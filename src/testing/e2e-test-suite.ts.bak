/**
 * HASIVU Platform - Comprehensive E2E Test Suite
 * Production-ready end-to-end integration testing framework for comprehensive system validation
 * Provides automated testing across all platform features and user workflows
 */

import axios, { AxiosInstance, AxiosResponse, AxiosRequestConfig } from 'axios';
import { LoggerService } from '../shared/utils/logger';
import { config } from '../config/environment';

const logger = LoggerService.getInstance();

/**
 * Test Environment Configuration
 */
export interface E2ETestConfig {
  baseUrl: string;
  timeout: number;
  retries: number;
  apiKey?: string;
  authToken?: string;
  testDatabase: {
    host: string;
    port: number;
    database: string;
    username: string;
    password: string;
  };
  testUser: {
    email: string;
    password: string;
  };
  enableScreenshots: boolean;
  headless: boolean;
  browserViewport: {
    width: number;
    height: number;
  };
}

/**
 * Test Step Definition
 */
export interface E2ETestStep {
  name: string;
  action: 'GET' | 'POST' | 'PUT' | 'DELETE' | 'PATCH' | 'NAVIGATE' | 'CLICK' | 'INPUT' | 'WAIT' | 'VERIFY';
  target?: string; // URL or selector
  data?: any;
  expectedStatus?: number;
  expectedResponse?: any;
  timeout?: number;
  retries?: number;
  selector?: string; // For UI interactions
  value?: string; // For input actions
  waitFor?: string; // For wait actions
  assertion?: (response: any) => boolean;
  setup?: () => Promise<void>;
  cleanup?: () => Promise<void>;
}

/**
 * Test Scenario Definition
 */
export interface E2ETestScenario {
  name: string;
  description: string;
  category: 'authentication' | 'menu-management' | 'payment-processing' | 'user-journey' | 'admin-workflow' | 'integration' | 'performance';
  priority: 'high' | 'medium' | 'low';
  tags: string[];
  prerequisites?: string[];
  steps: E2ETestStep[];
  expectedDuration: number; // in milliseconds
  setup?: () => Promise<void>;
  cleanup?: () => Promise<void>;
  retryOnFailure: boolean;
  skipOnEnvironment?: string[];
}

/**
 * Test Result Interface
 */
export interface E2ETestResult {
  scenarioName: string;
  category: string;
  status: 'passed' | 'failed' | 'skipped' | 'error';
  duration: number;
  steps: E2EStepResult[];
  error?: string;
  timestamp: number;
  environment: string;
  retryCount: number;
  screenshots?: string[];
  performanceMetrics?: {
    loadTime: number;
    responseTime: number;
    memoryUsage: number;
    cpuUsage: number;
  };
}

/**
 * Individual Test Step Result
 */
export interface E2EStepResult {
  stepName: string;
  status: 'passed' | 'failed' | 'skipped' | 'error';
  duration: number;
  response?: any;
  error?: string;
  screenshot?: string;
  timestamp: number;
  retryCount: number;
}

/**
 * Test Suite Statistics
 */
export interface E2ETestStatistics {
  totalScenarios: number;
  passedScenarios: number;
  failedScenarios: number;
  skippedScenarios: number;
  totalSteps: number;
  passedSteps: number;
  failedSteps: number;
  totalDuration: number;
  averageDuration: number;
  successRate: number;
  coverage: {
    endpoints: number;
    userFlows: number;
    features: number;
  };
}

/**
 * Comprehensive E2E Test Suite Service
 * Orchestrates end-to-end testing across all platform features
 */
export class E2ETestSuite {
  private static instance: E2ETestSuite;
  private httpClient: AxiosInstance;
  private testConfig: E2ETestConfig;
  private testResults: E2ETestResult[] = [];
  private currentAuthToken?: string;
  private testStartTime: number = 0;

  private constructor(config: E2ETestConfig) {
    this.testConfig = config;
    this.initializeHttpClient();
  }

  /**
   * Get singleton instance
   */
  public static getInstance(config?: E2ETestConfig): E2ETestSuite {
    if (!E2ETestSuite.instance) {
      if (!config) {
        throw new Error('E2ETestSuite requires configuration on first initialization');
      }
      E2ETestSuite.instance = new E2ETestSuite(config);
    }
    return E2ETestSuite.instance;
  }

  /**
   * Initialize HTTP client with default configuration
   */
  private initializeHttpClient(): void {
    this.httpClient = axios.create({
      baseURL: this.testConfig.baseUrl,
      timeout: this.testConfig.timeout,
      headers: {
        'Content-Type': 'application/json',
        'User-Agent': 'HASIVU-E2E-Test-Suite/1.0',
        ...(this.testConfig.apiKey && { 'X-API-Key': this.testConfig.apiKey }),
        ...(this.testConfig.authToken && { 'Authorization': `Bearer ${this.testConfig.authToken}` })
      }
    });

    // Request interceptor
    this.httpClient.interceptors.request.use((config) => {
      logger.debug('E2E Test Request', {
        method: config.method?.toUpperCase(),
        url: config.url,
        headers: config.headers
      });
      return config;
    });

    // Response interceptor
    this.httpClient.interceptors.response.use(
      (response) => {
        logger.debug('E2E Test Response', {
          status: response.status,
          url: response.config.url,
          duration: response.headers['x-response-time'] || 'unknown'
        });
        return response;
      },
      (error) => {
        logger.error('E2E Test Request Failed', {
          error: error instanceof Error ? error.message : String(error),
          status: error.response?.status,
          url: error.config?.url
        });
        return Promise.reject(error);
      }
    );
  }

  /**
   * Run single test scenario
   */
  public async runTestScenario(scenario: E2ETestScenario): Promise<E2ETestResult> {
    const startTime = Date.now();
    const steps: E2EStepResult[] = [];
    let retryCount = 0;

    logger.info(`Starting test scenario: ${scenario.name}`, {
      category: scenario.category,
      priority: scenario.priority,
      stepsCount: scenario.steps.length
    });

    // Check environment skip conditions
    if (scenario.skipOnEnvironment?.includes(process.env.NODE_ENV || 'development')) {
      logger.info(`Skipping scenario ${scenario.name} for environment: ${process.env.NODE_ENV}`);
      return {
        scenarioName: scenario.name,
        category: scenario.category,
        status: 'skipped',
        duration: Date.now() - startTime,
        steps: [],
        timestamp: startTime,
        environment: process.env.NODE_ENV || 'development',
        retryCount: 0
      };
    }

    try {
      // Run scenario setup if provided
      if (scenario.setup) {
        await scenario.setup();
      }

      // Execute test steps
      for (const step of scenario.steps) {
        const stepResult = await this.executeTestStep(step, scenario.name);
        steps.push(stepResult);

        if (stepResult.status === 'failed' && !scenario.retryOnFailure) {
          break;
        }
      }

      // Run scenario cleanup if provided
      if (scenario.cleanup) {
        await scenario.cleanup();
      }

      const duration = Date.now() - startTime;
      const allStepsPassed = steps.every(step => step.status === 'passed');

      const result: E2ETestResult = {
        scenarioName: scenario.name,
        category: scenario.category,
        status: allStepsPassed ? 'passed' : 'failed',
        duration,
        steps,
        timestamp: startTime,
        environment: process.env.NODE_ENV || 'development',
        retryCount
      };

      logger.info(`Completed test scenario: ${scenario.name}`, {
        status: result.status,
        duration: `${duration}ms`,
        stepsCount: steps.length,
        expectedDuration: `${scenario.expectedDuration}ms`,
        performanceDelta: duration - scenario.expectedDuration
      });

      return result;
    } catch (error: any) {
      const duration = Date.now() - startTime;
      
      logger.error(`Test scenario failed with error: ${scenario.name}`, {
        error: error instanceof Error ? error.message : String(error),
        duration: `${duration}ms`,
        completedSteps: steps.length
      });

      return {
        scenarioName: scenario.name,
        category: scenario.category,
        status: 'error',
        duration,
        steps,
        error: error instanceof Error ? error.message : String(error),
        timestamp: startTime,
        environment: process.env.NODE_ENV || 'development',
        retryCount
      };
    }
  }

  /**
   * Execute individual test step
   */
  private async executeTestStep(step: E2ETestStep, scenarioName: string): Promise<E2EStepResult> {
    const startTime = Date.now();
    let retryCount = 0;
    const maxRetries = step.retries || this.testConfig.retries;

    logger.debug(`Executing test step: ${step.name}`, {
      scenario: scenarioName,
      action: step.action,
      target: step.target
    });

    while (retryCount <= maxRetries) {
      try {
        // Run step setup if provided
        if (step.setup) {
          await step.setup();
        }

        let response: any;

        // Execute step based on action type
        switch (step.action) {
          case 'GET':
            response = await this.httpClient.get(step.target!, step.data);
            break;
          case 'POST':
            response = await this.httpClient.post(step.target!, step.data);
            break;
          case 'PUT':
            response = await this.httpClient.put(step.target!, step.data);
            break;
          case 'DELETE':
            response = await this.httpClient.delete(step.target!, { data: step.data });
            break;
          case 'PATCH':
            response = await this.httpClient.patch(step.target!, step.data);
            break;
          case 'NAVIGATE':
            // Browser navigation logic would go here
            response = { status: 200, data: { navigated: true, url: step.target } };
            break;
          case 'CLICK':
            // Browser click logic would go here
            response = { status: 200, data: { clicked: true, selector: step.selector } };
            break;
          case 'INPUT':
            // Browser input logic would go here
            response = { status: 200, data: { inputted: true, value: step.value } };
            break;
          case 'WAIT':
            await new Promise(resolve => setTimeout(resolve, parseInt(step.waitFor || '1000')));
            response = { status: 200, data: { waited: true, duration: step.waitFor } };
            break;
          case 'VERIFY':
            // Custom verification logic
            if (step.assertion && !step.assertion(response)) {
              throw new Error(`Verification failed: ${step.name}`);
            }
            response = { status: 200, data: { verified: true } };
            break;
          default:
            throw new Error(`Unknown test action: ${step.action}`);
        }

        // Validate response status if expected
        if (step.expectedStatus && response.status !== step.expectedStatus) {
          throw new Error(`Expected status ${step.expectedStatus} but got ${response.status}`);
        }

        // Validate response data if expected
        if (step.expectedResponse) {
          const responseMatches = JSON.stringify(response.data) === JSON.stringify(step.expectedResponse);
          if (!responseMatches) {
            throw new Error(`Response data does not match expected result`);
          }
        }

        // Run custom assertion if provided
        if (step.assertion && !step.assertion(response)) {
          throw new Error(`Custom assertion failed for step: ${step.name}`);
        }

        // Run step cleanup if provided
        if (step.cleanup) {
          await step.cleanup();
        }

        const duration = Date.now() - startTime;

        logger.debug(`Test step passed: ${step.name}`, {
          scenario: scenarioName,
          status: response.status,
          duration: `${duration}ms`,
          retryCount
        });

        return {
          stepName: step.name,
          status: 'passed',
          duration,
          response: response.data,
          timestamp: startTime,
          retryCount
        };
      } catch (error: any) {
        retryCount++;
        
        if (retryCount > maxRetries) {
          const duration = Date.now() - startTime;
          
          logger.error(`Test step failed: ${step.name}`, {
            scenario: scenarioName,
            error: error instanceof Error ? error.message : String(error),
            duration: `${duration}ms`,
            retryCount: retryCount - 1
          });

          return {
            stepName: step.name,
            status: 'failed',
            duration,
            error: error instanceof Error ? error.message : String(error),
            timestamp: startTime,
            retryCount: retryCount - 1
          };
        }

        // Wait before retry
        await new Promise(resolve => setTimeout(resolve, 1000 * retryCount));
        
        logger.warn(`Retrying test step: ${step.name}`, {
          scenario: scenarioName,
          retryCount,
          maxRetries,
          error: error instanceof Error ? error.message : String(error)
        });
      }
    }

    // This should never be reached, but TypeScript requires it
    throw new Error(`Unexpected end of executeTestStep for: ${step.name}`);
  }

  /**
   * Run complete test suite
   */
  public async runTestSuite(scenarios: E2ETestScenario[]): Promise<E2ETestResult[]> {
    this.testStartTime = Date.now();
    this.testResults = [];

    logger.info('Starting E2E Test Suite', {
      scenariosCount: scenarios.length,
      environment: process.env.NODE_ENV || 'development',
      baseUrl: this.testConfig.baseUrl
    });

    for (const scenario of scenarios) {
      const result = await this.runTestScenario(scenario);
      this.testResults.push(result);
    }

    const statistics = this.generateStatistics();
    
    logger.info('E2E Test Suite Completed', {
      ...statistics,
      totalDuration: `${Date.now() - this.testStartTime}ms`
    });

    return this.testResults;
  }

  /**
   * Run test scenarios in parallel
   */
  public async runTestSuiteParallel(scenarios: E2ETestScenario[], concurrency: number = 3): Promise<E2ETestResult[]> {
    this.testStartTime = Date.now();
    this.testResults = [];

    logger.info('Starting Parallel E2E Test Suite', {
      scenariosCount: scenarios.length,
      concurrency,
      environment: process.env.NODE_ENV || 'development'
    });

    // Group scenarios into batches
    const batches: E2ETestScenario[][] = [];
    for (let i = 0; i < scenarios.length; i += concurrency) {
      batches.push(scenarios.slice(i, i + concurrency));
    }

    // Execute batches sequentially, scenarios in parallel within each batch
    for (const batch of batches) {
      const batchPromises = batch.map(scenario => this.runTestScenario(scenario));
      const batchResults = await Promise.allSettled(batchPromises);
      
      batchResults.forEach((result, index) => {
        if (result.status === 'fulfilled') {
          this.testResults.push(result.value);
        } else {
          logger.error(`Test scenario failed with unhandled error: ${batch[index].name}`, {
            error: result.reason.message
          });
          
          this.testResults.push({
            scenarioName: batch[index].name,
            category: batch[index].category,
            status: 'error',
            duration: 0,
            steps: [],
            error: result.reason.message,
            timestamp: Date.now(),
            environment: process.env.NODE_ENV || 'development',
            retryCount: 0
          });
        }
      });
    }

    const statistics = this.generateStatistics();
    
    logger.info('Parallel E2E Test Suite Completed', {
      ...statistics,
      totalDuration: `${Date.now() - this.testStartTime}ms`
    });

    return this.testResults;
  }

  /**
   * Generate test statistics
   */
  public generateStatistics(): E2ETestStatistics {
    const totalScenarios = this.testResults.length;
    const passedScenarios = this.testResults.filter(r => r.status === 'passed').length;
    const failedScenarios = this.testResults.filter(r => r.status === 'failed').length;
    const skippedScenarios = this.testResults.filter(r => r.status === 'skipped').length;

    const allSteps = this.testResults.flatMap(r => r.steps);
    const totalSteps = allSteps.length;
    const passedSteps = allSteps.filter(s => s.status === 'passed').length;
    const failedSteps = allSteps.filter(s => s.status === 'failed').length;

    const totalDuration = this.testResults.reduce((sum, r) => sum + r.duration, 0);
    const averageDuration = totalScenarios > 0 ? totalDuration / totalScenarios : 0;
    const successRate = totalScenarios > 0 ? (passedScenarios / totalScenarios) * 100 : 0;

    return {
      totalScenarios,
      passedScenarios,
      failedScenarios,
      skippedScenarios,
      totalSteps,
      passedSteps,
      failedSteps,
      totalDuration,
      averageDuration,
      successRate,
      coverage: {
        endpoints: this.calculateEndpointCoverage(),
        userFlows: this.calculateUserFlowCoverage(),
        features: this.calculateFeatureCoverage()
      }
    };
  }

  /**
   * Calculate endpoint coverage
   */
  private calculateEndpointCoverage(): number {
    const testedEndpoints = new Set();
    this.testResults.forEach(result => {
      result.steps.forEach(step => {
        if (step.stepName.includes('/api/')) {
          testedEndpoints.add(step.stepName);
        }
      });
    });
    return testedEndpoints.size;
  }

  /**
   * Calculate user flow coverage
   */
  private calculateUserFlowCoverage(): number {
    const userFlows = new Set();
    this.testResults.forEach(result => {
      if (result.category === 'user-journey') {
        userFlows.add(result.scenarioName);
      }
    });
    return userFlows.size;
  }

  /**
   * Calculate feature coverage
   */
  private calculateFeatureCoverage(): number {
    const features = new Set();
    this.testResults.forEach(result => {
      features.add(result.category);
    });
    return features.size;
  }

  /**
   * Export test results to JSON
   */
  public exportResults(format: 'json' | 'html' | 'junit' = 'json'): string {
    const statistics = this.generateStatistics();
    const exportData = {
      testSuite: 'HASIVU Platform E2E Tests',
      timestamp: new Date().toISOString(),
      environment: process.env.NODE_ENV || 'development',
      configuration: {
        baseUrl: this.testConfig.baseUrl,
        timeout: this.testConfig.timeout,
        retries: this.testConfig.retries
      },
      statistics,
      results: this.testResults
    };

    switch (format) {
      case 'json':
        return JSON.stringify(exportData, null, 2);
      case 'html':
        return this.generateHtmlReport(exportData);
      case 'junit':
        return this.generateJunitReport(exportData);
      default:
        return JSON.stringify(exportData, null, 2);
    }
  }

  /**
   * Generate HTML report
   */
  private generateHtmlReport(data: any): string {
    return `
<!DOCTYPE html>
<html>
<head>
    <title>HASIVU Platform E2E Test Report</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .header { background: #f5f5f5; padding: 20px; border-radius: 5px; }
        .stats { display: flex; gap: 20px; margin: 20px 0; }
        .stat-card { background: #fff; border: 1px solid #ddd; padding: 15px; border-radius: 5px; flex: 1; }
        .passed { color: #28a745; }
        .failed { color: #dc3545; }
        .skipped { color: #ffc107; }
        .scenario { margin: 10px 0; padding: 15px; border: 1px solid #ddd; border-radius: 5px; }
        .step { margin: 5px 0; padding: 10px; background: #f9f9f9; border-radius: 3px; }
    </style>
</head>
<body>
    <div class="header">
        <h1>HASIVU Platform E2E Test Report</h1>
        <p>Generated: ${data.timestamp}</p>
        <p>Environment: ${data.environment}</p>
        <p>Base URL: ${data.configuration.baseUrl}</p>
    </div>
    
    <div class="stats">
        <div class="stat-card">
            <h3>Total Scenarios</h3>
            <p>${data.statistics.totalScenarios}</p>
        </div>
        <div class="stat-card">
            <h3 class="passed">Passed</h3>
            <p>${data.statistics.passedScenarios}</p>
        </div>
        <div class="stat-card">
            <h3 class="failed">Failed</h3>
            <p>${data.statistics.failedScenarios}</p>
        </div>
        <div class="stat-card">
            <h3>Success Rate</h3>
            <p>${data.statistics.successRate.toFixed(2)}%</p>
        </div>
    </div>
    
    <div class="scenarios">
        ${data.results.map((result: E2ETestResult) => `
            <div class="scenario ${result.status}">
                <h3>${result.scenarioName} (${result.category})</h3>
                <p>Status: <span class="${result.status}">${result.status.toUpperCase()}</span></p>
                <p>Duration: ${result.duration}ms</p>
                <p>Steps: ${result.steps.length}</p>
                ${result.error ? `<p class="failed">Error: ${result.error}</p>` : ''}
            </div>
        `).join('')}
    </div>
</body>
</html>
    `;
  }

  /**
   * Generate JUnit XML report
   */
  private generateJunitReport(data: any): string {
    const testsuites = data.results.map((result: E2ETestResult) => `
        <testsuite name="${result.scenarioName}" tests="${result.steps.length}" failures="${result.steps.filter((s: E2EStepResult) => s.status === 'failed').length}" time="${result.duration / 1000}">
            ${result.steps.map((step: E2EStepResult) => `
                <testcase name="${step.stepName}" time="${step.duration / 1000}" classname="${result.category}">
                    ${step.status === 'failed' ? `<failure message="${step.error}">${step.error}</failure>` : ''}
                </testcase>
            `).join('')}
        </testsuite>
    `).join('');

    return `<?xml version="1.0" encoding="UTF-8"?>
<testsuites name="HASIVU Platform E2E Tests" tests="${data.statistics.totalScenarios}" failures="${data.statistics.failedScenarios}" time="${data.statistics.totalDuration / 1000}">
    ${testsuites}
</testsuites>`;
  }

  /**
   * Set authentication token for API requests
   */
  public setAuthToken(token: string): void {
    this.currentAuthToken = token;
    this.httpClient.defaults.headers.common['Authorization'] = `Bearer ${token}`;
    
    logger.debug('Authentication token updated for E2E tests', {
      tokenLength: token.length,
      tokenPrefix: token.substring(0, 8) + '...'
    });
  }

  /**
   * Clear authentication token
   */
  public clearAuthToken(): void {
    this.currentAuthToken = undefined;
    delete this.httpClient.defaults.headers.common['Authorization'];
    
    logger.debug('Authentication token cleared for E2E tests');
  }

  /**
   * Get current test results
   */
  public getResults(): E2ETestResult[] {
    return this.testResults;
  }

  /**
   * Clear test results
   */
  public clearResults(): void {
    this.testResults = [];
    logger.debug('E2E test results cleared');
  }

  /**
   * Health check for test environment
   */
  public async healthCheck(): Promise<{
    status: 'healthy' | 'unhealthy';
    timestamp: number;
    checks: {
      apiConnectivity: boolean;
      databaseConnectivity: boolean;
      authService: boolean;
      testConfiguration: boolean;
    };
    error?: string;
  }> {
    try {
      const checks = {
        apiConnectivity: false,
        databaseConnectivity: false,
        authService: false,
        testConfiguration: true
      };

      // Test API connectivity
      try {
        const response = await this.httpClient.get('/health');
        checks.apiConnectivity = response.status === 200;
      } catch (error: unknown) {
        logger.warn('API connectivity check failed', { error: error instanceof Error ? error.message : 'Unknown error' });
      }

      // Test authentication service
      if (this.currentAuthToken) {
        try {
          const response = await this.httpClient.get('/auth/verify', {
            headers: { Authorization: `Bearer ${this.currentAuthToken}` }
          });
          checks.authService = response.status === 200;
        } catch (error: unknown) {
          logger.warn('Auth service check failed', { error: error instanceof Error ? error.message : 'Unknown error' });
        }
      }

      const allHealthy = Object.values(checks).every(Boolean);

      return {
        status: allHealthy ? 'healthy' : 'unhealthy',
        timestamp: Date.now(),
        checks
      };
    } catch (error: any) {
      logger.error('E2E test environment health check failed', {
        error: error instanceof Error ? error.message : String(error)
      });

      return {
        status: 'unhealthy',
        timestamp: Date.now(),
        checks: {
          apiConnectivity: false,
          databaseConnectivity: false,
          authService: false,
          testConfiguration: false
        },
        error: error instanceof Error ? error.message : String(error)
      };
    }
  }
}

/**
 * Test Scenario Builder Utility
 */
export class E2EScenarioBuilder {
  private scenario: Partial<E2ETestScenario> = {
    steps: [],
    retryOnFailure: true,
    tags: []
  };

  public name(name: string): E2EScenarioBuilder {
    this.scenario.name = name;
    return this;
  }

  public description(description: string): E2EScenarioBuilder {
    this.scenario.description = description;
    return this;
  }

  public category(category: E2ETestScenario['category']): E2EScenarioBuilder {
    this.scenario.category = category;
    return this;
  }

  public priority(priority: E2ETestScenario['priority']): E2EScenarioBuilder {
    this.scenario.priority = priority;
    return this;
  }

  public tags(tags: string[]): E2EScenarioBuilder {
    this.scenario.tags = tags;
    return this;
  }

  public expectedDuration(duration: number): E2EScenarioBuilder {
    this.scenario.expectedDuration = duration;
    return this;
  }

  public addStep(step: E2ETestStep): E2EScenarioBuilder {
    this.scenario.steps!.push(step);
    return this;
  }

  public addApiCall(name: string, method: E2ETestStep['action'], endpoint: string, data?: any, expectedStatus: number = 200): E2EScenarioBuilder {
    this.scenario.steps!.push({
      name,
      action: method,
      target: endpoint,
      data,
      expectedStatus
    });
    return this;
  }

  public addNavigation(name: string, url: string): E2EScenarioBuilder {
    this.scenario.steps!.push({
      name,
      action: 'NAVIGATE',
      target: url
    });
    return this;
  }

  public addClick(name: string, selector: string): E2EScenarioBuilder {
    this.scenario.steps!.push({
      name,
      action: 'CLICK',
      selector
    });
    return this;
  }

  public addInput(name: string, selector: string, value: string): E2EScenarioBuilder {
    this.scenario.steps!.push({
      name,
      action: 'INPUT',
      selector,
      value
    });
    return this;
  }

  public addWait(name: string, duration: number): E2EScenarioBuilder {
    this.scenario.steps!.push({
      name,
      action: 'WAIT',
      waitFor: duration.toString()
    });
    return this;
  }

  public setup(setupFn: () => Promise<void>): E2EScenarioBuilder {
    this.scenario.setup = setupFn;
    return this;
  }

  public cleanup(cleanupFn: () => Promise<void>): E2EScenarioBuilder {
    this.scenario.cleanup = cleanupFn;
    return this;
  }

  public retryOnFailure(retry: boolean = true): E2EScenarioBuilder {
    this.scenario.retryOnFailure = retry;
    return this;
  }

  public skipOnEnvironment(environments: string[]): E2EScenarioBuilder {
    this.scenario.skipOnEnvironment = environments;
    return this;
  }

  public build(): E2ETestScenario {
    if (!this.scenario.name) {
      throw new Error('Scenario name is required');
    }
    if (!this.scenario.description) {
      throw new Error('Scenario description is required');
    }
    if (!this.scenario.category) {
      throw new Error('Scenario category is required');
    }
    if (!this.scenario.priority) {
      throw new Error('Scenario priority is required');
    }
    if (!this.scenario.expectedDuration) {
      throw new Error('Scenario expected duration is required');
    }

    return this.scenario as E2ETestScenario;
  }
}

// Export default test configuration
export const defaultE2EConfig: E2ETestConfig = {
  baseUrl: (config as any).api.baseUrl || 'http://localhost:3000',
  timeout: 30000,
  retries: 2,
  testDatabase: {
    host: process.env.TEST_DB_HOST || 'localhost',
    port: parseInt(process.env.TEST_DB_PORT || '5432'),
    database: process.env.TEST_DB_NAME || 'hasivu_test',
    username: process.env.TEST_DB_USER || 'test_user',
    password: process.env.TEST_DB_PASSWORD || 'test_password'
  },
  testUser: {
    email: process.env.TEST_USER_EMAIL || 'test@hasivu.com',
    password: process.env.TEST_USER_PASSWORD || 'test123'
  },
  enableScreenshots: process.env.NODE_ENV !== 'production',
  headless: process.env.NODE_ENV === 'production',
  browserViewport: {
    width: 1920,
    height: 1080
  }
};

// Export singleton instance
export const e2eTestSuite = E2ETestSuite.getInstance(defaultE2EConfig);