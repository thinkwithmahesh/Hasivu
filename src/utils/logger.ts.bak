/**
 * HASIVU Platform - Logging Service
 * Production-ready Winston logger with structured logging
 * Implements comprehensive logging with performance tracking
 * Generated by SuperClaude Wave 3: Epic 3 Implementation - UTILITIES
 */
import * as winston from 'winston';

// Environment detection
const NODE_ENV = process.env.NODE_ENV || 'development';
const LOG_LEVEL = process.env.LOG_LEVEL || (NODE_ENV === 'production' ? 'info' : 'debug');

/**
 * Custom log format for structured logging
 */
const logFormat = winston.format.combine(
  winston.format.timestamp({
    format: 'YYYY-MM-DD HH:mm:ss'
  }),
  winston.format.errors({ stack: true }),
  winston.format.json(),
  winston.format.printf(({ timestamp, level, message, service, ...meta }) => {
    const logEntry = {
      timestamp,
      level: level.toUpperCase(),
      message,
      service: service || 'hasivu-platform',
      environment: NODE_ENV,
      ...meta
    };

    return JSON.stringify(logEntry);
  })
);

/**
 * Console format for development
 */
const consoleFormat = winston.format.combine(
  winston.format.timestamp({
    format: 'YYYY-MM-DD HH:mm:ss'
  }),
  winston.format.errors({ stack: true }),
  winston.format.colorize({ all: true }),
  winston.format.printf(({ timestamp, level, message, service, ...meta }) => {
    let logMessage = `[${timestamp}] ${level}: ${message}`;
    
    if (service) {
      logMessage = `[${timestamp}] [${service}] ${level}: ${message}`;
    }
    
    if (Object.keys(meta).length > 0) {
      logMessage += `\n${JSON.stringify(meta, null, 2)}`;
    }
    
    return logMessage;
  })
);

/**
 * Create transports based on environment
 */
const transports: winston.transport[] = [
  new winston.transports.Console({
    format: NODE_ENV === 'production' ? logFormat : consoleFormat,
    level: LOG_LEVEL
  })
];

// Add file transport in production
if (NODE_ENV === 'production') {
  transports.push(
    new winston.transports.File({
      filename: 'logs/error.log',
      level: 'error',
      format: logFormat,
      maxsize: 10485760, // 10MB
      maxFiles: 5
    }),
    new winston.transports.File({
      filename: 'logs/combined.log',
      format: logFormat,
      maxsize: 10485760, // 10MB
      maxFiles: 10
    })
  );
}

/**
 * Create Winston logger instance
 */
const logger = winston.createLogger({
  level: LOG_LEVEL,
  format: logFormat,
  defaultMeta: {
    service: 'hasivu-platform',
    environment: NODE_ENV
  },
  transports,
  exitOnError: false,
  silent: NODE_ENV === 'test'
});

/**
 * Enhanced logging interface with performance tracking
 */
export interface LogContext {
  userId?: string;
  sessionId?: string;
  requestId?: string;
  duration?: number;
  statusCode?: number;
  method?: string;
  url?: string;
  userAgent?: string;
  ip?: string;
  [key: string]: any;
}

/**
 * Enhanced logger with additional methods
 */
export class Logger {
  private static instance: Logger;
  private logger: winston.Logger;

  constructor(logger: winston.Logger) {
    this.logger = logger;
  }

  /**
   * Get singleton instance of Logger
   */
  public static getInstance(): Logger {
    if (!Logger.instance) {
      Logger.instance = new Logger(logger);
    }
    return Logger.instance;
  }


  /**
   * Debug level logging
   */
  public debug(message: string, context?: LogContext): void {
    this.logger.debug(message, context);
  }

  /**
   * Info level logging
   */
  public info(message: string, context?: LogContext): void {
    this.logger.info(message, context);
  }

  /**
   * Warning level logging
   */
  public warn(message: string, context?: LogContext): void {
    this.logger.warn(message, context);
  }

  /**
   * Error level logging
   */
  public error(message: string, error?: Error | any, context?: LogContext): void {
    const errorContext = {
      ...context,
      ...(error && {
        error: {
          name: error.name,
          message: error.message,
          stack: error.stack,
          ...error
        }
      })
    };

    this.logger.error(message, errorContext);
  }

  /**
   * Performance logging with timing
   */
  public performance(message: string, duration: number, context?: LogContext): void {
    this.logger.info(message, {
      ...context,
      duration: `${duration}ms`,
      type: 'performance'
    });
  }

  /**
   * Security event logging
   */
  public security(message: string, context?: LogContext): void {
    this.logger.warn(message, {
      ...context,
      type: 'security',
      severity: 'high'
    });
  }

  /**
   * Audit logging
   */
  public audit(message: string, context?: LogContext): void {
    this.logger.info(message, {
      ...context,
      type: 'audit'
    });
  }

  /**
   * Database operation logging
   */
  public database(message: string, context?: LogContext): void {
    this.logger.debug(message, {
      ...context,
      type: 'database'
    });
  }

  /**
   * API request logging
   */
  public request(message: string, context?: LogContext): void {
    this.logger.info(message, {
      ...context,
      type: 'request'
    });
  }

  /**
   * Business logic logging
   */
  public business(message: string, context?: LogContext): void {
    this.logger.info(message, {
      ...context,
      type: 'business'
    });
  }

  /**
   * Integration logging (external services)
   */
  public integration(message: string, context?: LogContext): void {
    this.logger.info(message, {
      ...context,
      type: 'integration'
    });
  }

  /**
   * Function start logging (legacy compatibility)
   */
  public logFunctionStart(functionName: string, context?: LogContext): void {
    this.logger.info(`Function started: ${functionName}`, {
      ...context,
      type: 'function',
      event: 'start'
    });
  }

  /**
   * Function end logging (legacy compatibility)
   */
  public logFunctionEnd(functionName: string, context?: LogContext): void {
    this.logger.info(`Function completed: ${functionName}`, {
      ...context,
      type: 'function',
      event: 'end'
    });
  }

  /**
   * Create child logger with additional context
   */
  public child(defaultContext: LogContext): Logger {
    const childLogger = this.logger.child(defaultContext);
    return new Logger(childLogger);
  }

  /**
   * Get the underlying Winston logger
   */
  public getWinstonLogger(): winston.Logger {
    return this.logger;
  }
}

// Create and export enhanced logger instance
const enhancedLogger = new Logger(logger);

// Export both the enhanced logger and the basic logger for compatibility
export { enhancedLogger as logger };
export default enhancedLogger;

// Legacy export for backward compatibility
export const log = enhancedLogger;

/**
 * Request logging middleware helper
 */
export const createRequestLogger = (requestId: string, userId?: string) => {
  return enhancedLogger.child({
    requestId,
    userId,
    type: 'request'
  });
};

/**
 * Performance timer utility
 */
export class PerformanceTimer {
  private startTime: number;
  private label: string;
  private logger: Logger;

  constructor(label: string, logger: Logger = enhancedLogger) {
    this.label = label;
    this.logger = logger;
    this.startTime = Date.now();
  }

  /**
   * End timing and log performance
   */
  public end(context?: LogContext): number {
    const duration = Date.now() - this.startTime;
    this.logger.performance(`${this.label} completed`, duration, context);
    return duration;
  }

  /**
   * Get current duration without logging
   */
  public getDuration(): number {
    return Date.now() - this.startTime;
  }
}

/**
 * Create performance timer
 */
export const createTimer = (label: string): PerformanceTimer => {
  return new PerformanceTimer(label);
};

/**
 * Log structured errors
 */
export const logError = (error: Error, context?: LogContext): void => {
  enhancedLogger.error('Unhandled error occurred', error, context);
};

/**
 * Log structured warnings
 */
export const logWarning = (message: string, context?: LogContext): void => {
  enhancedLogger.warn(message, context);
};

/**
 * Log structured info
 */
export const logInfo = (message: string, context?: LogContext): void => {
  enhancedLogger.info(message, context);
};

/**
 * Log structured debug
 */
export const logDebug = (message: string, context?: LogContext): void => {
  enhancedLogger.debug(message, context);
};