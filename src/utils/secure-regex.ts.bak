/**
 * HASIVU Platform - Secure Regex Utilities
 * ReDoS-protected regex operations with timeout and validation
 */

/**
 * Secure regex result interface
 */
export interface SecureRegexResult {
  isMatch: boolean;
  error?: string;
  executionTime?: number;
}

/**
 * Secure regex configuration
 */
export interface SecureRegexConfig {
  timeout?: number; // milliseconds
  maxInputLength?: number;
  enablePerformanceMonitoring?: boolean;
}

/**
 * Default configuration for secure regex operations
 */
const DEFAULT_CONFIG: Required<SecureRegexConfig> = {
  timeout: 1000, // 1 second timeout
  maxInputLength: 10000, // 10KB max input
  enablePerformanceMonitoring: true
};

/**
 * Secure regex class with ReDoS protection
 */
export class SecureRegex {
  private config: Required<SecureRegexConfig>;

  constructor(config: SecureRegexConfig = {}) {
    this.config = { ...DEFAULT_CONFIG, ...config };
  }

  /**
   * Execute regex with timeout protection
   */
  public test(pattern: RegExp | string, input: string): SecureRegexResult {
    const startTime = Date.now();

    try {
      // Input length validation
      if (input.length > this.config.maxInputLength) {
        return {
          isMatch: false,
          error: `Input length exceeds maximum allowed (${this.config.maxInputLength})`
        };
      }

      // Create regex instance
      const regex = typeof pattern === 'string' ? new RegExp(pattern) : pattern;

      // Execute with timeout using Promise race
      const result = this.executeWithTimeout(regex, input);
      const executionTime = Date.now() - startTime;

      return {
        isMatch: result,
        executionTime: this.config.enablePerformanceMonitoring ? executionTime : undefined
      };

    } catch (error: unknown) {
      const executionTime = Date.now() - startTime;
      return {
        isMatch: false,
        error: error instanceof Error ? (error instanceof Error ? error.message : String(error)) : 'Regex execution failed',
        executionTime: this.config.enablePerformanceMonitoring ? executionTime : undefined
      };
    }
  }

  /**
   * Execute regex matching with timeout protection
   */
  public match(pattern: RegExp | string, input: string): RegExpMatchArray | null {
    const result = this.test(pattern, input);

    if (!result.isMatch || result.error) {
      return null;
    }

    const regex = typeof pattern === 'string' ? new RegExp(pattern) : pattern;
    return input.match(regex);
  }

  /**
   * Execute regex replace with timeout protection
   */
  public replace(pattern: RegExp | string, input: string, replacement: string): string {
    const result = this.test(pattern, input);

    if (result.error) {
      throw new Error(`Regex replace failed: ${result.error}`);
    }

    const regex = typeof pattern === 'string' ? new RegExp(pattern, 'g') : pattern;
    return input.replace(regex, replacement);
  }

  /**
   * Execute regex with timeout using a simple approach
   * Note: This is a simplified timeout implementation
   */
  private executeWithTimeout(regex: RegExp, input: string): boolean {
    const startTime = Date.now();

    // Check for potentially dangerous patterns
    if (this.isDangerousPattern(regex)) {
      throw new Error('Potentially dangerous regex pattern detected');
    }

    // Execute with periodic timeout checks
    let match;
    try {
      match = regex.test(input);

      // Check if execution took too long
      if (Date.now() - startTime > this.config.timeout) {
        throw new Error('Regex execution timeout');
      }

      return match;
    } catch (error: unknown) {
      if (Date.now() - startTime > this.config.timeout) {
        throw new Error('Regex execution timeout');
      }
      throw error;
    }
  }

  /**
   * Check if regex pattern is potentially dangerous
   */
  private isDangerousPattern(regex: RegExp): boolean {
    const pattern = regex.source;

    // Common ReDoS patterns
    const dangerousPatterns = [
      /\(\.\*\+\)/,           // (.*+)
      /\(\.\*\)\+/,           // (.*)+
      /\(\.\+\)\*/,           // (.+)*
      /\(\.\+\)\+/,           // (.+)+
      /\(\.\*\)\*/,           // (.*)*
      /\([^)]*\+[^)]*\)\+/,   // nested quantifiers
      /\([^)]*\*[^)]*\)\*/,   // nested quantifiers
      /\(\?\:\.\*\)\+/,       // (?:.*)+
      /\(\?\:\.\+\)\*/,       // (?:.+)*
    ];

    return dangerousPatterns.some(dangerous => dangerous.test(pattern));
  }
}

/**
 * Pre-compiled safe regex patterns for common validations
 */
export const SafeRegexPatterns = {
  // Password validation (safe bounded version)
  password: /^(?=.*[a-z])(?=.*[A-Z])(?=.*[0-9])(?=.*[!@#$%^&*])[\w!@#$%^&*]{8,128}$/,

  // Email validation (simplified safe version)
  email: /^[a-zA-Z0-9._%+-]{1,64}@[a-zA-Z0-9.-]{1,255}\.[a-zA-Z]{2,}$/,

  // Phone number validation (bounded)
  phone: /^[+]?[1-9]?[0-9]{7,15}$/,

  // UUID validation (bounded)
  uuid: /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i,

  // RFID card number (bounded)
  rfidCard: /^[0-9A-Fa-f]{8,16}$/,

  // Alphanumeric with limited special characters (bounded)
  safeString: /^[a-zA-Z0-9\s._-]{1,500}$/,

  // Safe file path (bounded)
  safePath: /^[a-zA-Z0-9/_.-]{1,1000}$/,

  // IP address validation (bounded)
  ipAddress: /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/,

  // URL validation (simplified safe version)
  url: /^https?:\/\/[a-zA-Z0-9.-]{1,255}(?:\:[0-9]{1,5})?(?:\/[a-zA-Z0-9._~:/?#[\]@!$&'()*+,;=%-]{0,2000})?$/,

  // Bearer token validation (bounded for JWT tokens)
  bearerToken: /^Bearer\s+([A-Za-z0-9._~+/=-]{1,2048})$/i,

  // Data URL validation (bounded for base64 images)
  dataUrl: /^data:image\/(jpeg|jpg|png|webp);base64,([A-Za-z0-9+/]{1,1398102}={0,2})$/,

  // Timestamp format validation (bounded)
  timestampFormat: /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}\.\d{3}Z$/
};

/**
 * Global secure regex instance
 */
export const secureRegex = new SecureRegex();

/**
 * Utility functions for common validations
 */
export const RegexValidators = {
  /**
   * Validate password with secure regex
   */
  validatePassword(password: string): SecureRegexResult {
    return secureRegex.test(SafeRegexPatterns.password, password);
  },

  /**
   * Validate email with secure regex
   */
  validateEmail(email: string): SecureRegexResult {
    return secureRegex.test(SafeRegexPatterns.email, email);
  },

  /**
   * Validate phone number with secure regex
   */
  validatePhone(phone: string): SecureRegexResult {
    return secureRegex.test(SafeRegexPatterns.phone, phone);
  },

  /**
   * Validate UUID with secure regex
   */
  validateUUID(uuid: string): SecureRegexResult {
    return secureRegex.test(SafeRegexPatterns.uuid, uuid);
  },

  /**
   * Validate RFID card number with secure regex
   */
  validateRfidCard(cardNumber: string): SecureRegexResult {
    return secureRegex.test(SafeRegexPatterns.rfidCard, cardNumber);
  },

  /**
   * Validate Bearer token with secure regex
   */
  validateBearerToken(authHeader: string): SecureRegexResult {
    return secureRegex.test(SafeRegexPatterns.bearerToken, authHeader);
  },

  /**
   * Validate data URL with secure regex
   */
  validateDataUrl(dataUrl: string): SecureRegexResult {
    return secureRegex.test(SafeRegexPatterns.dataUrl, dataUrl);
  },

  /**
   * Validate timestamp format with secure regex
   */
  validateTimestampFormat(timestamp: string): SecureRegexResult {
    return secureRegex.test(SafeRegexPatterns.timestampFormat, timestamp);
  },

  /**
   * Sanitize input string for safe regex operations
   */
  sanitizeInput(input: string, maxLength: number = 1000): string {
    if (typeof input !== 'string') {
      return '';
    }

    // Limit length
    const truncated = input.slice(0, maxLength);

    // Remove or escape potentially dangerous characters
    return truncated.replace(/[<>'"&]/g, '');
  }
};

/**
 * Performance monitoring for regex operations
 */
export class RegexPerformanceMonitor {
  private static metrics: Map<string, { count: number; totalTime: number; maxTime: number }> = new Map();

  /**
   * Record regex performance metrics
   */
  public static recordMetric(pattern: string, executionTime: number): void {
    const existing = this.metrics.get(pattern) || { count: 0, totalTime: 0, maxTime: 0 };

    existing.count++;
    existing.totalTime += executionTime;
    existing.maxTime = Math.max(existing.maxTime, executionTime);

    this.metrics.set(pattern, existing);
  }

  /**
   * Get performance report
   */
  public static getReport(): Record<string, any> {
    const report: Record<string, any> = {};

    this.metrics.forEach((metrics, pattern) => {
      report[pattern] = {
        count: metrics.count,
        averageTime: metrics.totalTime / metrics.count,
        maxTime: metrics.maxTime,
        totalTime: metrics.totalTime
      };
    });

    return report;
  }

  /**
   * Reset metrics
   */
  public static reset(): void {
    this.metrics.clear();
  }
}