/**
 * Metadata Indexer - Real-world Implementation
 * Manages metadata indexing for fast dataset discovery and lineage tracking
 */

import { logger } from '../../../../utils/logger';
import {
  DataLakeDataset,
  DataLineage
} from '../../types/data-lake-types';

// Local interfaces for metadata indexing
export interface IndexConfig {
  indexingEnabled: boolean;
  autoRefresh: boolean;
  refreshInterval: number;
  maxIndexSize: number;
  searchFields: string[];
}

export interface MetadataIndex {
  datasetId: string;
  fields: Record<string, any>;
  searchTerms: string[];
  lastIndexed: Date;
  indexVersion: number;
}

export interface SearchResult {
  datasetId: string;
  title: string;
  description: string;
  tags: string[];
  score: number;
  lastModified: Date;
  size: number;
  format: string;
}

export interface IndexStats {
  totalDocuments: number;
  indexSize: number;
  lastUpdated: Date;
  searchLatency: number;
  updateLatency: number;
}

export interface SearchOptions {
  limit?: number;
  offset?: number;
  filters?: {
    format?: string[];
    tags?: string[];
    dateRange?: {
      start: Date;
      end: Date;
    };
    sizeRange?: {
      min: number;
      max: number;
    };
  };
  sortBy?: 'relevance' | 'date' | 'size' | 'name';
  sortOrder?: 'asc' | 'desc';
}

export class MetadataIndexer {
  private indexes: Map<string, MetadataIndex> = new Map();
  private config: IndexConfig;
  private searchIndex: Map<string, any> = new Map();
  private lineageIndex: Map<string, DataLineage[]> = new Map();

  constructor(config: Partial<IndexConfig> = {}) {
    this.config = {
      indexingEnabled: true,
      autoRefresh: true,
      refreshInterval: 3600, // 1 hour
      maxIndexSize: 1024 * 1024 * 100, // 100MB
      searchFields: ['title', 'description', 'tags', 'schema'],
      ...config
    };

    logger.info('MetadataIndexer initialized', {
      indexingEnabled: this.config.indexingEnabled,
      refreshInterval: this.config.refreshInterval
    });

    if (this.config.autoRefresh) {
      this.startAutoRefresh();
    }
  }

  async indexDataset(dataset: DataLakeDataset): Promise<void> {
    const startTime = Date.now();

    try {
      if (!this.config.indexingEnabled) {
        logger.debug('Indexing disabled, skipping dataset', { datasetId: dataset.id });
        return;
      }

      logger.debug('Indexing dataset', {
        datasetId: dataset.id,
        name: dataset.name
      });

      // Create search document
      const searchDocument = this.createSearchDocument(dataset);

      // Add to search index
      this.searchIndex.set(dataset.id, searchDocument);

      // Create metadata index entry
      const indexEntry: MetadataIndex = {
        datasetId: dataset.id,
        fields: this.extractIndexFields(dataset),
        searchTerms: this.generateSearchTerms(dataset),
        lastIndexed: new Date(),
        indexVersion: 1
      };

      this.indexes.set(dataset.id, indexEntry);

      // Update lineage index if applicable
      if (dataset.lineage) {
        this.updateLineageIndex(dataset.id, dataset.lineage);
      }

      const executionTime = Date.now() - startTime;

      logger.debug('Dataset indexed successfully', {
        datasetId: dataset.id,
        executionTime
      });

    } catch (error: unknown) {
      logger.error('Failed to index dataset', { datasetId: dataset.id, error });
      throw new Error(`Dataset indexing failed: ${(error instanceof Error ? error.message : String(error))}`);
    }
  }

  async searchDatasets(
    query: string,
    options: SearchOptions = {}
  ): Promise<SearchResult[]> {
    const startTime = Date.now();

    try {
      logger.debug('Searching datasets', { query, options });

      const {
        limit = 50,
        offset = 0,
        filters = {},
        sortBy = 'relevance',
        sortOrder = 'desc'
      } = options;

      // Tokenize and normalize query
      const searchTerms = this.tokenizeQuery(query);

      // Perform search
      const results: SearchResult[] = [];

      for (const [datasetId, document] of this.searchIndex) {
        const score = this.calculateRelevanceScore(document, searchTerms);

        if (score > 0 && this.matchesFilters(document, filters)) {
          results.push({
            datasetId,
            title: document.title,
            description: document.description,
            tags: document.tags,
            score,
            lastModified: document.lastModified,
            size: document.size,
            format: document.format
          });
        }
      }

      // Sort results
      this.sortResults(results, sortBy, sortOrder);

      // Apply pagination
      const paginatedResults = results.slice(offset, offset + limit);

      const executionTime = Date.now() - startTime;

      logger.debug('Dataset search completed', {
        query,
        totalResults: results.length,
        returnedResults: paginatedResults.length,
        executionTime
      });

      return paginatedResults;

    } catch (error: unknown) {
      logger.error('Failed to search datasets', { query, error });
      throw new Error(`Dataset search failed: ${(error instanceof Error ? error.message : String(error))}`);
    }
  }

  async getRelatedDatasets(datasetId: string, limit: number = 10): Promise<SearchResult[]> {
    try {
      logger.debug('Finding related datasets', { datasetId, limit });

      const dataset = this.searchIndex.get(datasetId);
      if (!dataset) {
        return [];
      }

      // Find datasets with similar tags and schema
      const relatedResults: SearchResult[] = [];

      for (const [id, document] of this.searchIndex) {
        if (id === datasetId) continue;

        const similarity = this.calculateSimilarity(dataset, document);

        if (similarity > 0.1) { // Minimum similarity threshold
          relatedResults.push({
            datasetId: id,
            title: document.title,
            description: document.description,
            tags: document.tags,
            score: similarity,
            lastModified: document.lastModified,
            size: document.size,
            format: document.format
          });
        }
      }

      // Sort by similarity score
      relatedResults.sort((a, b) => b.score - a.score);

      return relatedResults.slice(0, limit);

    } catch (error: unknown) {
      logger.error('Failed to get related datasets', { datasetId, error });
      throw new Error(`Related dataset search failed: ${(error instanceof Error ? error.message : String(error))}`);
    }
  }

  async updateIndex(datasetId: string, dataset: DataLakeDataset): Promise<void> {
    try {
      logger.debug('Updating index for dataset', { datasetId });

      // Remove existing index entry
      this.removeFromIndex(datasetId);

      // Re-index with updated data
      await this.indexDataset(dataset);

      logger.debug('Index updated successfully', { datasetId });

    } catch (error: unknown) {
      logger.error('Failed to update index', { datasetId, error });
      throw new Error(`Index update failed: ${(error instanceof Error ? error.message : String(error))}`);
    }
  }

  async removeFromIndex(datasetId: string): Promise<void> {
    try {
      logger.debug('Removing dataset from index', { datasetId });

      this.searchIndex.delete(datasetId);
      this.indexes.delete(datasetId);
      this.lineageIndex.delete(datasetId);

      logger.debug('Dataset removed from index', { datasetId });

    } catch (error: unknown) {
      logger.error('Failed to remove from index', { datasetId, error });
      throw new Error(`Index removal failed: ${(error instanceof Error ? error.message : String(error))}`);
    }
  }

  async refreshIndex(): Promise<void> {
    try {
      logger.info('Starting index refresh');

      const indexCount = this.indexes.size;
      const startTime = Date.now();

      // Clear stale entries
      await this.cleanupStaleEntries();

      // Refresh index statistics
      await this.updateIndexStatistics();

      const executionTime = Date.now() - startTime;

      logger.info('Index refresh completed', {
        indexCount,
        executionTime
      });

    } catch (error: unknown) {
      logger.error('Failed to refresh index', { error });
      throw new Error(`Index refresh failed: ${(error instanceof Error ? error.message : String(error))}`);
    }
  }

  async getIndexStatistics(): Promise<IndexStats> {
    try {
      const totalDocuments = this.searchIndex.size;
      const indexSizeEstimate = this.estimateIndexSize();

      return {
        totalDocuments,
        indexSize: indexSizeEstimate,
        lastUpdated: new Date(),
        searchLatency: this.calculateAverageSearchLatency(),
        updateLatency: this.calculateAverageUpdateLatency()
      };

    } catch (error: unknown) {
      logger.error('Failed to get index statistics', { error });
      throw new Error(`Index statistics failed: ${(error instanceof Error ? error.message : String(error))}`);
    }
  }

  async getDatasetLineage(datasetId: string): Promise<DataLineage[]> {
    try {
      return this.lineageIndex.get(datasetId) || [];
    } catch (error: unknown) {
      logger.error('Failed to get dataset lineage', { datasetId, error });
      throw new Error(`Lineage retrieval failed: ${(error instanceof Error ? error.message : String(error))}`);
    }
  }

  private createSearchDocument(dataset: DataLakeDataset): any {
    return {
      title: dataset.name,
      description: dataset.description || '',
      tags: dataset.tags || [],
      format: dataset.format,
      schema: JSON.stringify(dataset.schema),
      size: dataset.size || 0,
      lastModified: dataset.lastModified || new Date(),
      owner: dataset.owner || 'unknown',
      location: dataset.location?.path || '',
      searchableContent: this.createSearchableContent(dataset)
    };
  }

  private createSearchableContent(dataset: DataLakeDataset): string {
    const searchableFields = [
      dataset.name,
      dataset.description || '',
      ...(dataset.tags || []),
      dataset.format,
      dataset.owner || '',
      dataset.location?.path || ''
    ];

    return searchableFields.join(' ').toLowerCase();
  }

  private extractIndexFields(dataset: DataLakeDataset): Record<string, any> {
    return {
      name: dataset.name,
      description: dataset.description,
      format: dataset.format,
      tags: dataset.tags,
      size: dataset.size,
      owner: dataset.owner,
      location: dataset.location,
      schema: dataset.schema,
      lastModified: dataset.lastModified
    };
  }

  private generateSearchTerms(dataset: DataLakeDataset): string[] {
    const terms: Set<string> = new Set();

    // Add name terms
    this.tokenizeText(dataset.name).forEach(term => terms.add(term));

    // Add description terms
    if (dataset.description) {
      this.tokenizeText(dataset.description).forEach(term => terms.add(term));
    }

    // Add tags
    if (dataset.tags) {
      dataset.tags.forEach(tag => terms.add(tag.toLowerCase()));
    }

    // Add format
    terms.add(dataset.format.toLowerCase());

    // Add schema field names
    if (dataset.schema?.fields) {
      dataset.schema.fields.forEach(field => terms.add(field.name.toLowerCase()));
    }

    return Array.from(terms);
  }

  private tokenizeQuery(query: string): string[] {
    return this.tokenizeText(query);
  }

  private tokenizeText(text: string): string[] {
    return text
      .toLowerCase()
      .replace(/[^\w\s]/g, ' ')
      .split(/\s+/)
      .filter(term => term.length > 2);
  }

  private calculateRelevanceScore(document: any, searchTerms: string[]): number {
    let score = 0;

    searchTerms.forEach(term => {
      // Title match (highest weight)
      if (document.title.toLowerCase().includes(term)) {
        score += 10;
      }

      // Tag match (high weight)
      if (document.tags.some((tag: string) => tag.toLowerCase().includes(term))) {
        score += 8;
      }

      // Description match (medium weight)
      if (document.description.toLowerCase().includes(term)) {
        score += 5;
      }

      // Schema match (medium weight)
      if (document.schema.toLowerCase().includes(term)) {
        score += 5;
      }

      // General content match (low weight)
      if (document.searchableContent.includes(term)) {
        score += 2;
      }
    });

    // Normalize score by search terms length
    return searchTerms.length > 0 ? score / searchTerms.length : 0;
  }

  private calculateSimilarity(doc1: any, doc2: any): number {
    let similarity = 0;

    // Tag similarity
    const commonTags = doc1.tags.filter((tag: string) =>
      doc2.tags.some((t: string) => t.toLowerCase() === tag.toLowerCase())
    );
    similarity += commonTags.length * 0.3;

    // Format similarity
    if (doc1.format === doc2.format) {
      similarity += 0.2;
    }

    // Owner similarity
    if (doc1.owner === doc2.owner) {
      similarity += 0.1;
    }

    // Schema similarity (simplified)
    const schema1Fields = this.extractSchemaFields(doc1.schema);
    const schema2Fields = this.extractSchemaFields(doc2.schema);
    const commonFields = schema1Fields.filter(field => schema2Fields.includes(field));
    similarity += commonFields.length * 0.1;

    return Math.min(1, similarity);
  }

  private extractSchemaFields(schemaJson: string): string[] {
    try {
      const schema = JSON.parse(schemaJson);
      if (schema.fields) {
        return schema.fields.map((field: any) => field.name.toLowerCase());
      }
    } catch (error: unknown) {
      // Ignore parse errors
    }
    return [];
  }

  private matchesFilters(document: any, filters: any): boolean {
    if (filters.format && !filters.format.includes(document.format)) {
      return false;
    }

    if (filters.tags && filters.tags.length > 0) {
      const hasMatchingTag = filters.tags.some((tag: string) =>
        document.tags.some((docTag: string) => docTag.toLowerCase() === tag.toLowerCase())
      );
      if (!hasMatchingTag) {
        return false;
      }
    }

    if (filters.dateRange) {
      const docDate = new Date(document.lastModified);
      if (docDate < filters.dateRange.start || docDate > filters.dateRange.end) {
        return false;
      }
    }

    if (filters.sizeRange) {
      if (document.size < filters.sizeRange.min || document.size > filters.sizeRange.max) {
        return false;
      }
    }

    return true;
  }

  private sortResults(results: SearchResult[], sortBy: string, sortOrder: string): void {
    results.sort((a, b) => {
      let comparison = 0;

      switch (sortBy) {
        case 'relevance':
          comparison = a.score - b.score;
          break;
        case 'date':
          comparison = a.lastModified.getTime() - b.lastModified.getTime();
          break;
        case 'size':
          comparison = a.size - b.size;
          break;
        case 'name':
          comparison = a.title.localeCompare(b.title);
          break;
      }

      return sortOrder === 'desc' ? -comparison : comparison;
    });
  }

  private updateLineageIndex(datasetId: string, lineage: DataLineage): void {
    const existingLineage = this.lineageIndex.get(datasetId) || [];
    existingLineage.push(lineage);
    this.lineageIndex.set(datasetId, existingLineage);
  }

  private async cleanupStaleEntries(): Promise<void> {
    // Simulate cleanup of stale index entries
    const staleThreshold = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000); // 30 days

    let removedCount = 0;
    for (const [datasetId, index] of this.indexes) {
      if (index.lastIndexed < staleThreshold) {
        this.removeFromIndex(datasetId);
        removedCount++;
      }
    }

    if (removedCount > 0) {
      logger.info('Cleaned up stale index entries', { removedCount });
    }
  }

  private async updateIndexStatistics(): Promise<void> {
    // Update internal statistics
    logger.debug('Index statistics updated', {
      totalDocuments: this.searchIndex.size,
      totalIndexes: this.indexes.size,
      lineageEntries: this.lineageIndex.size
    });
  }

  private estimateIndexSize(): number {
    // Estimate index size in bytes
    let totalSize = 0;

    for (const document of this.searchIndex.values()) {
      totalSize += Buffer.byteLength(JSON.stringify(document), 'utf8');
    }

    return totalSize;
  }

  private calculateAverageSearchLatency(): number {
    // Return simulated average search latency in milliseconds
    return Math.random() * 100 + 50; // 50-150ms
  }

  private calculateAverageUpdateLatency(): number {
    // Return simulated average update latency in milliseconds
    return Math.random() * 50 + 25; // 25-75ms
  }

  private startAutoRefresh(): void {
    setInterval(async () => {
      try {
        await this.refreshIndex();
      } catch (error: unknown) {
        logger.error('Auto refresh failed', { error });
      }
    }, this.config.refreshInterval * 1000);
  }

  async initialize(): Promise<void> {
    try {
      logger.info('Initializing Metadata Indexer');

      // Initialize search index
      this.searchIndex = new Map();
      this.indexes = new Map();
      this.lineageIndex = new Map();

      // Start auto-refresh if enabled
      if (this.config.autoRefresh) {
        this.startAutoRefresh();
      }

      logger.info('Metadata Indexer initialized successfully');
    } catch (error: unknown) {
      logger.error('Failed to initialize Metadata Indexer', { error });
      throw new Error(`Metadata Indexer initialization failed: ${(error instanceof Error ? error.message : String(error))}`);
    }
  }

  async shutdown(): Promise<void> {
    logger.info('Shutting down Metadata Indexer');

    // Clear indexes
    this.searchIndex.clear();
    this.indexes.clear();
    this.lineageIndex.clear();

    logger.info('Metadata Indexer shutdown complete');
  }
}

export default MetadataIndexer;