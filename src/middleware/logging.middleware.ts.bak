/**
 * HASIVU Platform - Logging Middleware
 * Comprehensive logging system for request tracking and audit trails
 * Implements security and performance logging requirements
 */
import { Request, Response, NextFunction } from 'express';
import { logger } from '../utils/logger';
import { performance } from 'perf_hooks';

/**
 * Extended request interface with logging properties
 */
export interface LoggedRequest extends Request {
  requestId?: string;
  startTime?: number;
  userAgent?: string;
  clientIp?: string;
}

/**
 * Main logging middleware - tracks all requests
 */
export const loggingMiddleware = (
  req: LoggedRequest,
  res: Response,
  next: NextFunction
): void => {
  try {
    // Generate unique request ID
    req.requestId = `req_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    req.startTime = performance.now();
    
    // Extract client information
    req.clientIp = req.ip || req.connection.remoteAddress || 'unknown';
    req.userAgent = req.get('User-Agent') || 'unknown';

    // Log incoming request
    logger.info('Incoming request', {
      requestId: req.requestId,
      method: req.method,
      url: req.url,
      path: req.path,
      clientIp: req.clientIp,
      userAgent: req.userAgent,
      headers: {
        authorization: req.headers.authorization ? 'Bearer [REDACTED]' : undefined,
        'content-type': req.headers['content-type'],
        'content-length': req.headers['content-length']
      }
    });

    // Log response when it finishes
    res.on('finish', () => {
      const duration = req.startTime ? performance.now() - req.startTime : 0;
      
      logger.info('Request completed', {
        requestId: req.requestId,
        method: req.method,
        url: req.url,
        statusCode: res.statusCode,
        duration: Math.round(duration * 100) / 100,
        contentLength: res.get('content-length'),
        userAgent: req.userAgent,
        clientIp: req.clientIp
      });
    });

    // Set request ID header for tracing
    res.set('X-Request-ID', req.requestId);
    
    next();
  } catch (error: unknown) {
    logger.error('Logging middleware error', {
      error: error instanceof Error ? error.message : 'Unknown error',
      stack: error instanceof Error ? error.stack : undefined,
      requestId: req.requestId
    });
    next(error);
  }
};

/**
 * Request logger for specific routes - detailed logging
 */
export const requestLogger = (
  req: LoggedRequest,
  res: Response,
  next: NextFunction
): void => {
  try {
    const sanitizedBody = req.body ? sanitizeLogData(req.body) : undefined;
    const sanitizedQuery = req.query ? sanitizeLogData(req.query) : undefined;

    logger.info('Route request details', {
      requestId: req.requestId,
      method: req.method,
      path: req.path,
      query: sanitizedQuery,
      body: sanitizedBody,
      params: req.params,
      clientIp: req.clientIp,
      timestamp: new Date().toISOString()
    });

    next();
  } catch (error: unknown) {
    logger.error('Request logger error', {
      error: error instanceof Error ? error.message : 'Unknown error',
      requestId: req.requestId
    });
    next(error);
  }
};

/**
 * Audit logger for sensitive operations
 */
export const auditLogger = (
  req: LoggedRequest,
  res: Response,
  next: NextFunction
): void => {
  try {
    const userId = (req as any).user?.id || 'anonymous';
    const userRole = (req as any).user?.role || 'unknown';

    logger.warn('Audit trail', {
      requestId: req.requestId,
      userId,
      userRole,
      method: req.method,
      path: req.path,
      clientIp: req.clientIp,
      userAgent: req.userAgent,
      timestamp: new Date().toISOString(),
      action: `${req.method} ${req.path}`,
      resource: extractResourceFromPath(req.path)
    });

    next();
  } catch (error: unknown) {
    logger.error('Audit logger error', {
      error: error instanceof Error ? error.message : 'Unknown error',
      requestId: req.requestId
    });
    next(error);
  }
};

/**
 * Error logging middleware
 */
export const errorLogger = (
  error: any,
  req: LoggedRequest,
  res: Response,
  next: NextFunction
): void => {
  const errorDetails = {
    requestId: req.requestId,
    error: {
      message: error.message,
      stack: error.stack,
      name: error.name,
      code: error.code
    },
    request: {
      method: req.method,
      url: req.url,
      path: req.path,
      clientIp: req.clientIp,
      userAgent: req.userAgent
    },
    user: {
      id: (req as any).user?.id || 'anonymous',
      role: (req as any).user?.role || 'unknown'
    },
    timestamp: new Date().toISOString()
  };

  if (error.status >= 500) {
    logger.error('Server error occurred', errorDetails);
  } else if (error.status >= 400) {
    logger.warn('Client error occurred', errorDetails);
  } else {
    logger.error('Unexpected error occurred', errorDetails);
  }

  next(error);
};

/**
 * Sanitize sensitive data from logs
 */
function sanitizeLogData(data: any): any {
  if (!data || typeof data !== 'object') return data;

  const sensitiveFields = [
    'password',
    'token',
    'secret',
    'key',
    'authorization',
    'cookie',
    'session'
  ];

  const sanitized = { ...data };
  
  for (const field of sensitiveFields) {
    if (field in sanitized) {
      sanitized[field] = '[REDACTED]';
    }
  }

  // Recursively sanitize nested objects
  for (const key in sanitized) {
    if (typeof sanitized[key] === 'object' && sanitized[key] !== null) {
      sanitized[key] = sanitizeLogData(sanitized[key]);
    }
  }

  return sanitized;
}

/**
 * Extract resource identifier from request path
 */
function extractResourceFromPath(path: string): string {
  const segments = path.split('/').filter(Boolean);
  
  if (segments.length === 0) return 'root';
  if (segments.length === 1) return segments[0];
  if (segments.length >= 2) return `${segments[0]}/${segments[1]}`;
  
  return segments[0];
}

export default loggingMiddleware;