/**
 * HASIVU Platform - CSRF Protection Middleware
 * Comprehensive CSRF protection with token validation and secure headers
 */

import { Request, Response, NextFunction } from 'express';
import { sessionService } from '../services/session.service';
import { logger } from '../utils/logger';

/**
 * Extended Request interface with CSRF token
 */
export interface CSRFRequest extends Request {
  csrfToken?: string;
  sessionId?: string;
}

/**
 * CSRF protection configuration
 */
export interface CSRFConfig {
  ignoreMethods?: string[];
  customHeaderName?: string;
  skipPaths?: string[];
  errorMessage?: string;
}

/**
 * Default CSRF configuration
 */
const defaultCSRFConfig: CSRFConfig = {
  ignoreMethods: ['GET', 'HEAD', 'OPTIONS'],
  customHeaderName: 'X-CSRF-Token',
  skipPaths: ['/health', '/metrics', '/auth/refresh'],
  errorMessage: 'Invalid CSRF token'
};

/**
 * CSRF Protection Middleware
 * Validates CSRF tokens for state-changing operations
 */
export const csrfProtection = (config: CSRFConfig = {}) => {
  const csrfConfig = { ...defaultCSRFConfig, ...config };

  return async (req: CSRFRequest, res: Response, next: NextFunction): Promise<void> => {
    try {
      // Skip CSRF protection for safe methods
      if (csrfConfig.ignoreMethods?.includes(req.method)) {
        next();
        return;
      }

      // Skip CSRF protection for specified paths
      if (csrfConfig.skipPaths?.some(path => req.path.startsWith(path))) {
        next();
        return;
      }

      // Get session ID from cookies or headers
      const sessionId = req.cookies?.sessionId || req.headers['x-session-id'] as string;

      if (!sessionId) {
        res.status(401).json({
          error: 'Authentication required',
          message: 'Session ID is required for CSRF protection'
        });
        return;
      }

      // Get CSRF token from header or body
      const csrfToken = req.headers[csrfConfig.customHeaderName!.toLowerCase()] as string ||
                       req.body?.csrfToken ||
                       req.query?.csrfToken as string;

      if (!csrfToken) {
        logger.warn('CSRF token missing', {
          method: req.method,
          path: req.path,
          sessionId,
          ip: req.ip,
          userAgent: req.get('User-Agent')
        });

        res.status(403).json({
          error: 'CSRF token required',
          message: 'CSRF token is required for this operation'
        });
        return;
      }

      // Validate CSRF token with session
      const isValidCSRF = await sessionService.validateCSRFToken(sessionId, csrfToken);

      if (!isValidCSRF) {
        logger.warn('Invalid CSRF token detected', {
          method: req.method,
          path: req.path,
          sessionId,
          ip: req.ip,
          userAgent: req.get('User-Agent'),
          providedToken: csrfToken.substring(0, 8) + '...' // Log only first 8 chars for security
        });

        res.status(403).json({
          error: 'Invalid CSRF token',
          message: csrfConfig.errorMessage || 'CSRF token validation failed'
        });
        return;
      }

      // Store validated CSRF token and session ID in request
      req.csrfToken = csrfToken;
      req.sessionId = sessionId;

      logger.debug('CSRF token validated successfully', {
        method: req.method,
        path: req.path,
        sessionId
      });

      next();

    } catch (error: unknown) {
      logger.error('CSRF protection middleware error', {
        error: error instanceof Error ? (error instanceof Error ? error.message : String(error)) : 'Unknown error',
        method: req.method,
        path: req.path,
        sessionId: req.sessionId
      });

      res.status(500).json({
        error: 'CSRF validation error',
        message: 'Failed to validate CSRF token'
      });
    }
  };
};

/**
 * Middleware to generate and attach new CSRF token to response
 */
export const attachCSRFToken = async (
  req: CSRFRequest,
  res: Response,
  next: NextFunction
): Promise<void> => {
  try {
    const sessionId = req.cookies?.sessionId || req.headers['x-session-id'] as string;

    if (sessionId) {
      // Generate new CSRF token
      const csrfData = await sessionService.generateCSRFToken(sessionId);

      // Attach CSRF token to response header
      res.setHeader('X-CSRF-Token', csrfData.token);

      // Optionally attach to response locals for template rendering
      res.locals.csrfToken = csrfData.token;

      logger.debug('CSRF token attached to response', {
        sessionId,
        tokenExpires: csrfData.expiresAt.toISOString()
      });
    }

    next();
  } catch (error: unknown) {
    logger.error('Failed to attach CSRF token', {
      error: error instanceof Error ? (error instanceof Error ? error.message : String(error)) : 'Unknown error',
      sessionId: req.sessionId
    });

    // Don't fail the request if CSRF token generation fails
    next();
  }
};

/**
 * Double Submit Cookie CSRF Protection
 * Alternative CSRF protection method using double submit pattern
 */
export const doubleSubmitCSRF = (config: CSRFConfig = {}) => {
  const csrfConfig = { ...defaultCSRFConfig, ...config };

  return (req: CSRFRequest, res: Response, next: NextFunction): void => {
    try {
      // Skip for safe methods
      if (csrfConfig.ignoreMethods?.includes(req.method)) {
        next();
        return;
      }

      // Skip for specified paths
      if (csrfConfig.skipPaths?.some(path => req.path.startsWith(path))) {
        next();
        return;
      }

      // Get CSRF token from cookie and header/body
      const cookieToken = req.cookies?.csrfToken;
      const headerToken = req.headers[csrfConfig.customHeaderName!.toLowerCase()] as string ||
                         req.body?.csrfToken;

      // Both tokens must exist and match
      if (!cookieToken || !headerToken) {
        res.status(403).json({
          error: 'CSRF token required',
          message: 'CSRF token must be provided in both cookie and header/body'
        });
        return;
      }

      if (cookieToken !== headerToken) {
        logger.warn('CSRF double submit validation failed', {
          method: req.method,
          path: req.path,
          ip: req.ip,
          userAgent: req.get('User-Agent')
        });

        res.status(403).json({
          error: 'Invalid CSRF token',
          message: 'CSRF token mismatch detected'
        });
        return;
      }

      next();

    } catch (error: unknown) {
      logger.error('Double submit CSRF protection error', {
        error: error instanceof Error ? (error instanceof Error ? error.message : String(error)) : 'Unknown error',
        method: req.method,
        path: req.path
      });

      res.status(500).json({
        error: 'CSRF validation error',
        message: 'Failed to validate CSRF token'
      });
    }
  };
};

/**
 * SameSite CSRF Protection
 * Relies on SameSite cookie attribute for CSRF protection
 */
export const sameSiteCSRF = (req: Request, res: Response, next: NextFunction): void => {
  try {
    // Check if request has proper SameSite headers
    const origin = req.headers.origin;
    const referer = req.headers.referer;
    const host = req.headers.host;

    // For state-changing operations, validate origin/referer
    if (['POST', 'PUT', 'DELETE', 'PATCH'].includes(req.method)) {
      if (!origin && !referer) {
        logger.warn('Missing origin and referer headers', {
          method: req.method,
          path: req.path,
          ip: req.ip
        });

        res.status(403).json({
          error: 'Invalid request',
          message: 'Origin or referer header required'
        });
        return;
      }

      // Validate origin matches host
      if (origin) {
        const originHost = new URL(origin).host;
        if (originHost !== host) {
          logger.warn('Origin host mismatch', {
            method: req.method,
            path: req.path,
            origin,
            host,
            ip: req.ip
          });

          res.status(403).json({
            error: 'Invalid origin',
            message: 'Request origin does not match host'
          });
          return;
        }
      }
    }

    next();
  } catch (error: unknown) {
    logger.error('SameSite CSRF protection error', {
      error: error instanceof Error ? (error instanceof Error ? error.message : String(error)) : 'Unknown error',
      method: req.method,
      path: req.path
    });

    res.status(500).json({
      error: 'Origin validation error',
      message: 'Failed to validate request origin'
    });
  }
};

/**
 * Combined CSRF Protection
 * Uses multiple CSRF protection methods for enhanced security
 */
export const enhancedCSRFProtection = (config: CSRFConfig = {}) => {
  return [
    sameSiteCSRF,
    csrfProtection(config),
    attachCSRFToken
  ];
};

/**
 * Get CSRF token endpoint
 * Provides CSRF token for client-side requests
 */
export const getCSRFToken = async (req: Request, res: Response): Promise<void> => {
  try {
    const sessionId = req.cookies?.sessionId;

    if (!sessionId) {
      res.status(401).json({
        error: 'Authentication required',
        message: 'Valid session required to get CSRF token'
      });
      return;
    }

    // Validate session first
    const sessionValidation = await sessionService.validateSession(sessionId, req);
    if (!sessionValidation.valid) {
      res.status(401).json({
        error: 'Invalid session',
        message: sessionValidation.error || 'Session validation failed'
      });
      return;
    }

    // Generate new CSRF token
    const csrfData = await sessionService.generateCSRFToken(sessionId);

    res.json({
      csrfToken: csrfData.token,
      expiresAt: csrfData.expiresAt.toISOString()
    });

  } catch (error: unknown) {
    logger.error('Failed to generate CSRF token', {
      error: error instanceof Error ? (error instanceof Error ? error.message : String(error)) : 'Unknown error'
    });

    res.status(500).json({
      error: 'CSRF token generation failed',
      message: 'Unable to generate CSRF token'
    });
  }
};

export default {
  csrfProtection,
  attachCSRFToken,
  doubleSubmitCSRF,
  sameSiteCSRF,
  enhancedCSRFProtection,
  getCSRFToken
};