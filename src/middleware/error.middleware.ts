/**
 * HASIVU Platform - Error Handling Middleware
 * Global error handler with structured error responses and logging
 * Generated by SuperClaude Wave 2: Backend Implementation
 */

import { Request, Response, NextFunction } from 'express';
import { logger } from '../shared/logger.service';
import { config } from '../config/environment';

/**
 * Custom error interface
 */
export interface AppError extends Error {
  statusCode?: number;
  code?: string;
  details?: any;
  isOperational?: boolean;
}

/**
 * Error response interface
 */
export interface ErrorResponse {
  success: false;
  error: {
    code: string;
    message: string;
    details?: any;
    timestamp: string;
    requestId?: string;
    path: string;
  };
}

/**
 * Predefined error codes and messages
 */
export const ErrorCodes = {
  VALIDATION_ERROR: 'VALIDATION_ERROR',
  AUTHENTICATION_ERROR: 'AUTHENTICATION_ERROR',
  AUTHORIZATION_ERROR: 'AUTHORIZATION_ERROR',
  NOT_FOUND: 'NOT_FOUND',
  DUPLICATE_RESOURCE: 'DUPLICATE_RESOURCE',
  RESOURCE_CONFLICT: 'RESOURCE_CONFLICT',
  RATE_LIMIT_EXCEEDED: 'RATE_LIMIT_EXCEEDED',
  SERVICE_UNAVAILABLE: 'SERVICE_UNAVAILABLE',
  DATABASE_ERROR: 'DATABASE_ERROR',
  EXTERNAL_API_ERROR: 'EXTERNAL_API_ERROR',
  CONFIGURATION_ERROR: 'CONFIGURATION_ERROR',
  INTERNAL_ERROR: 'INTERNAL_ERROR',
} as const;

/**
 * Create standardized error
 */
export function createError(
  code: string,
  message: string,
  statusCode: number = 500,
  details?: any
): AppError {
  const error = new Error(message) as AppError;
  error.code = code;
  error.statusCode = statusCode;
  error.details = details;
  error.isOperational = true;
  return error;
}

/**
 * Create validation error
 */
export function createValidationError(message: string, details?: any): AppError {
  return createError(ErrorCodes.VALIDATION_ERROR, message, 400, details);
}

/**
 * Create not found error
 */
export function createNotFoundError(resource: string, identifier?: string): AppError {
  const message = identifier
    ? `${resource} with identifier '${identifier}' not found`
    : `${resource} not found`;
  return createError(ErrorCodes.NOT_FOUND, message, 404);
}

/**
 * Create authentication error
 */
export function createAuthenticationError(message: string = 'Authentication required'): AppError {
  return createError(ErrorCodes.AUTHENTICATION_ERROR, message, 401);
}

/**
 * Create authorization error
 */
export function createAuthorizationError(message: string = 'Access denied'): AppError {
  return createError(ErrorCodes.AUTHORIZATION_ERROR, message, 403);
}

/**
 * Create rate limit error
 */
export function createRateLimitError(message: string = 'Too many requests'): AppError {
  return createError(ErrorCodes.RATE_LIMIT_EXCEEDED, message, 429);
}

/**
 * Create service unavailable error
 */
export function createServiceUnavailableError(
  message: string = 'Service temporarily unavailable'
): AppError {
  return createError(ErrorCodes.SERVICE_UNAVAILABLE, message, 503);
}

/**
 * Create conflict error
 */
export function createConflictError(message: string = 'Resource already exists'): AppError {
  return createError(ErrorCodes.RESOURCE_CONFLICT, message, 409);
}

/**
 * Create database error
 */
export function createDatabaseError(message: string, details?: any): AppError {
  return createError(ErrorCodes.DATABASE_ERROR, message, 500, details);
}

/**
 * Main error handling middleware
 */
export const errorHandler = (
  err: AppError,
  req: Request,
  res: Response,
  next: NextFunction
): void => {
  // Set default values for unhandled errors
  const statusCode = err.statusCode || 500;
  const errorCode = err.code || ErrorCodes.INTERNAL_ERROR;
  const message = err.message || 'Internal server error';
  const isProduction = config.server.nodeEnv === 'production';

  // Generate request ID
  const requestId = (req.headers['x-request-id'] as string) || generateRequestId();

  // Log error details
  logError(err, req, requestId);

  // Build error response
  const errorResponse: ErrorResponse = {
    success: false,
    error: {
      code: errorCode,
      message: isProduction && statusCode >= 500 ? 'Internal server error' : message,
      timestamp: new Date().toISOString(),
      requestId,
      path: req.path,
      ...(shouldIncludeDetails(statusCode, isProduction) && { details: err.details }),
    },
  };

  // Send error response
  res.status(statusCode).json(errorResponse);
};

/**
 * 404 Not Found handler
 */
export const notFoundHandler = (req: Request, res: Response, next: NextFunction): void => {
  const error = createNotFoundError('Route', `${req.method} ${req.originalUrl}`);
  next(error);
};

/**
 * Async handler wrapper to catch async errors
 */
export const asyncHandler = (fn: Function) => {
  return (req: Request, res: Response, next: NextFunction) => {
    Promise.resolve(fn(req, res, next)).catch(next);
  };
};

/**
 * Helper functions
 */

function generateRequestId(): string {
  return `req_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
}

function shouldIncludeDetails(statusCode: number, isProduction: boolean): boolean {
  // Don't include details in production for server errors
  if (isProduction && statusCode >= 500) {
    return false;
  }
  // Include details for client errors and in development
  return true;
}

function logError(err: AppError, req: Request, requestId: string): void {
  const logData = {
    requestId,
    error: {
      name: err.name,
      message: err.message,
      code: err.code,
      statusCode: err.statusCode,
      stack: err.stack,
      details: err.details,
    },
    request: {
      method: req.method,
      url: req.originalUrl,
      headers: req.headers,
      body: req.body,
      query: req.query,
      params: req.params,
      ip: req.ip,
      userAgent: req.get('User-Agent'),
    },
    timestamp: new Date().toISOString(),
  };

  // Log based on error severity
  if (err.statusCode && err.statusCode < 500) {
    // Client errors (4xx) - log as warning
    logger.warn('Client error occurred', logData);
  } else {
    // Server errors (5xx) - log as error
    logger.error('Server error occurred', undefined, {
      errorMessage: logData instanceof Error ? logData.message : String(logData),
    });
  }
}

/**
 * Validation error middleware
 */
export const validationErrorHandler = (req: Request, res: Response, next: NextFunction): void => {
  // This would typically be used with express-validator
  // For now, it's a placeholder that just calls next
  next();
};

/**
 * Database error transformer
 */
export const transformDatabaseError = (error: any): AppError => {
  // Transform different database errors to standard format
  if (error.code === 'P2002') {
    // Prisma unique constraint violation
    return createError(ErrorCodes.DUPLICATE_RESOURCE, 'Resource already exists', 409, {
      field: error.meta?.target,
    });
  }

  if (error.code === 'P2025') {
    // Prisma record not found
    return createNotFoundError('Resource');
  }

  if (error.code === 'P2003') {
    // Prisma foreign key constraint violation
    return createError(
      ErrorCodes.RESOURCE_CONFLICT,
      'Cannot perform operation due to related data',
      409
    );
  }

  // Generic database error
  return createDatabaseError('Database operation failed', {
    originalError: error.message,
    code: error.code,
  });
};

/**
 * Express error handler for uncaught exceptions
 */
export const uncaughtExceptionHandler = (error: Error): void => {
  logger.error('Uncaught Exception', error, {
    timestamp: new Date().toISOString(),
  });

  // Graceful shutdown
  process.exit(1);
};

/**
 * Express error handler for unhandled promise rejections
 */
export const unhandledRejectionHandler = (reason: any, promise: Promise<any>): void => {
  logger.error(
    'Unhandled Promise Rejection',
    reason instanceof Error ? reason : new Error(String(reason)),
    {
      promise: promise.toString(),
      timestamp: new Date().toISOString(),
    }
  );

  // Graceful shutdown
  process.exit(1);
};

/**
 * Install global error handlers
 */
export const installGlobalErrorHandlers = (): void => {
  process.on('uncaughtException', uncaughtExceptionHandler);
  process.on('unhandledRejection', unhandledRejectionHandler);

  // Graceful shutdown on SIGTERM
  process.on('SIGTERM', () => {
    logger.info('SIGTERM received, shutting down gracefully');
    process.exit(0);
  });

  // Graceful shutdown on SIGINT
  process.on('SIGINT', () => {
    logger.info('SIGINT received, shutting down gracefully');
    process.exit(0);
  });
};
