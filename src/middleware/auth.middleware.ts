/**
 * HASIVU Platform - Authentication Middleware
 * JWT token validation, session management, and route protection
 * Generated by SuperClaude Wave 2: Backend Implementation
 */

import { Request, Response, NextFunction } from 'express';
import rateLimit from 'express-rate-limit';
import helmet from 'helmet';
import { authService } from '../services/auth.service';
import { jwtService } from '../shared/services/jwt.service';
import { logger } from '../utils/logger';

/**
 * Extended Request interface with user data
 */
export interface AuthenticatedRequest extends Request {
  user?: {
    id: string;
    email: string;
    role: string;
    permissions: string[];
  };
  sessionId?: string;
}

/**
 * Authentication middleware options
 */
export interface AuthOptions {
  roles?: string[];
  permissions?: string[];
  optional?: boolean;
}

/**
 * Security headers middleware
 */
export const securityHeaders = helmet({
  contentSecurityPolicy: {
    directives: {
      defaultSrc: ["'self'"],
      styleSrc: ["'self'", "'unsafe-inline'"],
      scriptSrc: ["'self'"],
      imgSrc: ["'self'", "data:", "https:"],
      connectSrc: ["'self'"],
      fontSrc: ["'self'"],
      objectSrc: ["'none'"],
      mediaSrc: ["'self'"],
      frameSrc: ["'none'"],
    },
  },
  crossOriginEmbedderPolicy: false
});

/**
 * Rate limiting middleware for authentication endpoints
 */
export const authRateLimit = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 5, // limit each IP to 5 requests per windowMs
  message: 'Too many authentication attempts, please try again later',
  standardHeaders: true,
  legacyHeaders: false,
  handler: (req, res) => {
    logger.warn('Rate limit exceeded for authentication', {
      ip: req.ip,
      userAgent: req.get('User-Agent'),
      path: req.path
    });
    res.status(429).json({
      error: 'Too many requests',
      message: 'Too many authentication attempts, please try again later',
      retryAfter: Math.round(15 * 60) // 15 minutes in seconds
    });
  }
});

/**
 * General rate limiting middleware
 */
export const generalRateLimit = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 100, // limit each IP to 100 requests per windowMs
  message: 'Too many requests, please try again later',
  standardHeaders: true,
  legacyHeaders: false
});

/**
 * Input validation and sanitization middleware
 */
export const validateInput = (req: Request, res: Response, next: NextFunction): void => {
  try {
    // Sanitize common XSS patterns
    const sanitizeString = (str: string): string => {
      if (typeof str !== 'string') return str;
      return str
        .replace(/[<>]/g, '') // Remove angle brackets
        .replace(/javascript:/gi, '') // Remove javascript: protocol
        .replace(/on\w+=/gi, '') // Remove event handlers
        .trim();
    };

    // Recursively sanitize object
    const sanitizeObject = (obj: any): any => {
      if (obj === null || typeof obj !== 'object') {
        return typeof obj === 'string' ? sanitizeString(obj) : obj;
      }

      if (Array.isArray(obj)) {
        return obj.map(sanitizeObject);
      }

      const sanitized: any = {};
      for (const key in obj) {
        if (obj.hasOwnProperty(key)) {
          const sanitizedKey = sanitizeString(key);
          sanitized[sanitizedKey] = sanitizeObject(obj[key]);
        }
      }
      return sanitized;
    };

    // Sanitize request body
    if (req.body) {
      req.body = sanitizeObject(req.body);
    }

    // Sanitize query parameters
    if (req.query) {
      req.query = sanitizeObject(req.query);
    }

    next();
  } catch (error) {
    logger.error('Input validation failed', error);
    res.status(400).json({
      error: 'Invalid input',
      message: 'Request contains invalid data'
    });
  }
};

/**
 * CORS middleware with security configurations
 */
export const corsMiddleware = (req: Request, res: Response, next: NextFunction): void => {
  const allowedOrigins = process.env.CORS_ORIGINS?.split(',') || ['http://localhost:3000'];
  const origin = req.headers.origin;

  // Check if origin is allowed
  if (origin && allowedOrigins.includes(origin)) {
    res.header('Access-Control-Allow-Origin', origin);
  }

  res.header('Access-Control-Allow-Methods', 'GET,POST,PUT,DELETE,OPTIONS,PATCH');
  res.header('Access-Control-Allow-Headers', 'Origin, X-Requested-With, Content-Type, Accept, Authorization');
  res.header('Access-Control-Allow-Credentials', 'true');
  res.header('Access-Control-Max-Age', '86400'); // 24 hours

  // Handle preflight requests
  if (req.method === 'OPTIONS') {
    res.sendStatus(200);
    return;
  }

  next();
};

/**
 * Main authentication middleware
 */
export const authMiddleware = async (
  req: AuthenticatedRequest,
  res: Response,
  next: NextFunction
): Promise<void> => {
  try {
    // Extract token from request headers
    const authHeader = req.headers.authorization;
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      res.status(401).json({
        error: 'Unauthorized',
        message: 'Access token is required'
      });
      return;
    }

    const token = authHeader.substring(7).trim();
    if (!token) {
      res.status(401).json({
        error: 'Unauthorized',
        message: 'Invalid access token format'
      });
      return;
    }

    // Verify JWT token with timeout protection
    const verificationResult = await jwtService.verifyToken(token, 'access');
    if (!verificationResult.isValid) {
      res.status(401).json({
        error: 'Unauthorized',
        message: verificationResult.error || 'Invalid token'
      });
      return;
    }

    const decoded = verificationResult.payload;

    // Validate session
    const sessionData = await authService.validateSession(decoded.sessionId);
    if (!sessionData.valid) {
      res.status(401).json({
        error: 'Unauthorized',
        message: 'Invalid or expired session'
      });
      return;
    }

    // Update session activity
    await authService.updateSessionActivity(decoded.sessionId, {
      userAgent: req.get('User-Agent'),
      ipAddress: req.ip
    });

    // Attach user data to request
    req.user = {
      id: decoded.userId,
      email: decoded.email,
      role: decoded.role,
      permissions: decoded.permissions
    };
    req.sessionId = decoded.sessionId;

    logger.debug('User authenticated successfully', {
      userId: decoded.userId,
      role: decoded.role,
      sessionId: decoded.sessionId
    });

    next();
  } catch (error) {
    logger.error('Authentication middleware error', error);
    if ((error as Error).message === 'Token expired') {
      res.status(401).json({
        error: 'Token expired',
        message: 'Please refresh your token or login again'
      });
    } else if ((error as Error).message?.includes('timeout')) {
      res.status(401).json({
        error: 'Authentication timeout',
        message: 'Token verification took too long - possible security threat'
      });
    } else {
      res.status(401).json({
        error: 'Authentication failed',
        message: 'Invalid or malformed token'
      });
    }
  }
};

/**
 * Optional authentication middleware (doesn't fail if no token)
 */
export const optionalAuthMiddleware = async (
  req: AuthenticatedRequest,
  res: Response,
  next: NextFunction
): Promise<void> => {
  try {
    const authHeader = req.headers.authorization;
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      // No token provided, continue without authentication
      next();
      return;
    }

    const token = authHeader.substring(7).trim();
    if (!token) {
      next();
      return;
    }

    // Try to verify token but don't fail if invalid
    try {
      const verificationResult = await jwtService.verifyToken(token, 'access');
      if (verificationResult.isValid) {
        const decoded = verificationResult.payload;
        
        // Validate session
        const sessionData = await authService.validateSession(decoded.sessionId);
        if (sessionData.valid) {
          req.user = {
            id: decoded.userId,
            email: decoded.email,
            role: decoded.role,
            permissions: decoded.permissions
          };
          req.sessionId = decoded.sessionId;

          // Update session activity
          await authService.updateSessionActivity(decoded.sessionId, {
            userAgent: req.get('User-Agent'),
            ipAddress: req.ip
          });
        }
      }
    } catch (error) {
      // Ignore authentication errors for optional middleware
      logger.debug('Optional authentication failed', { error: (error as Error).message });
    }

    next();
  } catch (error) {
    logger.error('Optional authentication middleware error', error);
    // Don't fail the request for optional authentication
    next();
  }
};

/**
 * Role-based authorization middleware
 */
export const requireRole = (roles: string | string[]) => {
  const allowedRoles = Array.isArray(roles) ? roles : [roles];
  
  return (req: AuthenticatedRequest, res: Response, next: NextFunction): void => {
    if (!req.user) {
      res.status(401).json({
        error: 'Unauthorized',
        message: 'Authentication required'
      });
      return;
    }

    if (!allowedRoles.includes(req.user.role)) {
      logger.warn('Insufficient role permissions', {
        userId: req.user.id,
        userRole: req.user.role,
        requiredRoles: allowedRoles
      });
      
      res.status(403).json({
        error: 'Forbidden',
        message: 'Insufficient permissions',
        details: `Required role: ${allowedRoles.join(' or ')}`
      });
      return;
    }

    next();
  };
};

/**
 * Permission-based authorization middleware
 */
export const requirePermission = (permissions: string | string[]) => {
  const requiredPermissions = Array.isArray(permissions) ? permissions : [permissions];
  
  return (req: AuthenticatedRequest, res: Response, next: NextFunction): void => {
    if (!req.user) {
      res.status(401).json({
        error: 'Unauthorized',
        message: 'Authentication required'
      });
      return;
    }

    const hasPermission = requiredPermissions.some(permission => 
      req.user!.permissions.includes(permission)
    );

    if (!hasPermission) {
      logger.warn('Insufficient permissions', {
        userId: req.user.id,
        userPermissions: req.user.permissions,
        requiredPermissions
      });
      
      res.status(403).json({
        error: 'Forbidden',
        message: 'Insufficient permissions',
        details: `Required permission: ${requiredPermissions.join(' or ')}`
      });
      return;
    }

    next();
  };
};

/**
 * Combined authorization middleware with flexible options
 */
export const authorize = (options: AuthOptions) => {
  return (req: AuthenticatedRequest, res: Response, next: NextFunction): void => {
    if (!req.user) {
      if (options.optional) {
        next();
        return;
      }
      
      res.status(401).json({
        error: 'Unauthorized',
        message: 'Authentication required'
      });
      return;
    }

    // Check roles if specified
    if (options.roles && options.roles.length > 0) {
      if (!options.roles.includes(req.user.role)) {
        res.status(403).json({
          error: 'Forbidden',
          message: 'Insufficient permissions',
          details: `Required role: ${options.roles.join(' or ')}`
        });
        return;
      }
    }

    // Check permissions if specified
    if (options.permissions && options.permissions.length > 0) {
      const hasPermission = options.permissions.some(permission => 
        req.user!.permissions.includes(permission)
      );
      
      if (!hasPermission) {
        res.status(403).json({
          error: 'Forbidden',
          message: 'Insufficient permissions',
          details: `Required permission: ${options.permissions.join(' or ')}`
        });
        return;
      }
    }

    next();
  };
};

/**
 * Audit logging middleware for sensitive operations
 */
export const auditLog = (operation: string) => {
  return (req: AuthenticatedRequest, res: Response, next: NextFunction): void => {
    const startTime = Date.now();
    
    // Log the operation attempt
    logger.info('Sensitive operation attempted', {
      operation,
      userId: req.user?.id,
      userEmail: req.user?.email,
      userRole: req.user?.role,
      ip: req.ip,
      userAgent: req.get('User-Agent'),
      method: req.method,
      path: req.path,
      timestamp: new Date().toISOString()
    });

    // Override res.json to log the response
    const originalJson = res.json;
    res.json = function(body) {
      const duration = Date.now() - startTime;
      const success = res.statusCode >= 200 && res.statusCode < 300;
      
      logger.info('Sensitive operation completed', {
        operation,
        userId: req.user?.id,
        success,
        statusCode: res.statusCode,
        duration,
        timestamp: new Date().toISOString()
      });
      
      return originalJson.call(this, body);
    };

    next();
  };
};

/**
 * Request timeout middleware to prevent ReDoS attacks
 */
export const requestTimeout = (timeoutMs: number = 30000) => {
  return (req: Request, res: Response, next: NextFunction): void => {
    const timeout = setTimeout(() => {
      if (!res.headersSent) {
        logger.warn('Request timeout', {
          method: req.method,
          path: req.path,
          ip: req.ip,
          timeout: timeoutMs
        });
        
        res.status(408).json({
          error: 'Request timeout',
          message: 'Request took too long to process'
        });
      }
    }, timeoutMs);

    // Clear timeout when response is sent
    res.on('finish', () => {
      clearTimeout(timeout);
    });

    next();
  };
};