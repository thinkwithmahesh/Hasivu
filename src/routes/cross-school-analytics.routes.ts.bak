/**
 * HASIVU Platform - Cross-School Analytics Routes
 * Epic 2 â†’ Story 4: Cross-School Analytics & Benchmarking API Endpoints
 *
 * Endpoints:
 * - GET /api/v1/analytics/cross-school/benchmark
 * - GET /api/v1/analytics/cross-school/nutrition-intelligence
 * - GET /api/v1/analytics/cross-school/operational-excellence
 * - GET /api/v1/analytics/cross-school/predictive-insights
 * - POST /api/v1/analytics/cross-school/federated-training
 * - GET /api/v1/analytics/cross-school/realtime-metrics
 */

import { Router, Request, Response, NextFunction, RequestHandler } from 'express';
import { body, query, validationResult } from 'express-validator';
import rateLimit from 'express-rate-limit';
import {
  crossSchoolAnalyticsService,
  BenchmarkCategory,
  PrivacyLevel,
  FederatedModelType
} from '../services/cross-school-analytics.service';
import { authMiddleware, requireRole, AuthenticatedRequest } from '../middleware/auth.middleware';
import { logger } from '../utils/logger';
import { createSuccessResponse, createErrorResponse } from '../shared/response.utils';

const router = Router();

/**
 * Rate limiting for analytics endpoints
 */
const analyticsRateLimit = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 100, // Limit each IP to 100 requests per windowMs
  message: 'Too many analytics requests from this IP, please try again later.',
  standardHeaders: true,
  legacyHeaders: false,
});

/**
 * Validation schemas
 */
const benchmarkQueryValidation = [
  query('category')
    .isIn(['operational_efficiency', 'nutrition_quality', 'student_satisfaction', 'cost_effectiveness', 'sustainability', 'safety_compliance'])
    .withMessage('Invalid benchmark category'),
  query('schoolId')
    .optional()
    .isUUID()
    .withMessage('School ID must be a valid UUID'),
  query('privacyLevel')
    .optional()
    .isIn(['none', 'basic', 'differential', 'federated'])
    .withMessage('Invalid privacy level'),
  query('includeComparisons')
    .optional()
    .isBoolean()
    .withMessage('Include comparisons must be boolean'),
  query('peerGroupSize')
    .optional()
    .isInt({ min: 5, max: 50 })
    .withMessage('Peer group size must be between 5 and 50')
];

const nutritionIntelligenceValidation = [
  query('schoolIds')
    .optional()
    .isArray()
    .withMessage('School IDs must be an array'),
  query('schoolIds.*')
    .isUUID()
    .withMessage('Each school ID must be a valid UUID'),
  query('privacyLevel')
    .optional()
    .isIn(['none', 'basic', 'differential', 'federated'])
    .withMessage('Invalid privacy level'),
  query('includeMenuOptimization')
    .optional()
    .isBoolean()
    .withMessage('Include menu optimization must be boolean'),
  query('includeDietaryPatterns')
    .optional()
    .isBoolean()
    .withMessage('Include dietary patterns must be boolean'),
  query('includeWasteReduction')
    .optional()
    .isBoolean()
    .withMessage('Include waste reduction must be boolean')
];

const operationalExcellenceValidation = [
  query('schoolIds')
    .optional()
    .isArray()
    .withMessage('School IDs must be an array'),
  query('schoolIds.*')
    .isUUID()
    .withMessage('Each school ID must be a valid UUID'),
  query('privacyLevel')
    .optional()
    .isIn(['none', 'basic', 'differential', 'federated'])
    .withMessage('Invalid privacy level'),
  query('includeKitchenEfficiency')
    .optional()
    .isBoolean()
    .withMessage('Include kitchen efficiency must be boolean'),
  query('includeStaffInsights')
    .optional()
    .isBoolean()
    .withMessage('Include staff insights must be boolean'),
  query('includeSupplyChain')
    .optional()
    .isBoolean()
    .withMessage('Include supply chain must be boolean'),
  query('includeEquipmentPredictions')
    .optional()
    .isBoolean()
    .withMessage('Include equipment predictions must be boolean')
];

const predictiveInsightsValidation = [
  query('schoolIds')
    .optional()
    .isArray()
    .withMessage('School IDs must be an array'),
  query('schoolIds.*')
    .isUUID()
    .withMessage('Each school ID must be a valid UUID'),
  query('forecastHorizon')
    .optional()
    .isInt({ min: 30, max: 1095 })
    .withMessage('Forecast horizon must be between 30 and 1095 days'),
  query('includeRiskAssessment')
    .optional()
    .isBoolean()
    .withMessage('Include risk assessment must be boolean'),
  query('includeGrowthOpportunities')
    .optional()
    .isBoolean()
    .withMessage('Include growth opportunities must be boolean')
];

const federatedTrainingValidation = [
  body('modelType')
    .isIn(['nutrition_optimization', 'demand_forecasting', 'cost_prediction', 'quality_assessment', 'waste_reduction'])
    .withMessage('Invalid model type'),
  body('participatingSchoolIds')
    .isArray({ min: 3 })
    .withMessage('Minimum 3 participating schools required'),
  body('participatingSchoolIds.*')
    .isUUID()
    .withMessage('Each school ID must be a valid UUID'),
  body('privacyParams')
    .optional()
    .isObject()
    .withMessage('Privacy params must be an object'),
  body('privacyParams.epsilon')
    .optional()
    .isFloat({ min: 0.01, max: 10 })
    .withMessage('Epsilon must be between 0.01 and 10'),
  body('privacyParams.delta')
    .optional()
    .isFloat({ min: 1e-10, max: 1e-3 })
    .withMessage('Delta must be between 1e-10 and 1e-3'),
  body('privacyParams.mechanism')
    .optional()
    .isIn(['laplace', 'gaussian', 'exponential'])
    .withMessage('Invalid privacy mechanism')
];

/**
 * Error handling middleware for validation
 */
const handleValidationErrors = (req: Request, res: Response, next: NextFunction): void => {
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    logger.warn('Cross-school analytics validation failed', {
      errors: errors.array(),
      path: req.path,
      query: req.query,
      body: req.body
    });

    res.status(400).json({
      error: 'Validation failed',
      code: 'VALIDATION_ERROR',
      data: { errors: errors.array() },
      timestamp: new Date().toISOString()
    });
    return;
  }
  next();
};

/**
 * Permission checking middleware
 */
const checkAnalyticsPermissions = (req: Request, res: Response, next: NextFunction): void => {
  const user = (req as any).user;

  // Only admin, school_admin, and super_admin can access cross-school analytics
  if (!['school_admin', 'admin', 'super_admin'].includes(user.role)) {
    logger.warn('Unauthorized cross-school analytics access attempt', {
      userId: user.id,
      role: user.role,
      path: req.path
    });

    res.status(403).json(createErrorResponse(
      'Insufficient permissions for cross-school analytics',
      403,
      'INSUFFICIENT_PERMISSIONS'
    ));
    return;
  }

  // School admins can only see their own school's data in aggregated form
  if (user.role === 'school_admin') {
    // Restrict schoolIds to user's school
    if (req.query.schoolIds) {
      req.query.schoolIds = [user.schoolId || undefined];
    }
    if (req.body.participatingSchoolIds) {
      // For federated learning, check if user's school is included
      if (!req.body.participatingSchoolIds.includes(user.schoolId || undefined)) {
        res.status(403).json(createErrorResponse(
          'School admin can only participate in training with their own school',
          403,
          'INSUFFICIENT_PERMISSIONS'
        ));
        return;
      }
    }
  }

  next();
};

/**
 * Apply middleware to all routes
 */
router.use(analyticsRateLimit);
router.use(authMiddleware as any);
router.use(checkAnalyticsPermissions as any);

/**
 * GET /api/v1/analytics/cross-school/benchmark
 * Generate cross-school benchmark analysis
 */
router.get('/benchmark',
  benchmarkQueryValidation,
  handleValidationErrors as any,
  async (req: AuthenticatedRequest, res: Response) => {
    const requestId = req.headers['x-request-id'] as string || 'unknown';

    try {
      logger.info('Cross-school benchmark request', {
        requestId,
        userId: (req as any).user.id,
        query: req.query
      });

      const {
        category,
        schoolId,
        privacyLevel = 'differential',
        includeComparisons = true,
        peerGroupSize = 10
      } = req.query;

      const result = await (crossSchoolAnalyticsService.constructor as any).generateCrossSchoolBenchmark(
        category as BenchmarkCategory,
        schoolId as string,
        privacyLevel as PrivacyLevel
      );

      if (!result.success) {
        return res.status(400).json(createErrorResponse(
          result.error?.message || 'Failed to generate benchmark',
          400,
          result.error?.code || 'BENCHMARK_FAILED'
        ));
      }

      logger.info('Cross-school benchmark generated successfully', {
        requestId,
        benchmarkId: result.data?.benchmarkId,
        schoolCount: result.data?.schoolCount
      });

      return res.json(createSuccessResponse({
        message: 'Cross-school benchmark generated successfully',
        data: result.data,
        metadata: {
          requestId,
          generatedAt: new Date().toISOString(),
          privacyLevel,
          category
        }
      }));

    } catch (error: any) {
      logger.error('Cross-school benchmark request failed', {
        requestId,
        error: (error instanceof Error ? error.message : String(error)),
        stack: (error instanceof Error ? error.stack : undefined)
      });

      return res.status(500).json(createErrorResponse(
        'Internal server error',
        500,
        'INTERNAL_ERROR'
      ));
    }
  }
);

/**
 * GET /api/v1/analytics/cross-school/nutrition-intelligence
 * Generate nutrition intelligence analysis
 */
router.get('/nutrition-intelligence',
  nutritionIntelligenceValidation,
  handleValidationErrors as any,
  async (req: AuthenticatedRequest, res: Response) => {
    const requestId = req.headers['x-request-id'] as string || 'unknown';

    try {
      logger.info('Nutrition intelligence request', {
        requestId,
        userId: (req as any).user.id,
        query: req.query
      });

      const {
        schoolIds,
        privacyLevel = 'differential',
        includeMenuOptimization = true,
        includeDietaryPatterns = true,
        includeWasteReduction = true
      } = req.query;

      const result = await (crossSchoolAnalyticsService.constructor as any).generateNutritionIntelligence(
        schoolIds as string[],
        privacyLevel as PrivacyLevel
      );

      if (!result.success) {
        return res.status(400).json(createErrorResponse(
          result.error?.message || 'Failed to generate nutrition intelligence',
          400,
          result.error?.code || 'NUTRITION_INTELLIGENCE_FAILED'
        ));
      }

      logger.info('Nutrition intelligence generated successfully', {
        requestId,
        analysisId: result.data?.analysisId,
        schoolCount: schoolIds?.length || 'all'
      });

      return res.json(createSuccessResponse({
        message: 'Nutrition intelligence generated successfully',
        data: result.data,
        metadata: {
          requestId,
          generatedAt: new Date().toISOString(),
          privacyLevel,
          schoolCount: schoolIds?.length || 'all'
        }
      }));

    } catch (error: any) {
      logger.error('Nutrition intelligence request failed', {
        requestId,
        error: (error instanceof Error ? error.message : String(error)),
        stack: (error instanceof Error ? error.stack : undefined)
      });

      return res.status(500).json(createErrorResponse(
        'Internal server error',
        500,
        'INTERNAL_ERROR'
      ));
    }
  }
);

/**
 * GET /api/v1/analytics/cross-school/operational-excellence
 * Generate operational excellence analytics
 */
router.get('/operational-excellence',
  operationalExcellenceValidation,
  handleValidationErrors as any,
  async (req: AuthenticatedRequest, res: Response) => {
    const requestId = req.headers['x-request-id'] as string || 'unknown';

    try {
      logger.info('Operational excellence request', {
        requestId,
        userId: (req as any).user.id,
        query: req.query
      });

      const {
        schoolIds,
        privacyLevel = 'differential',
        includeKitchenEfficiency = true,
        includeStaffInsights = true,
        includeSupplyChain = true,
        includeEquipmentPredictions = true
      } = req.query;

      const result = await (crossSchoolAnalyticsService.constructor as any).generateOperationalExcellence(
        schoolIds as string[],
        privacyLevel as PrivacyLevel
      );

      if (!result.success) {
        return res.status(400).json(createErrorResponse(
          result.error?.message || 'Failed to generate operational excellence analytics',
          400,
          result.error?.code || 'OPERATIONAL_EXCELLENCE_FAILED'
        ));
      }

      logger.info('Operational excellence analytics generated successfully', {
        requestId,
        analysisId: result.data?.analysisId,
        schoolCount: schoolIds?.length || 'all'
      });

      return res.json(createSuccessResponse({
        message: 'Operational excellence analytics generated successfully',
        data: result.data,
        metadata: {
          requestId,
          generatedAt: new Date().toISOString(),
          privacyLevel,
          schoolCount: schoolIds?.length || 'all'
        }
      }));

    } catch (error: any) {
      logger.error('Operational excellence request failed', {
        requestId,
        error: (error instanceof Error ? error.message : String(error)),
        stack: (error instanceof Error ? error.stack : undefined)
      });

      return res.status(500).json(createErrorResponse(
        'Internal server error',
        500,
        'INTERNAL_ERROR'
      ));
    }
  }
);

/**
 * GET /api/v1/analytics/cross-school/predictive-insights
 * Generate predictive insights and forecasting
 */
router.get('/predictive-insights',
  predictiveInsightsValidation,
  handleValidationErrors as any,
  async (req: AuthenticatedRequest, res: Response) => {
    const requestId = req.headers['x-request-id'] as string || 'unknown';

    try {
      logger.info('Predictive insights request', {
        requestId,
        userId: (req as any).user.id,
        query: req.query
      });

      const {
        schoolIds,
        forecastHorizon = 365,
        includeRiskAssessment = true,
        includeGrowthOpportunities = true
      } = req.query;

      const result = await (crossSchoolAnalyticsService.constructor as any).generatePredictiveInsights(
        schoolIds as string[],
        parseInt(forecastHorizon as string)
      );

      if (!result.success) {
        return res.status(400).json(createErrorResponse(
          result.error?.message || 'Failed to generate predictive insights',
          400,
          result.error?.code || 'PREDICTIVE_INSIGHTS_FAILED'
        ));
      }

      logger.info('Predictive insights generated successfully', {
        requestId,
        forecastId: result.data?.forecastId,
        confidenceLevel: result.data?.confidenceLevel
      });

      return res.json(createSuccessResponse({
        message: 'Predictive insights generated successfully',
        data: result.data,
        metadata: {
          requestId,
          generatedAt: new Date().toISOString(),
          forecastHorizon,
          schoolCount: schoolIds?.length || 'all'
        }
      }));

    } catch (error: any) {
      logger.error('Predictive insights request failed', {
        requestId,
        error: (error instanceof Error ? error.message : String(error)),
        stack: (error instanceof Error ? error.stack : undefined)
      });

      return res.status(500).json(createErrorResponse(
        'Internal server error',
        500,
        'INTERNAL_ERROR'
      ));
    }
  }
);

/**
 * POST /api/v1/analytics/cross-school/federated-training
 * Train federated learning model
 */
router.post('/federated-training',
  requireRole(['super_admin']) as any, // Only super admins can initiate federated training
  federatedTrainingValidation,
  handleValidationErrors as any,
  async (req: AuthenticatedRequest, res: Response) => {
    const requestId = req.headers['x-request-id'] as string || 'unknown';

    try {
      logger.info('Federated training request', {
        requestId,
        userId: (req as any).user.id,
        body: req.body
      });

      const {
        modelType,
        participatingSchoolIds,
        privacyParams
      } = req.body;

      const result = await (crossSchoolAnalyticsService.constructor as any).trainFederatedModel(
        modelType as FederatedModelType,
        participatingSchoolIds,
        privacyParams
      );

      if (!result.success) {
        return res.status(400).json(createErrorResponse(
          result.error?.message || 'Failed to train federated model',
          400,
          result.error?.code || 'FEDERATED_TRAINING_FAILED'
        ));
      }

      logger.info('Federated training completed successfully', {
        requestId,
        modelId: result.data?.modelId,
        participatingSchools: result.data?.participatingSchools
      });

      return res.json(createSuccessResponse({
        message: 'Federated model training completed successfully',
        data: result.data,
        metadata: {
          requestId,
          initiatedBy: req.user!.id,
          startedAt: new Date().toISOString()
        }
      }));

    } catch (error: any) {
      logger.error('Federated training request failed', {
        requestId,
        error: (error instanceof Error ? error.message : String(error)),
        stack: (error instanceof Error ? error.stack : undefined)
      });

      return res.status(500).json(createErrorResponse(
        'Internal server error',
        500,
        'INTERNAL_ERROR'
      ));
    }
  }
);

/**
 * GET /api/v1/analytics/cross-school/realtime-metrics
 * Get real-time cross-school performance metrics
 */
router.get('/realtime-metrics',
  async (req: AuthenticatedRequest, res: Response) => {
    const requestId = req.headers['x-request-id'] as string || 'unknown';

    try {
      const user = (req as any).user;
      const schoolId = user.role === 'school_admin' ? user.schoolId || undefined : req.query.schoolId as string;

      logger.info('Real-time metrics request', {
        requestId,
        userId: user.id,
        schoolId
      });

      const result = await (crossSchoolAnalyticsService.constructor as any).getRealtimePerformanceMetrics(schoolId);

      if (!result.success) {
        return res.status(400).json(createErrorResponse(
          result.error?.message || 'Failed to get realtime metrics',
          400,
          result.error?.code || 'REALTIME_METRICS_FAILED'
        ));
      }

      return res.json(createSuccessResponse({
        message: 'Real-time metrics retrieved successfully',
        data: result.data,
        metadata: {
          requestId,
          retrievedAt: new Date().toISOString(),
          schoolId: schoolId || 'all'
        }
      }));

    } catch (error: any) {
      logger.error('Real-time metrics request failed', {
        requestId,
        error: (error instanceof Error ? error.message : String(error)),
        stack: (error instanceof Error ? error.stack : undefined)
      });

      return res.status(500).json(createErrorResponse(
        'Internal server error',
        500,
        'INTERNAL_ERROR'
      ));
    }
  }
);

/**
 * GET /api/v1/analytics/cross-school/health
 * Health check endpoint for cross-school analytics
 */
router.get('/health', async (req: AuthenticatedRequest, res: Response) => {
  try {
    const healthStatus = {
      status: 'healthy',
      timestamp: new Date().toISOString(),
      services: {
        crossSchoolAnalytics: 'operational',
        federatedLearning: 'operational',
        privacyProtection: 'operational',
        realtimeBenchmarking: 'operational'
      },
      performance: {
        avgResponseTime: '< 2s',
        cacheHitRate: '95%',
        privacyCompliance: '100%'
      }
    };

    return res.json(createSuccessResponse({
      message: 'Cross-school analytics service is healthy',
      data: healthStatus
    }));

  } catch (error: any) {
    logger.error('Health check failed', error);

    return res.status(503).json(createErrorResponse(
      'Service temporarily unavailable',
      503,
      'SERVICE_UNAVAILABLE'
    ));
  }
});

export default router;