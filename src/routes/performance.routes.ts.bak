/**
 * HASIVU Platform - Performance Monitoring Routes
 * API endpoints for performance metrics and monitoring
 * Generated by SuperClaude - Performance Optimization Suite
 */

import { Router, Request, Response, NextFunction } from 'express';
import { query, param, validationResult } from 'express-validator';
import { performanceService } from '@/services/performance.service';
import { authMiddleware, AuthenticatedRequest } from '@/middleware/auth.middleware';
import { requestLogger } from '@/middleware/logging.middleware';
import { generalRateLimit as rateLimiter } from '@/middleware/rateLimiter.middleware';
import { logger } from '@/utils/logger';
import { ApiResponse } from '@/types/api.types';

const router = Router();

/**
 * Validation error handler middleware
 */
const handleValidationErrors = (req: Request, res: Response, next: NextFunction): void => {
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    res.status(400).json({
      success: false,
      message: 'Validation failed',
      errors: errors.array(),
      timestamp: new Date().toISOString(),
      version: '1.0'
    } as ApiResponse);
    return;
  }
  next();
};

// Apply middleware to all routes
router.use(requestLogger);
router.use(rateLimiter);

/**
 * GET /api/v1/performance/metrics
 * Get current performance metrics
 */
router.get('/metrics',
  authMiddleware,
  async (req: AuthenticatedRequest, res: Response, next: NextFunction) => {
    try {
      const metrics = await performanceService.getCurrentMetrics();

      res.json({
        success: true,
        data: metrics,
        message: 'Performance metrics retrieved successfully'
      } as ApiResponse);
    } catch (error: unknown) {
      logger.error('Failed to get performance metrics:', error);
      next(error);
    }
  }
);

/**
 * GET /api/v1/performance/dashboard
 * Get performance dashboard data
 */
router.get('/dashboard',
  authMiddleware,
  [
    query('timeRange')
      .optional()
      .isIn(['1h', '24h', '7d', '30d'])
      .withMessage('Time range must be 1h, 24h, 7d, or 30d'),
    query('metric')
      .optional()
      .isIn(['response_time', 'throughput', 'error_rate', 'cpu_usage', 'memory_usage'])
      .withMessage('Invalid metric type')
  ],
  handleValidationErrors,
  async (req: AuthenticatedRequest, res: Response, next: NextFunction) => {
    try {
      const dashboard = await performanceService.getDashboardData({
        schoolId: req.user.id,
        timeRange: req.query.timeRange as string || '24h',
        metric: req.query.metric as string
      });

      res.json({
        success: true,
        data: dashboard,
        message: 'Performance dashboard data retrieved successfully'
      } as ApiResponse);
    } catch (error: unknown) {
      logger.error('Failed to get dashboard data:', error);
      next(error);
    }
  }
);

/**
 * GET /api/v1/performance/history
 * Get historical performance data
 */
router.get('/history',
  authMiddleware,
  [
    query('startDate')
      .optional()
      .isISO8601()
      .toDate()
      .withMessage('Start date must be a valid ISO 8601 date'),
    query('endDate')
      .optional()
      .isISO8601()
      .toDate()
      .withMessage('End date must be a valid ISO 8601 date'),
    query('granularity')
      .optional()
      .isIn(['minute', 'hour', 'day'])
      .withMessage('Granularity must be minute, hour, or day'),
    query('metrics')
      .optional()
      .withMessage('Metrics must be a comma-separated list')
  ],
  handleValidationErrors,
  async (req: AuthenticatedRequest, res: Response, next: NextFunction) => {
    try {
      const history = await performanceService.getHistoricalData({
        startDate: new Date(req.query.startDate as string),
        endDate: new Date(req.query.endDate as string),
        metrics: req.query.metrics ? (req.query.metrics as string).split(',') : undefined
        // Note: granularity parameter removed as it's not supported by service method
      });

      res.json({
        success: true,
        data: history,
        message: 'Performance history retrieved successfully'
      } as ApiResponse);
    } catch (error: unknown) {
      logger.error('Failed to get performance history:', error);
      next(error);
    }
  }
);

/**
 * GET /api/v1/performance/alerts
 * Get performance alerts and thresholds
 */
router.get('/alerts',
  authMiddleware,
  [
    query('status')
      .optional()
      .isIn(['active', 'resolved', 'muted'])
      .withMessage('Status must be active, resolved, or muted'),
    query('severity')
      .optional()
      .isIn(['low', 'medium', 'high', 'critical'])
      .withMessage('Severity must be low, medium, high, or critical')
  ],
  handleValidationErrors,
  async (req: AuthenticatedRequest, res: Response, next: NextFunction) => {
    try {
      const alerts = await performanceService.getAlerts({
        schoolId: req.user.id,
        status: req.query.status as string,
        severity: req.query.severity as string
      });

      res.json({
        success: true,
        data: alerts,
        message: 'Performance alerts retrieved successfully'
      } as ApiResponse);
    } catch (error: unknown) {
      logger.error('Failed to get performance alerts:', error);
      next(error);
    }
  }
);

/**
 * GET /api/v1/performance/bottlenecks
 * Identify current performance bottlenecks
 */
router.get('/bottlenecks',
  authMiddleware,
  [
    query('threshold')
      .optional()
      .isFloat({ min: 0, max: 100 })
      .toFloat()
      .withMessage('Threshold must be a number between 0 and 100'),
    query('component')
      .optional()
      .isIn(['database', 'api', 'cache', 'external'])
      .withMessage('Component must be database, api, cache, or external')
  ],
  handleValidationErrors,
  async (req: AuthenticatedRequest, res: Response, next: NextFunction) => {
    try {
      const bottlenecks = await performanceService.identifyBottlenecks({
        threshold: Number(req.query.threshold) || 80,
        timeWindow: req.query.timeWindow as string || '1h'
        // Note: component parameter removed, using timeWindow instead per service interface
      });

      res.json({
        success: true,
        data: bottlenecks,
        message: 'Performance bottlenecks identified successfully'
      } as ApiResponse);
    } catch (error: unknown) {
      logger.error('Failed to identify bottlenecks:', error);
      next(error);
    }
  }
);

/**
 * POST /api/v1/performance/record
 * Record a custom performance metric
 */
router.post('/record',
  authMiddleware,
  [
    query('metric')
      .notEmpty()
      .withMessage('Metric name is required'),
    query('value')
      .isNumeric()
      .toFloat()
      .withMessage('Value must be a number'),
    query('tags')
      .optional()
      .withMessage('Tags should be key-value pairs')
  ],
  handleValidationErrors,
  async (req: AuthenticatedRequest, res: Response, next: NextFunction) => {
    try {
      await performanceService.recordMetric({
        name: req.query.metric as string,
        value: Number(req.query.value),
        tags: {}
      });

      res.status(201).json({
        success: true,
        message: 'Metric recorded successfully'
      } as ApiResponse);
    } catch (error: unknown) {
      logger.error('Failed to record metric:', error);
      next(error);
    }
  }
);

/**
 * GET /api/v1/performance/optimization-suggestions
 * Get AI-powered optimization suggestions
 */
router.get('/optimization-suggestions',
  authMiddleware,
  [
    query('category')
      .optional()
      .isIn(['database', 'api', 'frontend', 'infrastructure'])
      .withMessage('Category must be database, api, frontend, or infrastructure'),
    query('priority')
      .optional()
      .isIn(['low', 'medium', 'high'])
      .withMessage('Priority must be low, medium, or high')
  ],
  handleValidationErrors,
  async (req: AuthenticatedRequest, res: Response, next: NextFunction) => {
    try {
      const suggestions = await performanceService.getOptimizationSuggestions({
        schoolId: req.user.id,
        category: req.query.category as string,
        priority: req.query.priority as string
      });

      res.json({
        success: true,
        data: suggestions,
        message: 'Optimization suggestions retrieved successfully'
      } as ApiResponse);
    } catch (error: unknown) {
      logger.error('Failed to get optimization suggestions:', error);
      next(error);
    }
  }
);

/**
 * GET /api/v1/performance/health
 * Get overall system health status
 */
router.get('/health',
  authMiddleware,
  async (req: AuthenticatedRequest, res: Response, next: NextFunction) => {
    try {
      const health = await performanceService.getSystemHealth(req.user.id);

      res.json({
        success: true,
        data: health,
        message: 'System health retrieved successfully'
      } as ApiResponse);
    } catch (error: unknown) {
      logger.error('Failed to get system health:', error);
      next(error);
    }
  }
);

export default router;