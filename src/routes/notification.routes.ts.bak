/**
 * HASIVU Platform - Notification Routes
 * Notification management and delivery API endpoints
 * Implements comprehensive notification system with multi-channel delivery
 */

import { Router } from 'express';
import { body, param, query, validationResult } from 'express-validator';
import { Request, Response, NextFunction } from 'express';
import { NotificationService } from '@/services/notification.service';
import { WhatsAppService } from '@/services/whatsapp.service';
import { authMiddleware, AuthenticatedRequest } from '@/middleware/auth.middleware';
import { requestLogger } from '@/middleware/logging.middleware';
import { generalRateLimit as rateLimiter } from '@/middleware/rateLimiter.middleware';
import { logger } from '@/utils/logger';
import { ApiResponse, NotificationStatus, NotificationPriority } from '@/types/api.types';

const router = Router();

/**
 * Validation error handler middleware
 */
const handleValidationErrors = (req: Request, res: Response, next: NextFunction): void => {
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    res.status(400).json({
      success: false,
      message: 'Validation failed',
      errors: errors.array(),
      timestamp: new Date().toISOString(),
      version: '1.0'
    } as ApiResponse);
    return;
  }
  next();
};

// Apply middleware to all routes
router.use(requestLogger);
router.use(rateLimiter);

/**
 * POST /api/v1/notifications/send
 * Send single notification
 */
router.post('/send',
  authMiddleware,
  [
    body('recipientId')
      .notEmpty()
      .withMessage('Recipient ID is required'),
    body('type')
      .notEmpty()
      .withMessage('Notification type is required'),
    body('channel')
      .isIn(['push', 'email', 'sms', 'whatsapp', 'in_app', 'socket'])
      .withMessage('Invalid notification channel'),
    body('priority')
      .optional()
      .isIn(['low', 'normal', 'high', 'urgent'])
      .withMessage('Priority must be low, normal, high, or urgent'),
    body('variables')
      .optional()
      .isObject()
      .withMessage('Variables must be an object'),
    body('scheduledAt')
      .optional()
      .isISO8601()
      .toDate()
      .withMessage('Scheduled date must be a valid ISO 8601 date'),
    body('expiresAt')
      .optional()
      .isISO8601()
      .toDate()
      .withMessage('Expiry date must be a valid ISO 8601 date'),
    body('metadata')
      .optional()
      .isObject()
      .withMessage('Metadata must be an object')
  ],
  handleValidationErrors,
  async (req: AuthenticatedRequest, res: Response, next: NextFunction) => {
    try {
      const notification = await NotificationService.sendNotification({
        recipientId: req.body.recipientId,
        templateId: req.body.type,
        recipientType: 'user',
        channels: [req.body.channel],
        priority: req.body.priority || 'normal',
        variables: req.body.variables || {},
        scheduledAt: req.body.scheduledAt,
        expiresAt: req.body.expiresAt,
        metadata: req.body.metadata || {}
      });

      res.status(201).json({
        success: true,
        data: notification,
        message: 'Notification sent successfully',
        timestamp: new Date().toISOString(),
        version: '1.0'
      } as ApiResponse);
    } catch (error: unknown) {
      next(error);
    }
  }
);

/**
 * POST /api/v1/notifications/bulk
 * Send bulk notifications
 */
router.post('/bulk',
  authMiddleware,
  [
    body('notifications')
      .isArray({ min: 1 })
      .withMessage('Notifications array is required with at least one item'),
    body('notifications.*.recipientId')
      .notEmpty()
      .withMessage('Each notification must have a recipient ID'),
    body('notifications.*.type')
      .notEmpty()
      .withMessage('Each notification must have a type'),
    body('notifications.*.channel')
      .isIn(['push', 'email', 'sms', 'whatsapp', 'in_app', 'socket'])
      .withMessage('Each notification must have a valid channel')
  ],
  handleValidationErrors,
  async (req: AuthenticatedRequest, res: Response, next: NextFunction) => {
    try {
      const results = await NotificationService.sendBulkNotifications(
        req.body.notifications.map((n: any) => ({
          recipientId: n.recipientId,
          templateId: n.type,
          channel: n.channel,
          priority: n.priority || 'normal',
          variables: n.variables || {},
          scheduledAt: n.scheduledAt,
          expiresAt: n.expiresAt,
          metadata: n.metadata || {}
        }))
      );

      res.status(201).json({
        success: true,
        data: results,
        message: 'Bulk notifications processed',
        timestamp: new Date().toISOString(),
        version: '1.0'
      } as ApiResponse);
    } catch (error: unknown) {
      next(error);
    }
  }
);

/**
 * GET /api/v1/notifications
 * Get notifications with filtering
 */
router.get('/',
  authMiddleware,
  [
    query('status')
      .optional()
      .isIn(['pending', 'sent', 'delivered', 'failed', 'expired'])
      .withMessage('Invalid status filter'),
    query('channel')
      .optional()
      .isIn(['push', 'email', 'sms', 'whatsapp', 'in_app', 'socket'])
      .withMessage('Invalid channel filter'),
    query('priority')
      .optional()
      .isIn(['low', 'normal', 'high', 'urgent'])
      .withMessage('Invalid priority filter'),
    query('page')
      .optional()
      .isInt({ min: 1 })
      .toInt()
      .withMessage('Page must be a positive integer'),
    query('limit')
      .optional()
      .isInt({ min: 1, max: 100 })
      .toInt()
      .withMessage('Limit must be between 1 and 100')
  ],
  handleValidationErrors,
  async (req: AuthenticatedRequest, res: Response, next: NextFunction) => {
    try {
      const notifications = await NotificationService.getUserNotifications(
        req.user.id,
        {
          status: req.query.status as NotificationStatus | undefined,
          priority: req.query.priority as NotificationPriority | undefined,
          limit: Number(req.query.limit) || 50,
          page: Number(req.query.page) || 1
        }
      );

      res.json({
        success: true,
        data: notifications,
        message: 'Notifications retrieved successfully',
        timestamp: new Date().toISOString(),
        version: '1.0'
      } as ApiResponse);
    } catch (error: unknown) {
      next(error);
    }
  }
);

/**
 * GET /api/v1/notifications/:id
 * Get notification by ID
 */
router.get('/:id',
  authMiddleware,
  [
    param('id')
      .isUUID()
      .withMessage('Invalid notification ID')
  ],
  handleValidationErrors,
  async (req: AuthenticatedRequest, res: Response, next: NextFunction) => {
    try {
      // TODO: Implement getById method in NotificationService
      const notifications = await NotificationService.getUserNotifications(
        req.user.id,
        { limit: 1000 }
      );
      const notification = notifications.data?.notifications.find(n => n.id === req.params.id);

      if (!notification) {
        res.status(404).json({
          success: false,
          message: 'Notification not found'
        } as ApiResponse);
        return;
      }

      res.json({
        success: true,
        data: notification,
        message: 'Notification retrieved successfully',
        timestamp: new Date().toISOString(),
        version: '1.0'
      } as ApiResponse);
    } catch (error: unknown) {
      next(error);
    }
  }
);

/**
 * PUT /api/v1/notifications/:id/status
 * Update notification status
 */
router.put('/:id/status',
  authMiddleware,
  [
    param('id')
      .isUUID()
      .withMessage('Invalid notification ID'),
    body('status')
      .isIn(['cancelled', 'retrying'])
      .withMessage('Status must be cancelled or retrying')
  ],
  handleValidationErrors,
  async (req: AuthenticatedRequest, res: Response, next: NextFunction) => {
    try {
      // TODO: Implement updateStatus method in NotificationService
      // For now, return a basic response
      const notification = { id: req.params.id, status: req.body.status };

      res.json({
        success: true,
        data: notification,
        message: 'Notification status updated successfully',
        timestamp: new Date().toISOString(),
        version: '1.0'
      } as ApiResponse);
    } catch (error: unknown) {
      next(error);
    }
  }
);

/**
 * GET /api/v1/notifications/templates
 * Get notification templates
 */
router.get('/templates',
  authMiddleware,
  [
    query('type')
      .optional()
      .isString()
      .withMessage('Invalid template type'),
    query('channel')
      .optional()
      .isIn(['push', 'email', 'sms', 'whatsapp', 'in_app'])
      .withMessage('Invalid channel filter')
  ],
  handleValidationErrors,
  async (req: AuthenticatedRequest, res: Response, next: NextFunction) => {
    try {
      // TODO: Implement getTemplates method in NotificationService
      const templates: any[] = [];

      res.json({
        success: true,
        data: templates,
        message: 'Templates retrieved successfully',
        timestamp: new Date().toISOString(),
        version: '1.0'
      } as ApiResponse);
    } catch (error: unknown) {
      next(error);
    }
  }
);

/**
 * GET /api/v1/notifications/analytics
 * Get notification analytics
 */
router.get('/analytics',
  authMiddleware,
  [
    query('dateFrom')
      .optional()
      .isISO8601()
      .toDate()
      .withMessage('Date from must be a valid ISO 8601 date'),
    query('dateTo')
      .optional()
      .isISO8601()
      .toDate()
      .withMessage('Date to must be a valid ISO 8601 date'),
    query('channel')
      .optional()
      .isIn(['push', 'email', 'sms', 'whatsapp', 'in_app', 'socket'])
      .withMessage('Invalid channel filter')
  ],
  handleValidationErrors,
  async (req: AuthenticatedRequest, res: Response, next: NextFunction) => {
    try {
      const analytics = await NotificationService.getNotificationAnalytics(
        {
          startDate: req.query.dateFrom ? new Date(req.query.dateFrom as string) : new Date(Date.now() - 30 * 24 * 60 * 60 * 1000),
          endDate: req.query.dateTo ? new Date(req.query.dateTo as string) : new Date(),
          userId: req.user.id
        }
      );

      res.json({
        success: true,
        data: analytics,
        message: 'Analytics retrieved successfully',
        timestamp: new Date().toISOString(),
        version: '1.0'
      } as ApiResponse);
    } catch (error: unknown) {
      next(error);
    }
  }
);

/**
 * POST /api/v1/notifications/test
 * Test notification delivery
 */
router.post('/test',
  authMiddleware,
  [
    body('channel')
      .isIn(['push', 'email', 'sms', 'whatsapp'])
      .withMessage('Invalid test channel'),
    body('recipient')
      .notEmpty()
      .withMessage('Test recipient is required')
  ],
  handleValidationErrors,
  async (req: AuthenticatedRequest, res: Response, next: NextFunction) => {
    try {
      // TODO: Implement sendTest method in NotificationService
      // For now, use sendNotification with test template
      const result = await NotificationService.sendNotification({
        recipientId: req.body.recipient,
        templateId: 'test',
        recipientType: 'user',
        channels: [req.body.channel],
        priority: 'normal',
        variables: { message: 'Test notification' },
        metadata: { test: true }
      });

      res.json({
        success: true,
        data: result,
        message: 'Test notification sent successfully',
        timestamp: new Date().toISOString(),
        version: '1.0'
      } as ApiResponse);
    } catch (error: unknown) {
      next(error);
    }
  }
);

export default router;