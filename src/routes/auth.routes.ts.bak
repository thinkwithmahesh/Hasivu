/**
 * HASIVU Platform - Authentication Routes
 * User authentication endpoints with comprehensive security features
 * Generated by SuperClaude Wave 2: Backend Implementation - FIXED
 */
import { Router, Request, Response } from 'express';
import { authService } from '../services/auth.service';
import { DatabaseService } from '../services/database.service';
import { logger, log } from '../utils/logger';
import { asyncHandler, createValidationError, createConflictError } from '../middleware/error.middleware';
import { authMiddleware, optionalAuthMiddleware } from '../middleware/auth.middleware';
import { config } from '../config/environment';

const router = Router();

/**
 * Register new user
 * POST /auth/register
 */
router.post('/register', asyncHandler(async (req: Request, res: Response) => {
  const { email, password, passwordConfirm, firstName, lastName, role = 'parent' } = req.body;

  // Input validation
  if (!email || !password || !firstName || !lastName) {
    throw createValidationError('All required fields must be provided');
  }

  if (password !== passwordConfirm) {
    throw createValidationError('Passwords do not match');
  }

  // Validate email format
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  if (!emailRegex.test(email)) {
    throw createValidationError('Invalid email format');
  }

  // Validate password strength
  const passwordValidation = authService.validatePassword(password);
  if (!passwordValidation.valid) {
    throw createValidationError(`Password validation failed: ${passwordValidation.message}`);
  }

  // Check if user already exists
  const existingUser = await DatabaseService.client.user.findUnique({
    where: { email: email.toLowerCase() }
  });
  
  if (existingUser) {
    throw createConflictError('User with this email already exists');
  }

  // Hash password
  const passwordHash = await authService.hashPassword(password);

  // Create user in database transaction
  const user = await DatabaseService.transaction(async (prisma) => {
    const newUser = await prisma.user.create({
      data: {
        email: email.toLowerCase(),
        passwordHash,
        firstName,
        lastName,
        role,
        createdAt: new Date(),
        updatedAt: new Date()
      },
      select: {
        id: true,
        email: true,
        firstName: true,
        lastName: true,
        role: true,
        createdAt: true
      }
    });

    // Note: Role assignment simplified for this schema
    // In production, implement proper role management via schema relations

    return newUser;
  });

  // Log registration
  logger.info('User registered successfully', { userId: user.id, email: user.email, role });

  res.status(201).json({
    success: true,
    message: 'User registered successfully',
    user: {
      id: user.id,
      email: user.email,
      firstName: user.firstName,
      lastName: user.lastName,
      role: user.role
    }
  });
}));

/**
 * User login
 * POST /auth/login
 */
router.post('/login', asyncHandler(async (req: Request, res: Response) => {
  const { email, password, rememberMe = false } = req.body;

  // Input validation
  if (!email || !password) {
    throw createValidationError('Email and password are required');
  }

  // Authenticate user
  const authResult = await authService.authenticate({
    email: email.toLowerCase(),
    password,
    rememberMe,
    userAgent: req.headers['user-agent'] || 'Unknown',
    ipAddress: req.ip || 'Unknown'
  });

  // Set additional metadata for session
  await authService.updateSessionActivity(authResult.sessionId, {
    lastActivity: new Date(),
    ipAddress: req.ip,
    userAgent: req.headers['user-agent']
  });

  // Set HTTP-only cookies for web clients
  const cookieOptions = {
    httpOnly: true,
    secure: config.server.nodeEnv === 'production',
    sameSite: 'strict' as const,
    maxAge: rememberMe ? 30 * 24 * 60 * 60 * 1000 : 24 * 60 * 60 * 1000 // 30 days or 1 day
  };

  res.cookie('accessToken', authResult.tokens.accessToken, cookieOptions);
  res.cookie('refreshToken', authResult.tokens.refreshToken, {
    ...cookieOptions,
    maxAge: 7 * 24 * 60 * 60 * 1000 // 7 days
  });

  res.status(200).json({
    success: true,
    message: 'Login successful',
    user: authResult.user,
    tokens: authResult.tokens
  });
}));

/**
 * Refresh access token
 * POST /auth/refresh
 */
router.post('/refresh', asyncHandler(async (req: Request, res: Response) => {
  const { refreshToken } = req.body;
  
  // Also check cookies
  const tokenFromCookie = req.cookies?.refreshToken;
  const token = refreshToken || tokenFromCookie;
  
  if (!token) {
    throw createValidationError('Refresh token is required');
  }

  // Refresh the token
  const result = await authService.refreshToken(token);

  // Update cookie if it was provided via cookie
  if (tokenFromCookie) {
    const cookieOptions = {
      httpOnly: true,
      secure: config.server.nodeEnv === 'production',
      sameSite: 'strict' as const,
      maxAge: 24 * 60 * 60 * 1000 // 1 day
    };
    res.cookie('accessToken', result.accessToken, cookieOptions);
  }

  res.status(200).json({
    success: true,
    message: 'Token refreshed successfully',
    accessToken: result.accessToken
  });
}));

/**
 * User logout
 * POST /auth/logout
 */
router.post('/logout', authMiddleware, asyncHandler(async (req: any, res: Response) => {
  await authService.logout(req.sessionId);

  // Clear cookies
  res.clearCookie('accessToken');
  res.clearCookie('refreshToken');

  res.status(200).json({
    success: true,
    message: 'Logout successful'
  });
}));

/**
 * Logout from all sessions
 * POST /auth/logout-all
 */
router.post('/logout-all', authMiddleware, asyncHandler(async (req: any, res: Response) => {
  await authService.logoutAll(req.userId);

  // Clear cookies
  res.clearCookie('accessToken');
  res.clearCookie('refreshToken');

  res.status(200).json({
    success: true,
    message: 'Logged out from all sessions successfully'
  });
}));

/**
 * Get current user profile
 * GET /auth/me
 */
router.get('/me', authMiddleware, asyncHandler(async (req: any, res: Response) => {
  const userId = req.userId;

  const user = await DatabaseService.client.user.findUnique({
    where: { id: userId },
    select: {
      id: true,
      email: true,
      firstName: true,
      lastName: true,
      role: true,
      phone: true,
      timezone: true,
      language: true,
      preferences: true,
      createdAt: true,
      updatedAt: true
    }
  });

  if (!user) {
    throw createValidationError('User not found');
  }

  // Extract permissions from user roles based on proper schema
  const permissions: string[] = []; // TODO: Implement based on role system
  const roles: string[] = [user.role];

  res.status(200).json({
    success: true,
    user: {
      ...user,
      permissions,
      roles
    },
    sessionId: req.sessionId
  });
}));

/**
 * Update user profile
 * PATCH /auth/profile
 */
router.patch('/profile', authMiddleware, asyncHandler(async (req: any, res: Response) => {
  const userId = req.userId;
  const { firstName, lastName, phoneNumber, timezone, language, preferences } = req.body;

  // Update user profile
  const updatedUser = await DatabaseService.client.user.update({
    where: { id: userId },
    data: {
      ...(firstName && { firstName }),
      ...(lastName && { lastName }),
      ...(phoneNumber && { phone: phoneNumber }),
      ...(timezone && { timezone }),
      ...(language && { language }),
      ...(preferences && { preferences }),
      updatedAt: new Date()
    },
    select: {
      id: true,
      email: true,
      firstName: true,
      lastName: true,
      phone: true,
      timezone: true,
      language: true,
      preferences: true,
      updatedAt: true
    }
  });

  logger.info('User profile updated', { userId, changes: Object.keys(req.body) });

  res.status(200).json({
    success: true,
    message: 'Profile updated successfully',
    user: updatedUser
  });
}));

/**
 * Change password
 * PATCH /auth/change-password
 */
router.patch('/change-password', authMiddleware, asyncHandler(async (req: any, res: Response) => {
  const userId = req.userId;
  const { currentPassword, newPassword, newPasswordConfirm } = req.body;

  // Input validation
  if (!currentPassword || !newPassword || !newPasswordConfirm) {
    throw createValidationError('All password fields are required');
  }

  if (newPassword !== newPasswordConfirm) {
    throw createValidationError('New passwords do not match');
  }

  // Validate new password strength
  const passwordValidation = authService.validatePassword(newPassword);
  if (!passwordValidation.valid) {
    throw createValidationError(`Password validation failed: ${passwordValidation.message}`);
  }

  // Get current user
  const user = await DatabaseService.client.user.findUnique({
    where: { id: userId }
  });

  if (!user) {
    throw createValidationError('User not found');
  }

  // Verify current password
  const isCurrentPasswordValid = await authService.verifyPassword(currentPassword, user.passwordHash);
  if (!isCurrentPasswordValid) {
    throw createValidationError('Current password is incorrect');
  }

  // Hash new password
  const newPasswordHash = await authService.hashPassword(newPassword);

  // Update password
  await DatabaseService.client.user.update({
    where: { id: userId },
    data: {
      passwordHash: newPasswordHash,
      updatedAt: new Date()
    }
  });

  // Log password change
  logger.info('Password changed', { userId, timestamp: new Date() });

  // Logout from all other sessions for security
  await authService.logoutAll(userId);

  res.status(200).json({
    success: true,
    message: 'Password changed successfully'
  });
}));

/**
 * Check authentication status
 * GET /auth/status
 */
router.get('/status', optionalAuthMiddleware, asyncHandler(async (req: any, res: Response) => {
  if (req.userId) {
    res.status(200).json({
      authenticated: true,
      userId: req.userId,
      sessionId: req.sessionId
    });
  } else {
    res.status(200).json({
      authenticated: false
    });
  }
}));

/**
 * Request password reset (placeholder)
 * POST /auth/forgot-password
 */
router.post('/forgot-password', asyncHandler(async (req: Request, res: Response) => {
  const { email } = req.body;

  if (!email) {
    throw createValidationError('Email is required');
  }

  // Check if user exists
  const user = await DatabaseService.client.user.findUnique({
    where: { email: email.toLowerCase() }
  });

  // Always return success to prevent email enumeration
  res.status(200).json({
    success: true,
    message: 'If an account with this email exists, a password reset link has been sent'
  });

  // If user exists, log the request (actual implementation would send email)
  if (user) {
    logger.info('Password reset requested', { userId: user.id, email: user.email });
    // TODO: Implement email sending logic
  }
}));

/**
 * Validate password strength
 * POST /auth/validate-password
 */
router.post('/validate-password', asyncHandler(async (req: Request, res: Response) => {
  const { password } = req.body;

  if (!password) {
    throw createValidationError('Password is required');
  }

  const validation = authService.validatePassword(password);

  res.status(200).json({
    success: true,
    validation
  });
}));

export { router as authRouter };
export default router;