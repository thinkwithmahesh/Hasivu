/**
 * HASIVU Platform - Payment Routes
 * Razorpay payment gateway API endpoints
 * Generated by SuperClaude Wave 4: Payment Integration
 */

import { Router } from 'express';
import { body, param, query, validationResult } from 'express-validator';
import { Request, Response, NextFunction } from 'express';
import { paymentService } from '@/services/payment.service';
import { authMiddleware, AuthenticatedRequest } from '@/middleware/auth.middleware';
import requestLogger from '@/middleware/request-logger.middleware';
import { generalRateLimit as rateLimiter } from '@/middleware/rateLimiter.middleware';
import { logger, log } from '@/utils/logger';
import { ApiResponse, ApiError } from '@/types/api.types';

const router = Router();

/**
 * Validation middleware
 */
const handleValidationErrors = (req: Request, res: Response, next: NextFunction): void => {
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    res.status(400).json({
      success: false,
      message: 'Validation failed',
      error: {
        code: 'VALIDATION_ERROR',
        message: 'Validation failed',
        details: errors.array(),
        timestamp: new Date().toISOString()
      },
      timestamp: new Date().toISOString(),
      version: '1.0'
    } as ApiResponse);
    return;
  }
  next();
};

/**
 * Apply middleware to all routes
 */
router.use(requestLogger);
// Use the default rate limiter for payments
router.use(rateLimiter);

/**
 * Create payment order
 * POST /api/v1/payments/orders
 */
router.post('/orders',
  authMiddleware,
  [
    body('amount')
      .isFloat({ min: 1 })
      .withMessage('Amount must be a positive number'),
    body('currency')
      .isIn(['INR'])
      .withMessage('Currency must be INR'),
    body('orderId')
      .optional()
      .isUUID()
      .withMessage('Order ID must be a valid UUID'),
    body('subscriptionId')
      .optional()
      .isUUID()
      .withMessage('Subscription ID must be a valid UUID'),
    body('description')
      .isString()
      .isLength({ min: 1, max: 255 })
      .withMessage('Description is required and must be less than 255 characters'),
    body('notes')
      .optional()
      .isObject()
      .withMessage('Notes must be an object'),
    body('receipt')
      .optional()
      .isString()
      .isLength({ max: 40 })
      .withMessage('Receipt must be less than 40 characters')
  ],
  handleValidationErrors,
  async (req: AuthenticatedRequest, res: Response, next: NextFunction) => {
    try {
      const { amount, currency, orderId, subscriptionId, description, notes, receipt } = req.body;
      
      const paymentOrder = await paymentService.createPaymentOrder({
        userId: req.user!.id,
        amount,
        currency,
        notes,
        receipt
      });
      
      const razorpayConfig = {
        key: process.env.RAZORPAY_KEY_ID,
        order_id: paymentOrder.razorpayOrderId,
        amount: paymentOrder.amount,
        currency: paymentOrder.currency,
        name: 'HASIVU Platform',
        description: description || 'HASIVU Platform Payment',
        prefill: {
          email: req.user!.email,
          contact: ''
        },
        theme: {
          color: '#3B82F6'
        }
      };
      
      res.status(201).json({
        success: true,
        data: {
          paymentOrder,
          razorpayConfig
        },
        message: 'Payment order created successfully',
        timestamp: new Date().toISOString(),
        version: '1.0'
      } as ApiResponse);
      
    } catch (error: unknown) {
      logger.error('Create payment order error:', error);
      next(error);
    }
  }
);

/**
 * Verify and complete payment
 * POST /api/v1/payments/verify
 */
router.post('/verify',
  authMiddleware,
  [
    body('razorpay_payment_id')
      .isString()
      .notEmpty()
      .withMessage('Razorpay payment ID is required'),
    body('razorpay_order_id')
      .isString()
      .notEmpty()
      .withMessage('Razorpay order ID is required'),
    body('razorpay_signature')
      .isString()
      .notEmpty()
      .withMessage('Razorpay signature is required')
  ],
  handleValidationErrors,
  async (req: AuthenticatedRequest, res: Response, next: NextFunction) => {
    try {
      const { razorpay_payment_id, razorpay_order_id, razorpay_signature } = req.body;
      
      const transaction = await paymentService.capturePayment(
        razorpay_order_id,
        razorpay_payment_id,
        razorpay_signature
      );
      
      res.json({
        success: true,
        data: transaction,
        message: 'Payment verified and completed successfully',
        timestamp: new Date().toISOString(),
        version: '1.0'
      } as ApiResponse);
      
    } catch (error: unknown) {
      logger.error('Payment verification error:', error);
      next(error);
    }
  }
);

/**
 * Create refund
 * POST /api/v1/payments/refunds
 */
router.post('/refunds',
  authMiddleware,
  [
    body('paymentId')
      .isString()
      .notEmpty()
      .withMessage('Payment ID is required'),
    body('amount')
      .optional()
      .isFloat({ min: 1 })
      .withMessage('Amount must be a positive number'),
    body('reason')
      .isString()
      .isLength({ min: 1, max: 255 })
      .withMessage('Reason is required and must be less than 255 characters'),
    body('notes')
      .optional()
      .isObject()
      .withMessage('Notes must be an object')
  ],
  handleValidationErrors,
  async (req: AuthenticatedRequest, res: Response, next: NextFunction) => {
    try {
      const { paymentId, amount, reason, notes } = req.body;
      
      const refund = await paymentService.createRefund(
        paymentId,
        amount,
        reason
      );
      
      res.status(201).json({
        success: true,
        data: refund,
        message: 'Refund initiated successfully',
        timestamp: new Date().toISOString(),
        version: '1.0'
      } as ApiResponse);
      
    } catch (error: unknown) {
      logger.error('Create refund error:', error);
      next(error);
    }
  }
);

/**
 * Create subscription
 * POST /api/v1/payments/subscriptions
 */
router.post('/subscriptions',
  authMiddleware,
  [
    body('planId')
      .isString()
      .notEmpty()
      .withMessage('Plan ID is required'),
    body('totalCount')
      .optional()
      .isInt({ min: 1 })
      .withMessage('Total count must be a positive integer'),
    body('startAt')
      .optional()
      .isISO8601()
      .withMessage('Start date must be a valid ISO 8601 date'),
    body('addons')
      .optional()
      .isArray()
      .withMessage('Addons must be an array'),
    body('notes')
      .optional()
      .isObject()
      .withMessage('Notes must be an object')
  ],
  handleValidationErrors,
  async (req: AuthenticatedRequest, res: Response, next: NextFunction) => {
    try {
      const { planId, totalCount, startAt, addons, notes } = req.body;
      
      const subscription = await paymentService.createSubscription({
        userId: req.user!.id,
        planId,
        notes
      });
      
      res.status(201).json({
        success: true,
        data: subscription,
        message: 'Subscription created successfully',
        timestamp: new Date().toISOString(),
        version: '1.0'
      } as ApiResponse);
      
    } catch (error: unknown) {
      logger.error('Create subscription error:', error);
      next(error);
    }
  }
);

/**
 * Get transaction history
 * GET /api/v1/payments/transactions
 */
router.get('/transactions',
  authMiddleware,
  [
    query('status')
      .optional()
      .isIn(['created', 'authorized', 'captured', 'refunded', 'failed'])
      .withMessage('Invalid status'),
    query('startDate')
      .optional()
      .isISO8601()
      .toDate()
      .withMessage('Start date must be a valid ISO 8601 date'),
    query('endDate')
      .optional()
      .isISO8601()
      .toDate()
      .withMessage('End date must be a valid ISO 8601 date'),
    query('limit')
      .optional()
      .isInt({ min: 1, max: 100 })
      .toInt()
      .withMessage('Limit must be between 1 and 100'),
    query('offset')
      .optional()
      .isInt({ min: 0 })
      .toInt()
      .withMessage('Offset must be a non-negative integer')
  ],
  handleValidationErrors,
  async (req: AuthenticatedRequest, res: Response, next: NextFunction) => {
    try {
      const { status, startDate, endDate, limit = 20, offset = 0 } = req.query;
      
      const result = await paymentService.viewAllPayments({
        userId: req.user!.id,
        status: status as string,
        startDate: startDate ? new Date(startDate as string) : undefined,
        endDate: endDate ? new Date(endDate as string) : undefined,
        limit: limit as number,
        offset: offset as number
      });
      
      res.json({
        success: true,
        data: {
          transactions: result.data || [],
          pagination: {
            limit,
            offset,
            total: result.data?.length || 0,
            hasMore: false
          }
        },
        message: 'Transaction history retrieved successfully',
        timestamp: new Date().toISOString(),
        version: '1.0'
      } as ApiResponse);
      
    } catch (error: unknown) {
      logger.error('Get transaction history error:', error);
      next(error);
    }
  }
);

/**
 * Get payment order details
 * GET /api/v1/payments/orders/:orderId
 */
router.get('/orders/:orderId',
  authMiddleware,
  [
    param('orderId')
      .isString()
      .notEmpty()
      .withMessage('Order ID is required')
  ],
  handleValidationErrors,
  async (req: AuthenticatedRequest, res: Response, next: NextFunction) => {
    try {
      const { orderId } = req.params;
      
      const paymentOrder = await paymentService.getPaymentOrder(orderId);
      
      if (!paymentOrder) {
        return res.status(404).json({
          success: false,
          message: 'Payment order not found',
          timestamp: new Date().toISOString(),
          version: '1.0'
        } as ApiResponse);
      }
      
      // Verify user ownership
      if (paymentOrder.userId !== req.user!.id) {
        return res.status(403).json({
          success: false,
          message: 'Access denied',
          timestamp: new Date().toISOString(),
          version: '1.0'
        } as ApiResponse);
      }
      
      return res.json({
        success: true,
        data: paymentOrder,
        message: 'Payment order details retrieved successfully',
        timestamp: new Date().toISOString(),
        version: '1.0'
      } as ApiResponse);
      
    } catch (error: unknown) {
      logger.error('Get payment order error:', error);
      next(error);
    }
  }
);

/**
 * Webhook endpoint for Razorpay
 * POST /api/v1/payments/webhook
 */
router.post('/webhook',
  // No auth middleware for webhooks
  async (req: Request, res: Response, next: NextFunction) => {
    try {
      const payload = req.body;
      const signature = req.get('X-Razorpay-Signature');
      
      if (!signature) {
        return res.status(400).json({
          success: false,
          message: 'Missing webhook signature',
          timestamp: new Date().toISOString(),
          version: '1.0'
        } as ApiResponse);
      }
      
      await paymentService.handleWebhook(payload, signature);
      
      return res.json({
        success: true,
        message: 'Webhook processed successfully',
        timestamp: new Date().toISOString(),
        version: '1.0'
      } as ApiResponse);
      
    } catch (error: unknown) {
      logger.error('Payment webhook error:', error);
      // Still return success to prevent Razorpay retries
      return res.status(200).json({
        success: false,
        message: 'Webhook processing failed',
        timestamp: new Date().toISOString(),
        version: '1.0'
      } as ApiResponse);
    }
  }
);

/**
 * Get subscription details
 * GET /api/v1/payments/subscriptions/:subscriptionId
 */
router.get('/subscriptions/:subscriptionId',
  authMiddleware,
  [
    param('subscriptionId')
      .isString()
      .notEmpty()
      .withMessage('Subscription ID is required')
  ],
  handleValidationErrors,
  async (req: AuthenticatedRequest, res: Response, next: NextFunction) => {
    try {
      const { subscriptionId } = req.params;
      
      const subscription = await paymentService.getSubscriptionById(subscriptionId);
      
      if (!subscription) {
        return res.status(404).json({
          success: false,
          message: 'Subscription not found',
          timestamp: new Date().toISOString(),
          version: '1.0'
        } as ApiResponse);
      }
      
      // Verify user ownership
      if (subscription.userId !== req.user!.id) {
        return res.status(403).json({
          success: false,
          message: 'Access denied',
          timestamp: new Date().toISOString(),
          version: '1.0'
        } as ApiResponse);
      }
      
      res.json({
        success: true,
        data: subscription,
        message: 'Subscription details retrieved successfully',
        timestamp: new Date().toISOString(),
        version: '1.0'
      } as ApiResponse);
      
    } catch (error: unknown) {
      logger.error('Get subscription error:', error);
      next(error);
    }
  }
);

/**
 * Cancel subscription
 * POST /api/v1/payments/subscriptions/:subscriptionId/cancel
 */
router.post('/subscriptions/:subscriptionId/cancel',
  authMiddleware,
  [
    param('subscriptionId')
      .isString()
      .notEmpty()
      .withMessage('Subscription ID is required'),
    body('cancelAtCycleEnd')
      .optional()
      .isBoolean()
      .withMessage('Cancel at cycle end must be a boolean')
  ],
  handleValidationErrors,
  async (req: AuthenticatedRequest, res: Response, next: NextFunction) => {
    try {
      const { subscriptionId } = req.params;
      const { cancelAtCycleEnd = true } = req.body;
      
      const cancelledSubscription = await paymentService.cancelSubscription({
        userId: req.user!.id,
        subscriptionId,
        cancelAtCycleEnd
      });
      
      res.json({
        success: true,
        data: cancelledSubscription,
        message: 'Subscription cancelled successfully',
        timestamp: new Date().toISOString(),
        version: '1.0'
      } as ApiResponse);
      
    } catch (error: unknown) {
      logger.error('Cancel subscription error:', error);
      next(error);
    }
  }
);

/**
 * Get payment analytics
 * GET /api/v1/payments/analytics
 */
router.get('/analytics',
  authMiddleware,
  [
    query('period')
      .optional()
      .isIn(['7d', '30d', '90d', '1y'])
      .withMessage('Period must be one of: 7d, 30d, 90d, 1y'),
    query('type')
      .optional()
      .isIn(['revenue', 'transactions', 'subscriptions'])
      .withMessage('Type must be one of: revenue, transactions, subscriptions')
  ],
  handleValidationErrors,
  async (req: AuthenticatedRequest, res: Response, next: NextFunction) => {
    try {
      const { period = '30d', type = 'revenue' } = req.query;
      
      const analytics = await paymentService.getPaymentAnalytics({
        userId: req.user!.id,
        period: period as string,
        type: type as string
      });
      
      res.json({
        success: true,
        data: analytics,
        message: 'Payment analytics retrieved successfully',
        timestamp: new Date().toISOString(),
        version: '1.0'
      } as ApiResponse);
      
    } catch (error: unknown) {
      logger.error('Get payment analytics error:', error);
      next(error);
    }
  }
);

export default router;