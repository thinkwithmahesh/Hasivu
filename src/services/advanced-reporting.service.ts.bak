/**
 * HASIVU Epic 3 â†’ Story 5: Advanced Reporting & Insights Platform
 *
 * Comprehensive enterprise-grade reporting and analytics platform with:
 * - Automated report generation engine with AI-powered insights
 * - Multi-format exports (PDF, Excel, CSV, PowerBI, Tableau)
 * - Advanced analytics dashboard with real-time streaming
 * - Intelligent insights engine with anomaly detection
 * - Enterprise reporting infrastructure with multi-tenant isolation
 *
 * Production-ready implementation supporting 500+ schools
 * FINAL STORY to achieve 10/10 production readiness
 *
 * @author HASIVU Development Team
 * @version 1.0.0
 * @since 2024-09-18
 */

import { EventEmitter } from 'events';
import { v4 as uuidv4 } from 'uuid';
import PDFDocument from 'pdfkit';
import * as ExcelJS from 'exceljs';
import * as fs from 'fs/promises';
import { createWriteStream } from 'fs';
import * as path from 'path';
import { logger } from '../utils/logger';
import { MetricsCollector } from './metrics.service';
import { CacheManager } from './cache-manager.service';
import { AnalyticsService } from './analytics.service';
import { DataWarehouseOrchestrator } from '../analytics/data-warehouse/core/warehouse-orchestrator';
import { AIInsightsEngine } from './ai-insights.service';
import { NotificationService } from './notification.service';

/**
 * Report template interface
 */
export interface ReportTemplate {
  id: string;
  name: string;
  description: string;
  category: 'executive' | 'operational' | 'financial' | 'academic' | 'custom';
  layout: {
    sections: ReportSection[];
    styling: ReportStyling;
    branding: BrandingConfig;
  };
  dataRequirements: DataRequirement[];
  parameters: ReportParameter[];
  scheduleOptions: ScheduleConfig;
  exportFormats: ExportFormat[];
  tenantId?: string;
  createdAt: Date;
  updatedAt: Date;
  version: number;
}

/**
 * Report section configuration
 */
export interface ReportSection {
  id: string;
  type: 'header' | 'summary' | 'chart' | 'table' | 'text' | 'kpi' | 'insights';
  title: string;
  position: { row: number; column: number; span: number };
  config: {
    dataSource?: string;
    visualization?: VisualizationConfig;
    formatting?: FormattingConfig;
    filters?: FilterConfig[];
  };
}

/**
 * Visualization configuration
 */
export interface VisualizationConfig {
  type: 'line' | 'bar' | 'pie' | 'area' | 'scatter' | 'heatmap' | 'gauge' | 'treemap';
  dimensions: string[];
  metrics: string[];
  colors: string[];
  animations: boolean;
  interactions: boolean;
  responsive: boolean;
}

/**
 * Report scheduling configuration
 */
export interface ScheduleConfig {
  enabled: boolean;
  frequency: 'hourly' | 'daily' | 'weekly' | 'monthly' | 'quarterly' | 'yearly' | 'custom';
  interval?: number;
  cronExpression?: string;
  timezone: string;
  recipients: RecipientConfig[];
  deliveryOptions: DeliveryConfig;
}

/**
 * Export format configuration
 */
export interface ExportFormat {
  type: 'pdf' | 'excel' | 'csv' | 'json' | 'powerbi' | 'tableau' | 'html';
  enabled: boolean;
  options: Record<string, any>;
  compression?: boolean;
  password?: boolean;
}

/**
 * Generated report interface
 */
export interface GeneratedReport {
  id: string;
  templateId: string;
  name: string;
  description?: string;
  generatedAt: Date;
  generatedBy: string;
  tenantId: string;
  parameters: Record<string, any>;
  dateRange: { start: Date; end: Date };
  data: ReportData;
  insights: AIGeneratedInsight[];
  metadata: ReportMetadata;
  exports: ReportExport[];
  status: 'generating' | 'completed' | 'failed' | 'scheduled';
  executionTime: number;
  error?: string;
}

/**
 * Report data structure
 */
export interface ReportData {
  summary: {
    totalRecords: number;
    dateRange: { start: Date; end: Date };
    generationTime: number;
    dataFreshness: Date;
  };
  sections: {
    [sectionId: string]: {
      type: string;
      data: any;
      visualizations: any[] | undefined;
      metadata: any;
    };
  };
  rawData: {
    [sourceId: string]: any[] | undefined;
  };
  calculations: {
    kpis: Record<string, number>;
    trends: Record<string, TrendAnalysis>;
    comparisons: Record<string, ComparisonAnalysis>;
  };
}

/**
 * AI-generated insight
 */
export interface AIGeneratedInsight {
  id: string;
  type: 'trend' | 'anomaly' | 'recommendation' | 'prediction' | 'correlation';
  priority: 'low' | 'medium' | 'high' | 'critical';
  confidence: number;
  title: string;
  description: string;
  details: string;
  visualizations: VisualizationConfig[];
  actionItems: ActionItem[];
  dataPoints: any[] | undefined;
  metadata: {
    algorithm: string;
    modelVersion: string;
    generatedAt: Date;
    reviewStatus: 'pending' | 'approved' | 'rejected';
  };
}

/**
 * Trend analysis structure
 */
export interface TrendAnalysis {
  direction: 'up' | 'down' | 'stable';
  strength: number;
  significance: number;
  projectedValue: number;
  confidence: number;
  timeSeriesData: Array<{ date: Date; value: number; prediction?: number }>;
}

/**
 * Comparison analysis structure
 */
export interface ComparisonAnalysis {
  baseline: any;
  current: any;
  change: {
    absolute: number;
    percentage: number;
    significance: number;
  };
  context: string[];
}

/**
 * Advanced Reporting Service
 */
export class AdvancedReportingService extends EventEmitter {
  private readonly metrics = new MetricsCollector();
  private readonly cache = new CacheManager();

  private readonly templates = new Map<string, ReportTemplate>();
  private readonly generatedReports = new Map<string, GeneratedReport>();
  private readonly scheduledJobs = new Map<string, NodeJS.Timeout>();
  private readonly activeGenerations = new Set<string>();

  private isRunning = false;

  constructor(
    private readonly analyticsService: AnalyticsService,
    private readonly dataWarehouse: DataWarehouseOrchestrator,
    private readonly aiInsights: AIInsightsEngine,
    private readonly notifications: NotificationService,
    private readonly config: {
      maxConcurrentGenerations: number;
      cacheTimeout: number;
      exportPath: string;
      aiInsightsEnabled: boolean;
      securityLevel: 'basic' | 'enhanced' | 'enterprise';
    }
  ) {
    super();
    this.setupEventHandlers();
  }

  /**
   * Initialize the advanced reporting service
   */
  async initialize(): Promise<void> {
    try {
      logger.info('Initializing Advanced Reporting Service...');

      // Ensure export directory exists
      await fs.mkdir(this.config.exportPath, { recursive: true });

      // Load existing templates
      await this.loadReportTemplates();

      // Start scheduled report processor
      this.startScheduledReportProcessor();

      // Initialize AI insights engine if enabled
      if (this.config.aiInsightsEnabled) {
        await this.aiInsights.initialize();
      }

      this.isRunning = true;

      logger.info('Advanced Reporting Service initialized successfully', {
        templatesLoaded: this.templates.size,
        aiInsightsEnabled: this.config.aiInsightsEnabled,
        exportPath: this.config.exportPath
      });

      this.emit('initialized');

    } catch (error: unknown) {
      logger.error('Failed to initialize Advanced Reporting Service', { error });
      throw error;
    }
  }

  /**
   * Create a new report template
   */
  async createReportTemplate(
    templateData: Omit<ReportTemplate, 'id' | 'createdAt' | 'updatedAt' | 'version'>,
    userId: string
  ): Promise<ReportTemplate> {
    try {
      logger.info('Creating report template', {
        name: templateData.name,
        category: templateData.category,
        userId
      });

      const template: ReportTemplate = {
        ...templateData,
        id: uuidv4(),
        createdAt: new Date(),
        updatedAt: new Date(),
        version: 1
      };

      // Validate template structure
      await this.validateReportTemplate(template);

      // Store template
      this.templates.set(template.id, template);

      // Persist to database
      await this.persistReportTemplate(template);

      logger.info('Report template created successfully', {
        templateId: template.id,
        name: template.name
      });

      this.metrics.increment('reporting.template.created');
      this.emit('template:created', template);

      return template;

    } catch (error: unknown) {
      logger.error('Failed to create report template', { error, templateData });
      this.metrics.increment('reporting.template.creation.failed');
      throw error;
    }
  }

  /**
   * Generate a comprehensive report
   */
  async generateReport(
    templateId: string,
    parameters: Record<string, any>,
    userId: string,
    tenantId: string,
    options: {
      includeInsights?: boolean;
      exportFormats?: string[];
      schedule?: boolean;
      priority?: 'low' | 'normal' | 'high';
    } = {}
  ): Promise<GeneratedReport> {
    const startTime = Date.now();
    const reportId = uuidv4();

    try {
      logger.info('Starting report generation', {
        reportId,
        templateId,
        userId,
        tenantId,
        options
      });

      // Check concurrent generation limits
      if (this.activeGenerations.size >= this.config.maxConcurrentGenerations) {
        throw new Error('Maximum concurrent report generations reached');
      }

      this.activeGenerations.add(reportId);

      // Get template
      const template = this.templates.get(templateId);
      if (!template) {
        throw new Error(`Report template not found: ${templateId}`);
      }

      // Validate tenant access
      if (template.tenantId && template.tenantId !== tenantId) {
        throw new Error('Access denied to this report template');
      }

      // Initialize report
      const report: GeneratedReport = {
        id: reportId,
        templateId,
        name: `${template.name} - ${new Date().toISOString().split('T')[0]}`,
        description: template.description,
        generatedAt: new Date(),
        generatedBy: userId,
        tenantId,
        parameters,
        dateRange: parameters.dateRange || this.getDefaultDateRange(),
        data: {
          summary: {
            totalRecords: 0,
            dateRange: parameters.dateRange || this.getDefaultDateRange(),
            generationTime: 0,
            dataFreshness: new Date()
          },
          sections: {},
          rawData: {},
          calculations: {
            kpis: {},
            trends: {},
            comparisons: {}
          }
        },
        insights: [],
        metadata: {
          templateVersion: template.version,
          dataSourcesUsed: [],
          generationMethod: 'automated',
          qualityScore: 0
        },
        exports: [],
        status: 'generating',
        executionTime: 0
      };

      this.generatedReports.set(reportId, report);
      this.emit('report:generation:started', report);

      // Generate report data
      await this.generateReportData(report, template);

      // Generate AI insights if enabled
      if (options.includeInsights !== false && this.config.aiInsightsEnabled) {
        report.insights = await this.generateAIInsights(report, template);
      }

      // Create exports
      const exportFormats = options.exportFormats || template.exportFormats.filter(f => f.enabled).map(f => f.type);
      for (const format of exportFormats) {
        const exportResult = await this.exportReport(report, format as any);
        report.exports.push(exportResult);
      }

      // Finalize report
      report.status = 'completed';
      report.executionTime = Date.now() - startTime;
      report.metadata.qualityScore = this.calculateQualityScore(report);

      this.generatedReports.set(reportId, report);
      this.activeGenerations.delete(reportId);

      // Persist report
      await this.persistGeneratedReport(report);

      // Send notifications if scheduled
      if (options.schedule) {
        await this.sendReportNotifications(report, template);
      }

      logger.info('Report generated successfully', {
        reportId,
        executionTime: report.executionTime,
        sectionsGenerated: Object.keys(report.data.sections).length,
        insightsGenerated: report.insights.length,
        exportsCreated: report.exports.length
      });

      this.metrics.timing('reporting.generation.time', report.executionTime);
      this.metrics.increment('reporting.generation.completed');
      this.emit('report:generation:completed', report);

      return report;

    } catch (error: unknown) {
      this.activeGenerations.delete(reportId);

      const failedReport = this.generatedReports.get(reportId);
      if (failedReport) {
        failedReport.status = 'failed';
        failedReport.error = (error instanceof Error ? error.message : String(error));
        failedReport.executionTime = Date.now() - startTime;
      }

      logger.error('Failed to generate report', {
        error,
        reportId,
        templateId,
        executionTime: Date.now() - startTime
      });

      this.metrics.timing('reporting.generation.time.failed', Date.now() - startTime);
      this.metrics.increment('reporting.generation.failed');
      this.emit('report:generation:failed', { reportId, error });

      throw error;
    }
  }

  /**
   * Generate AI-powered insights for a report
   */
  private async generateAIInsights(
    report: GeneratedReport,
    template: ReportTemplate
  ): Promise<AIGeneratedInsight[]> {
    try {
      logger.debug('Generating AI insights', { reportId: report.id });

      const insights: AIGeneratedInsight[] = [];

      // Analyze trends
      const trendInsights = await this.aiInsights.analyzeTrends(
        report.data.rawData,
        report.dateRange
      );

      // Detect anomalies
      const anomalyInsights = await this.aiInsights.detectAnomalies(
        report.data.rawData,
        { sensitivity: 0.8, algorithm: 'isolation_forest' }
      );

      // Generate predictions
      const predictionInsights = await this.aiInsights.generatePredictions(
        report.data.rawData,
        { horizon: '30d', confidence: 0.85 }
      );

      // Find correlations
      const correlationInsights = await this.aiInsights.findCorrelations(
        report.data.rawData,
        { threshold: 0.7, method: 'pearson' }
      );

      // Generate recommendations
      const recommendations = await this.aiInsights.generateRecommendations(
        report.data.rawData,
        report.data.calculations.kpis,
        { context: template.category, priority: 'business_impact' }
      );

      insights.push(
        ...trendInsights,
        ...anomalyInsights,
        ...predictionInsights,
        ...correlationInsights,
        ...recommendations
      );

      // Sort by priority and confidence
      insights.sort((a, b) => {
        const priorityWeight = { critical: 4, high: 3, medium: 2, low: 1 };
        const aPriority = priorityWeight[a.priority] * a.confidence;
        const bPriority = priorityWeight[b.priority] * b.confidence;
        return bPriority - aPriority;
      });

      logger.info('AI insights generated', {
        reportId: report.id,
        insightsCount: insights.length,
        criticalInsights: insights.filter(i => i.priority === 'critical').length
      });

      this.metrics.gauge('reporting.insights.generated', insights.length);

      return insights.slice(0, 20); // Limit to top 20 insights

    } catch (error: unknown) {
      logger.error('Failed to generate AI insights', { error, reportId: report.id });
      return [];
    }
  }

  /**
   * Export report to various formats
   */
  async exportReport(
    report: GeneratedReport,
    format: 'pdf' | 'excel' | 'csv' | 'json' | 'powerbi' | 'tableau' | 'html'
  ): Promise<ReportExport> {
    try {
      logger.debug('Exporting report', { reportId: report.id, format });

      const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
      const filename = `${report.name.replace(/[^a-zA-Z0-9]/g, '_')}_${timestamp}`;
      const exportPath = path.join(this.config.exportPath, `${filename}.${format}`);

      let exportResult: ReportExport;

      switch (format) {
        case 'pdf':
          exportResult = await this.exportToPDF(report, exportPath);
          break;
        case 'excel':
          exportResult = await this.exportToExcel(report, exportPath);
          break;
        case 'csv':
          exportResult = await this.exportToCSV(report, exportPath);
          break;
        case 'json':
          exportResult = await this.exportToJSON(report, exportPath);
          break;
        case 'powerbi':
          exportResult = await this.exportToPowerBI(report, exportPath);
          break;
        case 'tableau':
          exportResult = await this.exportToTableau(report, exportPath);
          break;
        case 'html':
          exportResult = await this.exportToHTML(report, exportPath);
          break;
        default:
          throw new Error(`Unsupported export format: ${format}`);
      }

      logger.info('Report exported successfully', {
        reportId: report.id,
        format,
        fileSize: exportResult.size,
        exportPath
      });

      this.metrics.increment(`reporting.export.${format}.success`);

      return exportResult;

    } catch (error: unknown) {
      logger.error('Failed to export report', { error, reportId: report.id, format });
      this.metrics.increment(`reporting.export.${format}.failed`);
      throw error;
    }
  }

  /**
   * Schedule automated report generation
   */
  async scheduleReport(
    templateId: string,
    schedule: ScheduleConfig,
    userId: string,
    tenantId: string
  ): Promise<string> {
    try {
      logger.info('Scheduling automated report', {
        templateId,
        frequency: schedule.frequency,
        userId,
        tenantId
      });

      const scheduleId = uuidv4();

      // Calculate next execution time
      const nextExecution = this.calculateNextExecution(schedule);

      // Create scheduled job
      const job = setTimeout(async () => {
        try {
          await this.executeScheduledReport(templateId, schedule, userId, tenantId);

          // Reschedule if recurring
          if (schedule.frequency !== 'custom') {
            await this.scheduleReport(templateId, schedule, userId, tenantId);
          }
        } catch (error: unknown) {
          logger.error('Scheduled report execution failed', {
            error,
            templateId,
            scheduleId
          });
        }
      }, nextExecution.getTime() - Date.now());

      this.scheduledJobs.set(scheduleId, job);

      // Persist schedule
      await this.persistReportSchedule({
        id: scheduleId,
        templateId,
        schedule,
        userId,
        tenantId,
        nextExecution,
        createdAt: new Date(),
        active: true
      });

      logger.info('Report scheduled successfully', {
        scheduleId,
        templateId,
        nextExecution
      });

      this.metrics.increment('reporting.schedule.created');

      return scheduleId;

    } catch (error: unknown) {
      logger.error('Failed to schedule report', { error, templateId });
      throw error;
    }
  }

  /**
   * Get advanced analytics dashboard data
   */
  async getAnalyticsDashboard(
    tenantId: string,
    dateRange: { start: Date; end: Date },
    filters: Record<string, any> = {}
  ): Promise<{
    kpis: Array<{ id: string; name: string; value: number; trend: number; format: string }>;
    charts: Array<{ id: string; type: string; data: any[] | undefined; config: any }>;
    insights: AIGeneratedInsight[];
    realTimeMetrics: Record<string, any>;
    dataFreshness: Date;
  }> {
    try {
      logger.debug('Generating analytics dashboard', { tenantId, dateRange });

      const cacheKey = `dashboard:${tenantId}:${dateRange.start.getTime()}:${dateRange.end.getTime()}`;
      const cached = await this.cache.get(cacheKey);

      if (cached) {
        return cached; // CacheManager already handles JSON parsing
      }

      // Generate KPIs
      const kpis = await this.generateDashboardKPIs(tenantId, dateRange, filters);

      // Generate charts
      const charts = await this.generateDashboardCharts(tenantId, dateRange, filters);

      // Get real-time metrics
      const realTimeMetrics = await AnalyticsService.getRealtimeMetrics();

      // Generate insights if enabled
      let insights: AIGeneratedInsight[] = [];
      if (this.config.aiInsightsEnabled) {
        insights = await this.generateDashboardInsights(tenantId, dateRange, filters);
      }

      const dashboard = {
        kpis,
        charts,
        insights,
        realTimeMetrics,
        dataFreshness: new Date()
      };

      // Cache for 5 minutes
      await this.cache.setex(cacheKey, 300, dashboard);

      this.metrics.increment('reporting.dashboard.generated');

      return dashboard;

    } catch (error: unknown) {
      logger.error('Failed to generate analytics dashboard', { error, tenantId });
      throw error;
    }
  }

  /**
   * Get report execution status and progress
   */
  async getReportStatus(reportId: string): Promise<{
    status: string;
    progress: number;
    estimatedCompletion?: Date;
    error?: string;
  }> {
    const report = this.generatedReports.get(reportId);

    if (!report) {
      throw new Error(`Report not found: ${reportId}`);
    }

    const progress = this.calculateReportProgress(report);

    return {
      status: report.status,
      progress,
      estimatedCompletion: report.status === 'generating' ?
        new Date(Date.now() + (30000 * (1 - progress))) : undefined,
      error: report.error
    };
  }

  // Private helper methods

  private async generateReportData(
    report: GeneratedReport,
    template: ReportTemplate
  ): Promise<void> {
    for (const section of template.layout.sections) {
      try {
        const sectionData = await this.generateSectionData(section, report, template);
        report.data.sections[section.id] = sectionData;

        this.emit('report:section:completed', { reportId: report.id, sectionId: section.id });
      } catch (error: unknown) {
        logger.error('Failed to generate section data', {
          error,
          reportId: report.id,
          sectionId: section.id
        });

        report.data.sections[section.id] = {
          type: section.type,
          data: null,
          visualizations: [],
          metadata: { error: (error instanceof Error ? error.message : String(error)) }
        };
      }
    }

    // Calculate summary metrics
    report.data.summary.totalRecords = Object.values(report.data.rawData)
      .reduce((sum, data) => sum + (Array.isArray(data) ? data.length : 0), 0);
  }

  private async generateSectionData(
    section: ReportSection,
    report: GeneratedReport,
    template: ReportTemplate
  ): Promise<any> {
    switch (section.type) {
      case 'header':
        return this.generateHeaderSection(section, report, template);
      case 'summary':
        return this.generateSummarySection(section, report, template);
      case 'chart':
        return this.generateChartSection(section, report, template);
      case 'table':
        return this.generateTableSection(section, report, template);
      case 'kpi':
        return this.generateKPISection(section, report, template);
      case 'insights':
        return this.generateInsightsSection(section, report, template);
      default:
        throw new Error(`Unknown section type: ${section.type}`);
    }
  }

  private async exportToPDF(report: GeneratedReport, exportPath: string): Promise<ReportExport> {
    const doc = new PDFDocument();
    const stream = createWriteStream(exportPath);
    doc.pipe(stream);

    // Add content
    doc.fontSize(20).text(report.name, 50, 50);
    doc.fontSize(12).text(`Generated: ${report.generatedAt.toISOString()}`, 50, 80);

    // Add sections
    let yPosition = 120;
    for (const [sectionId, sectionData] of Object.entries(report.data.sections)) {
      doc.fontSize(16).text(sectionId, 50, yPosition);
      yPosition += 30;

      if (sectionData.data) {
        doc.fontSize(10).text(JSON.stringify(sectionData.data, null, 2), 50, yPosition);
        yPosition += 100;
      }
    }

    doc.end();

    return new Promise((resolve, reject) => {
      stream.on('finish', async () => {
        const stats = await fs.stat(exportPath);
        resolve({
          id: uuidv4(),
          reportId: report.id,
          format: 'pdf',
          path: exportPath,
          size: stats.size,
          createdAt: new Date(),
          downloadCount: 0
        });
      });

      stream.on('error', reject);
    });
  }

  private async exportToExcel(report: GeneratedReport, exportPath: string): Promise<ReportExport> {
    const workbook = new ExcelJS.Workbook();

    // Add summary sheet
    const summarySheet = workbook.addWorksheet('Summary');
    summarySheet.columns = [
      { header: 'Metric', key: 'metric', width: 30 },
      { header: 'Value', key: 'value', width: 20 }
    ];

    summarySheet.addRow({ metric: 'Report Name', value: report.name });
    summarySheet.addRow({ metric: 'Generated At', value: report.generatedAt });
    summarySheet.addRow({ metric: 'Total Records', value: report.data.summary.totalRecords });

    // Add data sheets
    for (const [sectionId, sectionData] of Object.entries(report.data.sections)) {
      if (sectionData.data && Array.isArray(sectionData.data)) {
        const sheet = workbook.addWorksheet(sectionId);

        if (sectionData.data.length > 0) {
          const headers = Object.keys(sectionData.data[0]);
          sheet.columns = headers.map(h => ({ header: h, key: h, width: 15 }));

          sectionData.data.forEach(row => sheet.addRow(row));
        }
      }
    }

    await workbook.xlsx.writeFile(exportPath);

    const stats = await fs.stat(exportPath);

    return {
      id: uuidv4(),
      reportId: report.id,
      format: 'excel',
      path: exportPath,
      size: stats.size,
      createdAt: new Date(),
      downloadCount: 0
    };
  }

  private async exportToCSV(report: GeneratedReport, exportPath: string): Promise<ReportExport> {
    // Combine all tabular data
    const csvData: any[] | undefined = [];

    for (const [sectionId, sectionData] of Object.entries(report.data.sections)) {
      if (sectionData.data && Array.isArray(sectionData.data)) {
        csvData.push(
          ...sectionData.data.map((row: any) => ({ section: sectionId, ...row }))
        );
      }
    }

    if (csvData.length === 0) {
      throw new Error('No tabular data available for CSV export');
    }

    const headers = Object.keys(csvData[0]);
    const csvContent = [
      headers.join(','),
      ...csvData.map((row: any) =>
        headers.map(h => `"${String(row[h] || '').replace(/"/g, '""')}"`).join(',')
      )
    ].join('\n');

    await fs.writeFile(exportPath, csvContent);

    const stats = await fs.stat(exportPath);

    return {
      id: uuidv4(),
      reportId: report.id,
      format: 'csv',
      path: exportPath,
      size: stats.size,
      createdAt: new Date(),
      downloadCount: 0
    };
  }

  private async exportToJSON(report: GeneratedReport, exportPath: string): Promise<ReportExport> {
    const jsonData = {
      metadata: {
        reportId: report.id,
        name: report.name,
        generatedAt: report.generatedAt,
        generatedBy: report.generatedBy,
        tenantId: report.tenantId
      },
      data: report.data,
      insights: report.insights
    };

    await fs.writeFile(exportPath, JSON.stringify(jsonData, null, 2));

    const stats = await fs.stat(exportPath);

    return {
      id: uuidv4(),
      reportId: report.id,
      format: 'json',
      path: exportPath,
      size: stats.size,
      createdAt: new Date(),
      downloadCount: 0
    };
  }

  private async exportToPowerBI(report: GeneratedReport, exportPath: string): Promise<ReportExport> {
    // Generate PowerBI compatible dataset
    const powerBIData = {
      name: report.name,
      tables: Object.entries(report.data.sections).map(([sectionId, sectionData]) => ({
        name: sectionId,
        columns: sectionData.data ? Object.keys(sectionData.data[0] || {}).map(col => ({
          name: col,
          dataType: this.inferDataType(sectionData.data[0]?.[col])
        })) : [],
        rows: sectionData.data || []
      }))
    };

    await fs.writeFile(exportPath.replace('.powerbi', '.json'), JSON.stringify(powerBIData, null, 2));

    const stats = await fs.stat(exportPath.replace('.powerbi', '.json'));

    return {
      id: uuidv4(),
      reportId: report.id,
      format: 'powerbi',
      path: exportPath.replace('.powerbi', '.json'),
      size: stats.size,
      createdAt: new Date(),
      downloadCount: 0
    };
  }

  private async exportToTableau(report: GeneratedReport, exportPath: string): Promise<ReportExport> {
    // Generate Tableau Data Extract compatible format
    const tableauData = {
      extract: {
        datasource: {
          name: report.name,
          connection: {
            class: 'json',
            filename: exportPath
          },
          tables: Object.entries(report.data.sections).map(([sectionId, sectionData]) => ({
            name: sectionId,
            schema: sectionData.data ? Object.keys(sectionData.data[0] || {}).map(col => ({
              name: col,
              type: this.inferTableauType(sectionData.data[0]?.[col])
            })) : [],
            data: sectionData.data || []
          }))
        }
      }
    };

    await fs.writeFile(exportPath.replace('.tableau', '.json'), JSON.stringify(tableauData, null, 2));

    const stats = await fs.stat(exportPath.replace('.tableau', '.json'));

    return {
      id: uuidv4(),
      reportId: report.id,
      format: 'tableau',
      path: exportPath.replace('.tableau', '.json'),
      size: stats.size,
      createdAt: new Date(),
      downloadCount: 0
    };
  }

  private async exportToHTML(report: GeneratedReport, exportPath: string): Promise<ReportExport> {
    const html = `
      <!DOCTYPE html>
      <html>
      <head>
        <title>${report.name}</title>
        <meta charset="utf-8">
        <style>
          body { font-family: Arial, sans-serif; margin: 40px; }
          .header { border-bottom: 2px solid #333; padding-bottom: 20px; margin-bottom: 30px; }
          .section { margin-bottom: 30px; padding: 20px; border: 1px solid #ddd; }
          .insight { background: #f0f8ff; padding: 15px; margin: 10px 0; border-left: 4px solid #007acc; }
          table { width: 100%; border-collapse: collapse; }
          th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
          th { background-color: #f2f2f2; }
        </style>
      </head>
      <body>
        <div class="header">
          <h1>${report.name}</h1>
          <p>Generated: ${report.generatedAt.toISOString()}</p>
          <p>By: ${report.generatedBy}</p>
        </div>

        ${Object.entries(report.data.sections).map(([sectionId, sectionData]) => `
          <div class="section">
            <h2>${sectionId}</h2>
            ${this.renderSectionAsHTML(sectionData)}
          </div>
        `).join('')}

        ${report.insights.length > 0 ? `
          <div class="section">
            <h2>AI Insights</h2>
            ${report.insights.map(insight => `
              <div class="insight">
                <h3>${insight.title}</h3>
                <p>${insight.description}</p>
                <small>Confidence: ${(insight.confidence * 100).toFixed(1)}%</small>
              </div>
            `).join('')}
          </div>
        ` : ''}
      </body>
      </html>
    `;

    await fs.writeFile(exportPath, html);

    const stats = await fs.stat(exportPath);

    return {
      id: uuidv4(),
      reportId: report.id,
      format: 'html',
      path: exportPath,
      size: stats.size,
      createdAt: new Date(),
      downloadCount: 0
    };
  }

  private renderSectionAsHTML(sectionData: any): string {
    if (Array.isArray(sectionData.data) && sectionData.data.length > 0) {
      const headers = Object.keys(sectionData.data[0]);

      return `
        <table>
          <thead>
            <tr>${headers.map(h => `<th>${h}</th>`).join('')}</tr>
          </thead>
          <tbody>
            ${sectionData.data.map((row: any) =>
              `<tr>${headers.map((h: string) => `<td>${row[h] || ''}</td>`).join('')}</tr>`
            ).join('')}
          </tbody>
        </table>
      `;
    }

    return `<p>${JSON.stringify(sectionData.data, null, 2)}</p>`;
  }

  private inferDataType(value: any): string {
    if (typeof value === 'number') return 'number';
    if (typeof value === 'boolean') return 'boolean';
    if (value instanceof Date) return 'datetime';
    return 'string';
  }

  private inferTableauType(value: any): string {
    if (typeof value === 'number') return 'real';
    if (typeof value === 'boolean') return 'boolean';
    if (value instanceof Date) return 'datetime';
    return 'string';
  }

  private calculateQualityScore(report: GeneratedReport): number {
    let score = 100;

    // Deduct for missing sections
    const totalSections = Object.keys(report.data.sections).length;
    const completedSections = Object.values(report.data.sections).filter(s => s.data !== null).length;
    score -= (totalSections - completedSections) * 10;

    // Deduct for low data volume
    if (report.data.summary.totalRecords < 10) {
      score -= 20;
    }

    // Add points for insights
    score += Math.min(report.insights.length * 2, 10);

    return Math.max(0, Math.min(100, score));
  }

  private calculateReportProgress(report: GeneratedReport): number {
    if (report.status === 'completed') return 1;
    if (report.status === 'failed') return 0;

    const totalSections = Object.keys(report.data.sections).length || 1;
    const completedSections = Object.values(report.data.sections).filter(s => s.data !== null).length;

    return completedSections / totalSections;
  }

  private getDefaultDateRange(): { start: Date; end: Date } {
    const end = new Date();
    const start = new Date(end.getTime() - 30 * 24 * 60 * 60 * 1000); // 30 days ago
    return { start, end };
  }

  private setupEventHandlers(): void {
    this.on('report:generation:started', (report) => {
      logger.info('Report generation started', { reportId: report.id });
      this.metrics.increment('reporting.generation.started');
    });

    this.on('report:generation:completed', (report) => {
      this.metrics.gauge('reporting.generation.quality', report.metadata.qualityScore);
    });

    this.on('template:created', (template) => {
      this.metrics.gauge('reporting.templates.total', this.templates.size);
    });
  }

  /**
   * Get report templates with filtering and pagination
   */
  async getReportTemplates(options: {
    category?: string;
    tenantId?: string;
    page?: number;
    limit?: number;
  }): Promise<{ templates: ReportTemplate[]; total: number; page: number; limit: number }> {
    const templates = Array.from(this.templates.values());
    let filtered = templates;

    if (options.category) {
      filtered = filtered.filter(t => t.category === options.category);
    }

    if (options.tenantId) {
      filtered = filtered.filter(t => !t.tenantId || t.tenantId === options.tenantId);
    }

    const page = options.page || 1;
    const limit = options.limit || 20;
    const start = (page - 1) * limit;
    const paginated = filtered.slice(start, start + limit);

    return {
      templates: paginated,
      total: filtered.length,
      page,
      limit
    };
  }

  /**
   * Get a specific report by ID
   */
  async getReport(reportId: string, userId: string): Promise<GeneratedReport | null> {
    const report = this.generatedReports.get(reportId);
    if (!report) {
      return null;
    }

    // Basic access control - users can only see their own reports or admin reports
    if (report.generatedBy !== userId && !['admin', 'super_admin'].includes(userId)) {
      throw new Error('Access denied to this report');
    }

    return report;
  }

  /**
   * Get report export information
   */
  async getReportExport(reportId: string, exportId: string, userId: string): Promise<ReportExport | null> {
    const report = await this.getReport(reportId, userId);
    if (!report) {
      return null;
    }

    const exportInfo = report.exports.find(e => e.id === exportId);
    return exportInfo || null;
  }

  /**
   * Increment download count for a report export
   */
  async incrementDownloadCount(exportId: string): Promise<void> {
    for (const report of this.generatedReports.values()) {
      const exportInfo = report.exports.find(e => e.id === exportId);
      if (exportInfo) {
        exportInfo.downloadCount++;
        this.metrics.increment('reporting.export.downloaded');
        break;
      }
    }
  }

  /**
   * Get a specific insight by ID
   */
  async getInsight(insightId: string): Promise<AIGeneratedInsight | null> {
    for (const report of this.generatedReports.values()) {
      const insight = report.insights.find(i => i.id === insightId);
      if (insight) {
        return insight;
      }
    }
    return null;
  }

  /**
   * Get service health status
   */
  async getHealthStatus(): Promise<{
    status: 'healthy' | 'degraded' | 'unhealthy';
    activeGenerations: number;
    templatesLoaded: number;
    reportsGenerated: number;
    averageGenerationTime: number;
  }> {
    const templatesLoaded = this.templates.size;
    const reportsGenerated = this.generatedReports.size;
    const activeGenerations = this.activeGenerations.size;
    
    // Calculate average generation time
    const reports = Array.from(this.generatedReports.values());
    const completedReports = reports.filter(r => r.status === 'completed');
    const averageGenerationTime = completedReports.length > 0 
      ? completedReports.reduce((sum, r) => sum + r.executionTime, 0) / completedReports.length
      : 0;

    let status: 'healthy' | 'degraded' | 'unhealthy' = 'healthy';
    
    if (activeGenerations >= this.config.maxConcurrentGenerations) {
      status = 'degraded';
    }
    
    if (!this.isRunning) {
      status = 'unhealthy';
    }

    return {
      status,
      activeGenerations,
      templatesLoaded,
      reportsGenerated,
      averageGenerationTime
    };
  }

  // Additional private methods would be implemented here...
  private async loadReportTemplates(): Promise<void> { /* Implementation */ }
  private async validateReportTemplate(template: ReportTemplate): Promise<void> { /* Implementation */ }
  private async persistReportTemplate(template: ReportTemplate): Promise<void> { /* Implementation */ }
  private async persistGeneratedReport(report: GeneratedReport): Promise<void> { /* Implementation */ }
  private async persistReportSchedule(schedule: any): Promise<void> { /* Implementation */ }
  private async executeScheduledReport(templateId: string, schedule: ScheduleConfig, userId: string, tenantId: string): Promise<void> { /* Implementation */ }
  private calculateNextExecution(schedule: ScheduleConfig): Date { return new Date(Date.now() + 86400000); }
  private async sendReportNotifications(report: GeneratedReport, template: ReportTemplate): Promise<void> { /* Implementation */ }
  private startScheduledReportProcessor(): void { /* Implementation */ }
  private async generateDashboardKPIs(tenantId: string, dateRange: any, filters: any): Promise<any[]> { return []; }
  private async generateDashboardCharts(tenantId: string, dateRange: any, filters: any): Promise<any[]> { return []; }
  private async generateDashboardInsights(tenantId: string, dateRange: any, filters: any): Promise<AIGeneratedInsight[]> { return []; }
  private async generateHeaderSection(section: ReportSection, report: GeneratedReport, template: ReportTemplate): Promise<any> { return {}; }
  private async generateSummarySection(section: ReportSection, report: GeneratedReport, template: ReportTemplate): Promise<any> { return {}; }
  private async generateChartSection(section: ReportSection, report: GeneratedReport, template: ReportTemplate): Promise<any> { return {}; }
  private async generateTableSection(section: ReportSection, report: GeneratedReport, template: ReportTemplate): Promise<any> { return {}; }
  private async generateKPISection(section: ReportSection, report: GeneratedReport, template: ReportTemplate): Promise<any> { return {}; }
  private async generateInsightsSection(section: ReportSection, report: GeneratedReport, template: ReportTemplate): Promise<any> { return {}; }
}

// Additional interfaces for completeness
interface ReportStyling {
  colors: string[];
  fonts: Record<string, string>;
  layout: Record<string, any>;
}

interface BrandingConfig {
  logo?: string;
  colors: Record<string, string>;
  fonts: Record<string, string>;
}

interface DataRequirement {
  source: string;
  query: string;
  dependencies: string[];
  caching: boolean;
}

interface ReportParameter {
  name: string;
  type: string;
  required: boolean;
  defaultValue?: any;
  validation?: any;
}

interface RecipientConfig {
  email: string;
  name: string;
  role: string;
}

interface DeliveryConfig {
  method: 'email' | 'dashboard' | 'api';
  options: Record<string, any>;
}

interface ActionItem {
  id: string;
  title: string;
  description: string;
  priority: 'low' | 'medium' | 'high';
  dueDate?: Date;
}

interface ReportMetadata {
  templateVersion: number;
  dataSourcesUsed: string[];
  generationMethod: string;
  qualityScore: number;
}

interface ReportExport {
  id: string;
  reportId: string;
  format: string;
  path: string;
  size: number;
  createdAt: Date;
  downloadCount: number;
}

interface FormattingConfig {
  numberFormat?: string;
  dateFormat?: string;
  currency?: string;
}

interface FilterConfig {
  field: string;
  operator: string;
  value: any;
}

