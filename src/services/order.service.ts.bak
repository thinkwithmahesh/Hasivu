/**
 * HASIVU Platform - Order Management Service
 * Business logic layer for parent ordering system
 * Implements Epic 3: Parent Ordering System with comprehensive features
 * Generated by SuperClaude Wave 3: Epic 3 Implementation - COMPREHENSIVE
 */
import { Order, OrderItem, PaymentOrder, DeliveryVerification, Prisma } from '@prisma/client';
import { OrderRepository } from '../repositories/order.repository';
import { OrderItemRepository } from '../repositories/orderItem.repository';
import { PaymentOrderRepository } from '../repositories/paymentOrder.repository';
import { MenuItemRepository } from '../repositories/menuItem.repository';
import { UserRepository } from '../repositories/user.repository';
import { DatabaseService } from './database.service';
import { PaymentService } from './payment.service';
import { NotificationService } from './notification.service';
import { RedisService } from './redis.service';
import { logger } from '../utils/logger';
import { cache } from '../utils/cache';
import { v4 as uuidv4 } from 'uuid';

/**
 * Order status enum (local definition for missing Prisma export)
 */
export enum OrderStatus {
  PENDING = 'PENDING',
  CONFIRMED = 'CONFIRMED',
  PREPARING = 'PREPARING',
  READY = 'READY',
  OUT_FOR_DELIVERY = 'OUT_FOR_DELIVERY',
  DELIVERED = 'DELIVERED',
  CANCELLED = 'CANCELLED'
}

/**
 * Order creation input interface
 */
export interface CreateOrderInput {
  studentId: string;
  parentId: string;
  schoolId: string;
  items: Array<{
    menuItemId: string;
    quantity: number;
    specialInstructions?: string;
    customizations?: Record<string, any>;
  }>;
  deliveryDate: Date;
  deliveryType: 'pickup' | 'delivery';
  deliveryTime?: string;
  deliveryAddress?: string;
  specialInstructions?: string;
  metadata?: Record<string, any>;
}

/**
 * Cart item interface
 */
export interface CartItem {
  menuItemId: string;
  quantity: number;
  price: number;
  specialInstructions?: string;
  customizations?: Record<string, any>;
}

/**
 * Cart interface
 */
export interface Cart {
  items: CartItem[];
  totalAmount: number;
  lastUpdated: Date;
  expiresAt: Date;
}

/**
 * Add to cart input interface
 */
export interface AddToCartInput {
  studentId: string;
  menuItemId: string;
  quantity: number;
  specialInstructions?: string;
  customizations?: Record<string, any>;
}

/**
 * Payment data interface
 */
export interface ProcessPaymentInput {
  orderId: string;
  paymentMethod: 'razorpay' | 'wallet' | 'cash';
  paymentDetails?: Record<string, any>;
  amountPaid?: number;
}

/**
 * Order tracking data interface
 */
export interface OrderTrackingData extends Order {
  timeline: Array<{
    status: OrderStatus;
    timestamp: Date;
    message?: string;
  }>;
  estimatedDelivery?: Date;
  canCancel: boolean;
  deliveryDetails?: {
    verifiedAt: Date;
    location: string;
    rfidData: Record<string, any>;
  };
}

/**
 * Orders query interface
 */
export interface OrdersQuery {
  page?: number;
  limit?: number;
  status?: OrderStatus;
  dateFrom?: Date;
  dateTo?: Date;
  schoolId?: string;
  sortBy?: string;
  sortOrder?: 'asc' | 'desc';
}

/**
 * Analytics query interface
 */
export interface AnalyticsQuery {
  schoolId?: string;
  startDate: Date;
  endDate: Date;
  groupBy?: 'day' | 'week' | 'month';
}

/**
 * Order analytics interface
 */
export interface OrderAnalytics {
  totalOrders: number;
  totalRevenue: number;
  deliveryRate: number;
  cancellationRate: number;
  averageOrderValue: number;
  ordersByStatus: Record<OrderStatus, number>;
  revenueByDay: Array<{ date: string; revenue: number; orders: number }>;
}

/**
 * Popular items interface
 */
export interface PopularItemsQuery {
  schoolId?: string;
  startDate?: Date;
  endDate?: Date;
  limit?: number;
}

/**
 * Service response interface
 */
export interface ServiceResponse<T> {
  success: boolean;
  data?: T;
  error?: {
    message: string;
    code: string;
    details?: any;
  };
}

/**
 * Order Management Service class
 */
export class OrderService {
  private static readonly CACHE_TTL = 300; // 5 minutes
  private static readonly CART_EXPIRY = 3600; // 1 hour
  private static readonly MAX_QUANTITY_PER_ITEM = 10;
  private static readonly ORDER_CUTOFF_HOURS = 2; // Hours before delivery
  private static readonly VALID_STATUS_TRANSITIONS: Record<OrderStatus, OrderStatus[]> = {
    [OrderStatus.PENDING]: [OrderStatus.CONFIRMED, OrderStatus.CANCELLED],
    [OrderStatus.CONFIRMED]: [OrderStatus.PREPARING, OrderStatus.CANCELLED],
    [OrderStatus.PREPARING]: [OrderStatus.READY, OrderStatus.CANCELLED],
    [OrderStatus.READY]: [OrderStatus.OUT_FOR_DELIVERY, OrderStatus.DELIVERED, OrderStatus.CANCELLED],
    [OrderStatus.OUT_FOR_DELIVERY]: [OrderStatus.DELIVERED, OrderStatus.CANCELLED],
    [OrderStatus.DELIVERED]: [],
    [OrderStatus.CANCELLED]: []
  };

  /**
   * Create new order with comprehensive validation
   */
  public static async createOrder(input: CreateOrderInput): Promise<ServiceResponse<Order>> {
    try {
      logger.info('Creating order', { 
        studentId: input.studentId, 
        itemCount: input.items.length 
      });

      // Validate business rules
      const validation = await this.validateOrderInput(input);
      if (!validation.success) {
        return validation as unknown as ServiceResponse<Order>;
      }

      // Get menu items with availability check
      const menuItemIds = input.items.map((item: any) => item.menuItemId);
      const menuItems = await MenuItemRepository.findMany({
        filters: { 
          schoolId: input.schoolId,
          available: true 
        },
        ids: menuItemIds
      });

      if (menuItems.items.length !== menuItemIds.length) {
        const foundIds = menuItems.items.map((item: any) => item.id);
        const missingIds = menuItemIds.filter(id => !foundIds.includes(id));
        return {
          success: false,
          error: {
            message: `Menu items not available: ${missingIds.join(', ')}`,
            code: 'ITEMS_UNAVAILABLE'
          }
        };
      }

      // Check dietary restrictions and allergies
      const student = await UserRepository.findById(input.studentId);
      // Note: dietaryRestrictions and allergies fields not available in current User schema
      const dietaryRestrictions = (student as any)?.dietaryRestrictions;
      const allergies = (student as any)?.allergies;
      if (dietaryRestrictions || allergies) {
        const restrictionCheck = await this.checkDietaryRestrictions(
          menuItems.items,
          dietaryRestrictions,
          allergies
        );
        if (!restrictionCheck.success) {
          return restrictionCheck as unknown as ServiceResponse<Order>;
        }
      }

      // Calculate total amount and prepare order items
      let totalAmount = 0;
      const orderItems: Array<Prisma.OrderItemCreateManyOrderInput> = [];

      for (const inputItem of input.items) {
        const menuItem = menuItems.items.find(mi => mi.id === inputItem.menuItemId);
        if (!menuItem) continue;

        // Validate quantity
        if (inputItem.quantity > this.MAX_QUANTITY_PER_ITEM) {
          return {
            success: false,
            error: {
              message: `Quantity for ${menuItem.name} exceeds maximum allowed (${this.MAX_QUANTITY_PER_ITEM})`,
              code: 'QUANTITY_EXCEEDED'
            }
          };
        }

        const itemTotal = Number(menuItem.price) * inputItem.quantity;
        totalAmount += itemTotal;

        orderItems.push({
          id: uuidv4(),
          menuItemId: inputItem.menuItemId,
          quantity: inputItem.quantity,
          unitPrice: Number(menuItem.price),
          totalPrice: Number(menuItem.price) * inputItem.quantity,
          // Use 'notes' field as per Prisma schema, not specialInstructions
          notes: inputItem.specialInstructions || null,
          customizations: inputItem.customizations ? JSON.stringify(inputItem.customizations) : "{}"
        });
      }

      // Create order in transaction
      const order = await DatabaseService.transaction(async (tx) => {
        // Create order
        const orderData: Prisma.OrderCreateInput = {
          id: uuidv4(),
          orderNumber: `ORD-${Date.now()}`,
          // Use correct relation connects as per Prisma schema
          user: { connect: { id: input.parentId } },
          student: { connect: { id: input.studentId } },
          school: { connect: { id: input.schoolId } },
          totalAmount: totalAmount,
          status: 'pending',
          deliveryDate: input.deliveryDate,
          // Store additional details in metadata since they're not in schema
          metadata: JSON.stringify({
            deliveryType: input.deliveryType,
            deliveryTime: input.deliveryTime,
            deliveryAddress: input.deliveryAddress,
            specialInstructions: input.specialInstructions,
            ...input.metadata
          })
        };

        const createdOrder = await tx.order.create({ data: orderData });

        // Create order items
        await tx.orderItem.createMany({
          data: orderItems.map((item: any) => ({
            ...item,
            orderId: createdOrder.id
          }))
        });

        return createdOrder;
      });

      // Clear cart after successful order creation
      await this.clearCart(input.studentId);

      // Send order confirmation notification
      await NotificationService.sendOrderConfirmation({
        orderId: order.id,
        studentId: input.studentId,
        parentId: input.parentId,
        totalAmount: totalAmount,
        deliveryDate: input.deliveryDate
      }).catch(error => {
        logger.warn('Failed to send order confirmation notification', error);
      });

      logger.info('Order created successfully', { 
        orderId: order.id,
        totalAmount: totalAmount
      });

      return {
        success: true,
        data: order
      };
    } catch (error: unknown) {
      logger.error('Failed to create order', error, { input });
      
      // Handle specific database errors
      if (error instanceof Error && error.message.includes('Unique constraint')) {
        return {
          success: false,
          error: {
            message: 'Order already exists',
            code: 'DUPLICATE_ORDER'
          }
        };
      }

      return {
        success: false,
        error: {
          message: 'Failed to create order',
          code: 'ORDER_CREATION_FAILED',
          details: error
        }
      };
    }
  }

  /**
   * Add item to cart with Redis caching
   */
  public static async addToCart(input: AddToCartInput): Promise<ServiceResponse<Cart>> {
    try {
      logger.info('Adding item to cart', { 
        studentId: input.studentId,
        menuItemId: input.menuItemId
      });

      // Validate menu item
      const menuItem = await MenuItemRepository.findById(input.menuItemId);
      if (!menuItem || !menuItem.available) {
        return {
          success: false,
          error: {
            message: `Menu item not available`,
            code: 'ITEM_UNAVAILABLE'
          }
        };
      }

      // Validate quantity
      if (input.quantity > this.MAX_QUANTITY_PER_ITEM) {
        return {
          success: false,
          error: {
            message: `Quantity exceeds maximum allowed (${this.MAX_QUANTITY_PER_ITEM})`,
            code: 'QUANTITY_EXCEEDED'
          }
        };
      }

      // Get existing cart
      const cartKey = `cart:${input.studentId}`;
      const existingCartData = await RedisService.get(cartKey);
      let cart: Cart = existingCartData ? 
        JSON.parse(existingCartData) : 
        { items: [], totalAmount: 0, lastUpdated: new Date(), expiresAt: new Date() };

      // Find existing item or add new one
      const existingItemIndex = cart.items.findIndex(
        item => item.menuItemId === input.menuItemId
      );

      const itemPrice = Number(menuItem.price);
      const cartItem: CartItem = {
        menuItemId: input.menuItemId,
        quantity: input.quantity,
        price: itemPrice,
        specialInstructions: input.specialInstructions,
        customizations: input.customizations
      };

      if (existingItemIndex >= 0) {
        // Update existing item quantity
        cart.items[existingItemIndex].quantity += input.quantity;
        cart.items[existingItemIndex].specialInstructions = input.specialInstructions;
        cart.items[existingItemIndex].customizations = input.customizations;
      } else {
        // Add new item
        cart.items.push(cartItem);
      }

      // Recalculate total
      cart.totalAmount = cart.items.reduce(
        (total, item) => total + (item.price * item.quantity), 
        0
      );
      cart.lastUpdated = new Date();
      cart.expiresAt = new Date(Date.now() + this.CART_EXPIRY * 1000);

      // Save to Redis
      await RedisService.set(cartKey, JSON.stringify(cart), this.CART_EXPIRY);

      logger.info('Item added to cart successfully', { 
        studentId: input.studentId,
        cartTotal: cart.totalAmount,
        itemCount: cart.items.length
      });

      return {
        success: true,
        data: cart
      };
    } catch (error: unknown) {
      logger.error('Failed to add item to cart', error, { input });
      return {
        success: false,
        error: {
          message: 'Failed to add item to cart',
          code: 'CART_UPDATE_FAILED',
          details: error
        }
      };
    }
  }

  /**
   * Update order status with validation and history tracking
   */
  public static async updateOrderStatus(
    orderId: string, 
    newStatus: OrderStatus,
    message?: string
  ): Promise<ServiceResponse<Order>> {
    try {
      logger.info('Updating order status', { orderId, newStatus });

      // Get existing order
      const existingOrder = await OrderRepository.findById(orderId);
      if (!existingOrder) {
        return {
          success: false,
          error: {
            message: `Order with ID ${orderId} not found`,
            code: 'ORDER_NOT_FOUND'
          }
        };
      }

      // Validate status transition
      const validTransitions = this.VALID_STATUS_TRANSITIONS[existingOrder.status as OrderStatus];
      if (!validTransitions.includes(newStatus)) {
        return {
          success: false,
          error: {
            message: `Invalid status transition from ${existingOrder.status} to ${newStatus}`,
            code: 'INVALID_STATUS_TRANSITION'
          }
        };
      }

      // Update status history (field not available in current schema)
      const currentHistory = (existingOrder as any).statusHistory ? 
        JSON.parse((existingOrder as any).statusHistory as string) : [];
      
      const newHistoryEntry = {
        status: newStatus,
        timestamp: new Date(),
        message: message || `Order status updated to ${newStatus}`
      };
      
      currentHistory.push(newHistoryEntry);

      // Update order
      const updatedOrder = await OrderRepository.update(orderId, {
        status: newStatus,
        // Note: statusHistory field not available in current Order schema
        updatedAt: new Date()
      });

      // Send status update notification
      await NotificationService.sendOrderStatusUpdate({
        orderId: orderId,
        studentId: existingOrder.studentId,
        // Note: parentId field not available in current Order schema
        parentId: (existingOrder as any).parentId || existingOrder.userId,
        newStatus: newStatus,
        message: message
      }).catch(error => {
        logger.warn('Failed to send status update notification', error);
      });

      logger.info('Order status updated successfully', { orderId, newStatus });

      return {
        success: true,
        data: updatedOrder
      };
    } catch (error: unknown) {
      logger.error('Failed to update order status', error, { orderId, newStatus });
      return {
        success: false,
        error: {
          message: 'Failed to update order status',
          code: 'STATUS_UPDATE_FAILED',
          details: error
        }
      };
    }
  }

  /**
   * Process order payment with comprehensive integration
   */
  public static async processOrderPayment(
    input: ProcessPaymentInput
  ): Promise<ServiceResponse<any>> {
    try {
      logger.info('Processing order payment', { 
        orderId: input.orderId,
        paymentMethod: input.paymentMethod
      });

      // Get order
      const order = await OrderRepository.findById(input.orderId);
      if (!order) {
        return {
          success: false,
          error: {
            message: `Order with ID ${input.orderId} not found`,
            code: 'ORDER_NOT_FOUND'
          }
        };
      }

      // Create payment order record
      const paymentOrderData: Prisma.PaymentOrderCreateInput = {
        id: uuidv4(),
        razorpayOrderId: `razorpay_${uuidv4()}`, // Generate temporary ID - will be updated by payment gateway
        userId: order.userId,
        orderId: input.orderId,
        amount: Math.round(order.totalAmount * 100), // Razorpay expects amount in paise
        currency: 'INR',
        status: 'pending',
        expiresAt: new Date(Date.now() + 24 * 60 * 60 * 1000), // 24 hours from now
        metadata: JSON.stringify(input.paymentDetails || {})
      };

      const paymentOrder = await PaymentOrderRepository.create(paymentOrderData);

      // Process payment based on method
      let paymentResult;
      
      if (input.paymentMethod === 'cash') {
        // Cash payment - mark as completed
        paymentResult = {
          success: true,
          data: {
            paymentId: paymentOrder.id,
            status: 'captured',
            paymentMethod: 'cash'
          }
        };
      } else {
        // Process through payment service
        paymentResult = await PaymentService.processPayment({
          orderId: input.orderId,
          amount: Number(order.totalAmount),
          currency: 'INR',
          paymentMethodId: input.paymentMethod
        });
      }

      if (!paymentResult.success) {
        // Update payment order status
        await PaymentOrderRepository.update(paymentOrder.id, {
          status: 'failed',
          metadata: JSON.stringify({
            error: paymentResult.error?.message,
            failedAt: new Date().toISOString()
          })
        });

        return {
          success: false,
          error: {
            message: paymentResult.error?.message || 'Payment failed',
            code: 'PAYMENT_FAILED',
            details: paymentResult.error
          }
        };
      }

      // Update payment order status
      await PaymentOrderRepository.update(paymentOrder.id, {
        status: paymentResult.data.status,
        metadata: JSON.stringify({
          paymentId: paymentResult.data.paymentId,
          paidAt: new Date().toISOString(),
          paymentDetails: paymentResult.data
        })
      });

      // Update order status if payment successful
      if (paymentResult.data.status === 'captured') {
        await this.updateOrderStatus(input.orderId, OrderStatus.CONFIRMED, 'Payment confirmed');
      }

      logger.info('Order payment processed successfully', { 
        orderId: input.orderId,
        paymentStatus: paymentResult.data.status
      });

      return {
        success: true,
        data: {
          paymentId: paymentResult.data.paymentId,
          paymentStatus: paymentResult.data.status,
          paymentMethod: input.paymentMethod
        }
      };
    } catch (error: unknown) {
      logger.error('Failed to process order payment', error, { input });
      return {
        success: false,
        error: {
          message: 'Failed to process payment',
          code: 'PAYMENT_PROCESSING_FAILED',
          details: error
        }
      };
    }
  }

  /**
   * Get order tracking information with timeline
   */
  public static async getOrderTracking(orderId: string): Promise<ServiceResponse<OrderTrackingData>> {
    try {
      const cacheKey = `order_tracking:${orderId}`;
      const cached = await cache.get(cacheKey);
      if (cached) {
        return { success: true, data: JSON.parse(cached) };
      }

      const order = await OrderRepository.findByIdWithIncludes(orderId, {
        orderItems: {
          include: {
            menuItem: true
          }
        },
        deliveryVerifications: {
          include: {
            card: true,
            reader: true
          }
        }
      });

      if (!order) {
        return {
          success: false,
          error: {
            message: `Order with ID ${orderId} not found`,
            code: 'ORDER_NOT_FOUND'
          }
        };
      }

      // Parse status history
      // statusHistory not available in current Order schema, use empty timeline
      const timeline: any[] = [];

      // Calculate estimated delivery
      let estimatedDelivery: Date | undefined;
      if (order.status !== OrderStatus.DELIVERED && order.status !== OrderStatus.CANCELLED) {
        estimatedDelivery = new Date(order.deliveryDate);
        estimatedDelivery.setHours(12, 0, 0, 0); // Default to noon
      }

      // Check if order can be cancelled
      const canCancel = ['PENDING', 'CONFIRMED'].includes(order.status);

      // Get delivery details if available
      let deliveryDetails;
      // Cast order to include deliveryVerifications since it's included in query
      const orderWithIncludes = order as typeof order & { 
        deliveryVerifications?: Array<any>
      };
      
      if (orderWithIncludes.deliveryVerifications && orderWithIncludes.deliveryVerifications.length > 0) {
        const verification = orderWithIncludes.deliveryVerifications[0];
        deliveryDetails = {
          verifiedAt: verification.verifiedAt,
          location: verification.rfidReader?.location || 'Unknown',
          rfidData: {
            cardNumber: verification.rfidCard?.cardNumber,
            readerLocation: verification.rfidReader?.location
          }
        };
      }

      const trackingData: OrderTrackingData = {
        ...order,
        timeline,
        estimatedDelivery,
        canCancel,
        deliveryDetails
      };

      await cache.setex(cacheKey, this.CACHE_TTL, JSON.stringify(trackingData));

      return {
        success: true,
        data: trackingData
      };
    } catch (error: unknown) {
      logger.error('Failed to get order tracking', error, { orderId });
      return {
        success: false,
        error: {
          message: 'Failed to get order tracking',
          code: 'TRACKING_FAILED',
          details: error
        }
      };
    }
  }

  /**
   * Get orders by student with filtering and pagination
   */
  public static async getOrdersByStudent(
    studentId: string,
    query: OrdersQuery = {}
  ): Promise<ServiceResponse<{ orders: Order[]; pagination: any }>> {
    try {
      const page = query.page || 1;
      const limit = Math.min(query.limit || 10, 50);
      const skip = (page - 1) * limit;

      const filters: any = { studentId };
      if (query.status) filters.status = query.status;
      if (query.dateFrom || query.dateTo) {
        filters.createdAt = {};
        if (query.dateFrom) filters.createdAt.gte = query.dateFrom;
        if (query.dateTo) filters.createdAt.lte = query.dateTo;
      }
      if (query.schoolId) filters.schoolId = query.schoolId;

      const result = await OrderRepository.findMany({
        filters,
        skip,
        take: limit,
        sortBy: query.sortBy || 'createdAt',
        sortOrder: query.sortOrder || 'desc',
        include: {
          orderItems: {
            include: {
              menuItem: true
            }
          }
        }
      });

      const total = await OrderRepository.count(filters);
      const totalPages = Math.ceil(total / limit);

      return {
        success: true,
        data: {
          orders: result.items,
          pagination: {
            page,
            limit,
            total,
            totalPages
          }
        }
      };
    } catch (error: unknown) {
      logger.error('Failed to get orders by student', error, { studentId, query });
      return {
        success: false,
        error: {
          message: 'Failed to get orders',
          code: 'ORDERS_FETCH_FAILED',
          details: error
        }
      };
    }
  }


  /**
   * Get order analytics for reporting
   */
  public static async getOrderAnalytics(
    query: AnalyticsQuery
  ): Promise<ServiceResponse<OrderAnalytics>> {
    try {
      const filters: any = {
        createdAt: {
          gte: query.startDate,
          lte: query.endDate
        }
      };
      if (query.schoolId) filters.schoolId = query.schoolId;

      // Get aggregated data
      const analytics = await OrderRepository.getAnalytics(filters, query.groupBy);

      const result: OrderAnalytics = {
        totalOrders: analytics.totalOrders,
        totalRevenue: analytics.totalRevenue,
        deliveryRate: (analytics.deliveredOrders / analytics.totalOrders) * 100,
        cancellationRate: (analytics.cancelledOrders / analytics.totalOrders) * 100,
        averageOrderValue: analytics.totalRevenue / analytics.totalOrders,
        ordersByStatus: {
          [OrderStatus.PENDING]: analytics.ordersByStatus?.[OrderStatus.PENDING] || 0,
          [OrderStatus.CONFIRMED]: analytics.ordersByStatus?.[OrderStatus.CONFIRMED] || 0,
          [OrderStatus.PREPARING]: analytics.ordersByStatus?.[OrderStatus.PREPARING] || 0,
          [OrderStatus.READY]: analytics.ordersByStatus?.[OrderStatus.READY] || 0,
          [OrderStatus.OUT_FOR_DELIVERY]: analytics.ordersByStatus?.[OrderStatus.OUT_FOR_DELIVERY] || 0,
          [OrderStatus.DELIVERED]: analytics.ordersByStatus?.[OrderStatus.DELIVERED] || 0,
          [OrderStatus.CANCELLED]: analytics.ordersByStatus?.[OrderStatus.CANCELLED] || 0
        },
        revenueByDay: analytics.revenueByDay
      };

      return {
        success: true,
        data: result
      };
    } catch (error: unknown) {
      logger.error('Failed to get order analytics', error, { query });
      return {
        success: false,
        error: {
          message: 'Failed to get analytics',
          code: 'ANALYTICS_FAILED',
          details: error
        }
      };
    }
  }

  /**
   * Get popular menu items based on order data
   */
  public static async getPopularItems(
    query: PopularItemsQuery
  ): Promise<ServiceResponse<any[]>> {
    try {
      const filters: any = {};
      if (query.schoolId) filters.schoolId = query.schoolId;
      if (query.startDate || query.endDate) {
        filters.createdAt = {};
        if (query.startDate) filters.createdAt.gte = query.startDate;
        if (query.endDate) filters.createdAt.lte = query.endDate;
      }

      const popularItems = await OrderItemRepository.getPopularItems(
        filters,
        query.limit || 10
      );

      return {
        success: true,
        data: popularItems
      };
    } catch (error: unknown) {
      logger.error('Failed to get popular items', error, { query });
      return {
        success: false,
        error: {
          message: 'Failed to get popular items',
          code: 'POPULAR_ITEMS_FAILED',
          details: error
        }
      };
    }
  }

  /**
   * Get orders for parent and their children
   */
  public static async getParentChildren(parentId: string): Promise<ServiceResponse<Order[]>> {
    try {
      // Get all students associated with this parent
      const students = await UserRepository.findMany({
        filters: { parentId },
        select: ['id']
      });

      const studentIds = students.items.map(s => s.id);

      if (studentIds.length === 0) {
        return {
          success: true,
          data: []
        };
      }

      // Get orders for all children
      const orders = await OrderRepository.findMany({
        filters: {
          studentId: { in: studentIds }
        },
        include: {
          orderItems: {
            include: {
              menuItem: true
            }
          },
          student: true
        },
        sortBy: 'createdAt',
        sortOrder: 'desc'
      });

      return {
        success: true,
        data: orders.items
      };
    } catch (error: unknown) {
      logger.error('Failed to get parent children orders', error, { parentId });
      return {
        success: false,
        error: {
          message: 'Failed to get orders',
          code: 'ORDERS_FETCH_FAILED',
          details: error
        }
      };
    }
  }

  /**
   * Find multiple orders with filters
   */
  public static async findMany(filters: any): Promise<ServiceResponse<Order[]>> {
    try {
      const result = await OrderRepository.findMany({
        filters,
        include: {
          orderItems: {
            include: {
              menuItem: true
            }
          }
        }
      });

      return {
        success: true,
        data: result.items
      };
    } catch (error: unknown) {
      logger.error('Failed to find orders', error, { filters });
      return {
        success: false,
        error: {
          message: 'Failed to find orders',
          code: 'ORDERS_FIND_FAILED',
          details: error
        }
      };
    }
  }

  /**
   * Get tracking information for an order
   */
  public static async getTrackingInfo(orderId: string): Promise<ServiceResponse<any>> {
    try {
      const tracking = await this.getOrderTracking(orderId);
      return tracking;
    } catch (error: unknown) {
      logger.error('Failed to get tracking info', error, { orderId });
      return {
        success: false,
        error: {
          message: 'Failed to get tracking information',
          code: 'TRACKING_INFO_FAILED',
          details: error
        }
      };
    }
  }

  /**
   * Estimate delivery time for an order
   */
  public static async estimateDeliveryTime(orderId: string): Promise<ServiceResponse<{ estimatedTime: Date; confidence: number }>> {
    try {
      const order = await OrderRepository.findById(orderId);
      if (!order) {
        return {
          success: false,
          error: {
            message: 'Order not found',
            code: 'ORDER_NOT_FOUND'
          }
        };
      }

      // Simple estimation based on order status and delivery date
      let estimatedTime = new Date(order.deliveryDate);
      let confidence = 0.8; // 80% confidence

      switch (order.status) {
        case OrderStatus.PENDING:
          estimatedTime.setHours(12, 0, 0, 0); // Default to noon
          confidence = 0.6;
          break;
        case OrderStatus.CONFIRMED:
          estimatedTime.setHours(12, 30, 0, 0); // 12:30 PM
          confidence = 0.7;
          break;
        case OrderStatus.PREPARING:
          estimatedTime.setHours(13, 0, 0, 0); // 1:00 PM
          confidence = 0.8;
          break;
        case OrderStatus.READY:
          estimatedTime.setHours(13, 30, 0, 0); // 1:30 PM
          confidence = 0.9;
          break;
        case OrderStatus.OUT_FOR_DELIVERY:
          estimatedTime.setHours(14, 0, 0, 0); // 2:00 PM
          confidence = 0.95;
          break;
        default:
          confidence = 1.0; // Already delivered
      }

      return {
        success: true,
        data: {
          estimatedTime,
          confidence
        }
      };
    } catch (error: unknown) {
      logger.error('Failed to estimate delivery time', error, { orderId });
      return {
        success: false,
        error: {
          message: 'Failed to estimate delivery time',
          code: 'DELIVERY_ESTIMATE_FAILED',
          details: error
        }
      };
    }
  }

  /**
   * Get status counts for orders
   */
  public static async getStatusCounts(filters?: any): Promise<ServiceResponse<Record<OrderStatus, number>>> {
    try {
      const counts = await OrderRepository.getStatusCounts(filters);

      // Ensure all statuses are present
      const result: Record<OrderStatus, number> = {
        [OrderStatus.PENDING]: 0,
        [OrderStatus.CONFIRMED]: 0,
        [OrderStatus.PREPARING]: 0,
        [OrderStatus.READY]: 0,
        [OrderStatus.OUT_FOR_DELIVERY]: 0,
        [OrderStatus.DELIVERED]: 0,
        [OrderStatus.CANCELLED]: 0
      };

      // Merge with actual counts
      Object.assign(result, counts);

      return {
        success: true,
        data: result
      };
    } catch (error: unknown) {
      logger.error('Failed to get status counts', error, { filters });
      return {
        success: false,
        error: {
          message: 'Failed to get status counts',
          code: 'STATUS_COUNTS_FAILED',
          details: error
        }
      };
    }
  }

  /**
   * Find order by ID
   */
  public static async findById(orderId: string): Promise<ServiceResponse<Order | null>> {
    try {
      const order = await OrderRepository.findById(orderId);
      return {
        success: true,
        data: order
      };
    } catch (error: unknown) {
      logger.error('Failed to find order by ID', error, { orderId });
      return {
        success: false,
        error: {
          message: 'Failed to find order',
          code: 'ORDER_FIND_FAILED',
          details: error
        }
      };
    }
  }

  /**
   * Clear cart for student
   */
  public static async clearCart(studentId: string): Promise<void> {
    try {
      const cartKey = `cart:${studentId}`;
      await RedisService.del(cartKey);
      logger.info('Cart cleared', { studentId });
    } catch (error: unknown) {
      logger.warn('Failed to clear cart', { studentId, error });
    }
  }

  /**
   * Get cart for student
   */
  public static async getCart(studentId: string): Promise<ServiceResponse<Cart | null>> {
    try {
      const cartKey = `cart:${studentId}`;
      const cartData = await RedisService.get(cartKey);
      
      if (!cartData) {
        return {
          success: true,
          data: null
        };
      }

      const cart: Cart = JSON.parse(cartData);
      
      // Check if cart has expired
      if (new Date() > new Date(cart.expiresAt)) {
        await RedisService.del(cartKey);
        return {
          success: true,
          data: null
        };
      }

      return {
        success: true,
        data: cart
      };
    } catch (error: unknown) {
      logger.error('Failed to get cart', error, { studentId });
      return {
        success: false,
        error: {
          message: 'Failed to get cart',
          code: 'CART_FETCH_FAILED',
          details: error
        }
      };
    }
  }

  /**
   * Check if user can access a specific order
   */
  public static async canUserAccessOrder(userId: string, order: Order): Promise<boolean> {
    try {
      // Check if user is the parent of the student who placed the order
      if (order.userId === userId) {
        return true;
      }

      // Check if user is a parent of the student
      const student = await UserRepository.findById(order.studentId);
      if (student && (student as any).parentId === userId) {
        return true;
      }

      // Check if user is a school admin for the school
      const user = await UserRepository.findById(userId);
      if (user && ['admin', 'school_admin'].includes((user as any).role)) {
        return order.schoolId === (user as any).schoolId;
      }

      return false;
    } catch (error: unknown) {
      logger.error('Error checking order access', error, { userId, orderId: order.id });
      return false;
    }
  }

  /**
   * Get detailed tracking information for an order
   */
  public static async getDetailedTrackingInfo(orderId: string): Promise<ServiceResponse<any>> {
    try {
      const tracking = await this.getOrderTracking(orderId);
      if (!tracking.success) {
        return tracking;
      }

      // Add additional detailed information
      const order = await OrderRepository.findById(orderId);
      if (!order) {
        return {
          success: false,
          error: { message: 'Order not found', code: 'ORDER_NOT_FOUND' }
        };
      }

      const detailedTracking = {
        ...tracking.data,
        deliveryDetails: order.deliveryDate ? {
          scheduledDate: order.deliveryDate,
          estimatedTime: '12:00-14:00', // Default time slot
          deliveryAddress: (order as any).deliveryAddress || 'School premises'
        } : null,
        preparationDetails: order.status === 'preparing' ? {
          startedAt: new Date(), // Would need to track actual start time
          estimatedCompletion: new Date(Date.now() + 30 * 60 * 1000), // 30 minutes from now
          progress: 50 // Estimated progress
        } : null
      };

      return {
        success: true,
        data: detailedTracking
      };
    } catch (error: unknown) {
      logger.error('Error getting detailed tracking info', error, { orderId });
      return {
        success: false,
        error: {
          message: 'Failed to get detailed tracking information',
          code: 'TRACKING_DETAILS_FAILED',
          details: error
        }
      };
    }
  }

  /**
   * Get delivery status for an order
   */
  public static async getDeliveryStatus(orderId: string): Promise<ServiceResponse<any>> {
    try {
      const order = await OrderRepository.findById(orderId);
      if (!order) {
        return {
          success: false,
          error: { message: 'Order not found', code: 'ORDER_NOT_FOUND' }
        };
      }

      const deliveryStatus = {
        orderId,
        status: order.status,
        deliveryDate: order.deliveryDate,
        isDelivered: ['delivered'].includes(order.status),
        isOutForDelivery: order.status === 'out_for_delivery',
        estimatedDelivery: order.status === 'out_for_delivery' ?
          new Date(Date.now() + 30 * 60 * 1000) : null, // 30 minutes from now
        deliveryNotes: (order as any).deliveryNotes || null
      };

      return {
        success: true,
        data: deliveryStatus
      };
    } catch (error: unknown) {
      logger.error('Error getting delivery status', error, { orderId });
      return {
        success: false,
        error: {
          message: 'Failed to get delivery status',
          code: 'DELIVERY_STATUS_FAILED',
          details: error
        }
      };
    }
  }

  /**
   * Get preparation information for an order
   */
  public static async getPreparationInfo(orderId: string): Promise<ServiceResponse<any>> {
    try {
      const order = await OrderRepository.findById(orderId);
      if (!order) {
        return {
          success: false,
          error: { message: 'Order not found', code: 'ORDER_NOT_FOUND' }
        };
      }

      const preparationInfo = {
        orderId,
        status: order.status,
        isBeingPrepared: order.status === 'preparing',
        preparationProgress: order.status === 'preparing' ? 75 : 100,
        estimatedCompletion: order.status === 'preparing' ?
          new Date(Date.now() + 15 * 60 * 1000) : null, // 15 minutes from now
        kitchenNotes: (order as any).kitchenNotes || null
      };

      return {
        success: true,
        data: preparationInfo
      };
    } catch (error: unknown) {
      logger.error('Error getting preparation info', error, { orderId });
      return {
        success: false,
        error: {
          message: 'Failed to get preparation information',
          code: 'PREPARATION_INFO_FAILED',
          details: error
        }
      };
    }
  }

  /**
   * Check if an order can be cancelled
   */
  public static async canCancelOrder(orderId: string, userId: string): Promise<{ allowed: boolean; reason?: string }> {
    try {
      const order = await OrderRepository.findById(orderId);
      if (!order) {
        return { allowed: false, reason: 'Order not found' };
      }

      // Check user access
      const canAccess = await this.canUserAccessOrder(userId, order);
      if (!canAccess) {
        return { allowed: false, reason: 'Access denied' };
      }

      // Check if order is in a cancellable state
      const cancellableStatuses = ['pending', 'confirmed', 'preparing'];
      if (!cancellableStatuses.includes(order.status)) {
        return { allowed: false, reason: `Order status '${order.status}' cannot be cancelled` };
      }

      // Check time constraints (e.g., can't cancel within 2 hours of delivery)
      if (order.deliveryDate) {
        const cutoffTime = new Date(order.deliveryDate.getTime() - this.ORDER_CUTOFF_HOURS * 60 * 60 * 1000);
        if (new Date() > cutoffTime) {
          return { allowed: false, reason: 'Order cutoff time has passed' };
        }
      }

      return { allowed: true };
    } catch (error: unknown) {
      logger.error('Error checking if order can be cancelled', error, { orderId, userId });
      return { allowed: false, reason: 'Internal error' };
    }
  }

  /**
   * Check if an order can be modified
   */
  public static async canModifyOrder(orderId: string, userId: string): Promise<boolean> {
    try {
      const order = await OrderRepository.findById(orderId);
      if (!order) {
        return false;
      }

      // Check user access
      const canAccess = await this.canUserAccessOrder(userId, order);
      if (!canAccess) {
        return false;
      }

      // Check if order is in a modifiable state
      const modifiableStatuses = ['pending', 'confirmed'];
      if (!modifiableStatuses.includes(order.status)) {
        return false;
      }

      // Check time constraints
      if (order.deliveryDate) {
        const cutoffTime = new Date(order.deliveryDate.getTime() - this.ORDER_CUTOFF_HOURS * 60 * 60 * 1000);
        if (new Date() > cutoffTime) {
          return false;
        }
      }

      return true;
    } catch (error: unknown) {
      logger.error('Error checking if order can be modified', error, { orderId, userId });
      return false;
    }
  }

  /**
   * Check if an order is eligible for refund
   */
  public static async isRefundEligible(orderId: string): Promise<boolean> {
    try {
      const order = await OrderRepository.findById(orderId);
      if (!order) {
        return false;
      }

      // Check if order was paid and is cancelled
      if (order.status !== 'cancelled') {
        return false;
      }

      // Check if payment was made (would need payment status check)
      // For now, assume cancelled orders are refund eligible
      return true;
    } catch (error: unknown) {
      logger.error('Error checking refund eligibility', error, { orderId });
      return false;
    }
  }

  /**
   * Check if a parent can order for a specific student
   */
  public static async canParentOrderForStudent(parentId: string, studentId: string): Promise<boolean> {
    try {
      const student = await UserRepository.findById(studentId);
      if (!student) {
        return false;
      }

      // Check if the student has this user as parent
      return (student as any).parentId === parentId;
    } catch (error: unknown) {
      logger.error('Error checking parent ordering permission', error, { parentId, studentId });
      return false;
    }
  }

  /**
   * Validate delivery slot for an order
   */
  public static async validateDeliverySlot(schoolId: string, deliveryDate: Date, timeSlot: string): Promise<{ isValid: boolean; reason?: string; estimatedDelivery?: Date }> {
    try {
      // Check if delivery date is in the future
      if (deliveryDate < new Date()) {
        return {
          isValid: false,
          reason: 'Delivery date cannot be in the past'
        };
      }

      // Check cutoff time
      const cutoffTime = new Date(deliveryDate.getTime() - this.ORDER_CUTOFF_HOURS * 60 * 60 * 1000);
      if (new Date() > cutoffTime) {
        return {
          isValid: false,
          reason: 'Order cutoff time has passed for the selected delivery date'
        };
      }

      // Validate time slot
      const validTimeSlots = ['breakfast', 'lunch', 'dinner', 'snack'];
      if (!validTimeSlots.includes(timeSlot)) {
        return {
          isValid: false,
          reason: 'Invalid delivery time slot'
        };
      }

      // Calculate estimated delivery time based on time slot
      let estimatedDelivery: Date;
      switch (timeSlot) {
        case 'breakfast':
          estimatedDelivery = new Date(deliveryDate.getTime() + 8 * 60 * 60 * 1000); // 8 AM
          break;
        case 'lunch':
          estimatedDelivery = new Date(deliveryDate.getTime() + 12 * 60 * 60 * 1000); // 12 PM
          break;
        case 'dinner':
          estimatedDelivery = new Date(deliveryDate.getTime() + 18 * 60 * 60 * 1000); // 6 PM
          break;
        case 'snack':
          estimatedDelivery = new Date(deliveryDate.getTime() + 15 * 60 * 60 * 1000); // 3 PM
          break;
        default:
          estimatedDelivery = new Date(deliveryDate.getTime() + 12 * 60 * 60 * 1000);
      }

      return {
        isValid: true,
        estimatedDelivery
      };
    } catch (error: unknown) {
      logger.error('Error validating delivery slot', error, { schoolId, deliveryDate, timeSlot });
      return {
        isValid: false,
        reason: 'Failed to validate delivery slot'
      };
    }
  }

  /**
   * Validate order items
   */
  public static async validateOrderItems(items: any[], context: { schoolId: string; deliveryDate: Date; deliveryTimeSlot: string }): Promise<{ isValid: boolean; errors?: string[] }> {
    try {
      if (!items || items.length === 0) {
        return {
          isValid: false,
          errors: ['Order must contain at least one item']
        };
      }

      if (items.length > 20) {
        return {
          isValid: false,
          errors: ['Maximum 20 different items per order']
        };
      }

      const errors: string[] = [];

      // Validate each item
      const menuItemIds = items.map((item: any) => item.menuItemId);
      const menuItems = await MenuItemRepository.findMany({
        filters: { schoolId: context.schoolId, available: true },
        ids: menuItemIds
      });

      if (menuItems.items.length !== menuItemIds.length) {
        const foundIds = menuItems.items.map((item: any) => item.id);
        const missingIds = menuItemIds.filter(id => !foundIds.includes(id));
        errors.push(`Menu items not available: ${missingIds.join(', ')}`);
      }

      // Validate quantities and customizations
      for (const item of items) {
        if (item.quantity < 1 || item.quantity > this.MAX_QUANTITY_PER_ITEM) {
          errors.push(`Invalid quantity for item ${item.menuItemId}: must be between 1 and ${this.MAX_QUANTITY_PER_ITEM}`);
        }
      }

      return {
        isValid: errors.length === 0,
        errors: errors.length > 0 ? errors : undefined
      };
    } catch (error: unknown) {
      logger.error('Error validating order items', error, { schoolId: context.schoolId, itemCount: items?.length });
      return {
        isValid: false,
        errors: ['Failed to validate order items']
      };
    }
  }

  /**
   * Calculate order pricing
   */
  public static async calculateOrderPricing(items: any[], context: { discountCode?: string; studentId: string; schoolId: string }): Promise<{ subtotal: number; taxAmount: number; total: number; currency: string; itemizedPricing: any[] }> {
    try {
      const menuItemIds = items.map((item: any) => item.menuItemId);
      const menuItems = await MenuItemRepository.findMany({
        filters: { schoolId: context.schoolId },
        ids: menuItemIds
      });

      let subtotal = 0;
      const itemizedPricing = [];

      for (const item of items) {
        const menuItem = menuItems.items.find(mi => mi.id === item.menuItemId);
        if (!menuItem) continue;

        const unitPrice = Number(menuItem.price);
        const itemTotal = unitPrice * item.quantity;
        subtotal += itemTotal;

        itemizedPricing.push({
          menuItemId: item.menuItemId,
          name: menuItem.name,
          quantity: item.quantity,
          unitPrice,
          totalPrice: itemTotal
        });
      }

      // Calculate tax (assume 5% for now)
      const taxAmount = subtotal * 0.05;
      const total = subtotal + taxAmount;

      return {
        subtotal,
        taxAmount,
        total,
        currency: 'INR',
        itemizedPricing
      };
    } catch (error: unknown) {
      logger.error('Error calculating order pricing', error, { schoolId: context.schoolId, itemCount: items?.length });
      throw new Error('Failed to calculate order pricing');
    }
  }

  /**
   * Check if a user can update an order
   */
  public static async canUserUpdateOrder(userId: string, order: Order): Promise<boolean> {
    try {
      // Check user access
      const canAccess = await this.canUserAccessOrder(userId, order);
      if (!canAccess) {
        return false;
      }

      // Check if order is in an updatable state
      const updatableStatuses = ['pending', 'confirmed'];
      if (!updatableStatuses.includes(order.status)) {
        return false;
      }

      return true;
    } catch (error: unknown) {
      logger.error('Error checking if user can update order', error, { userId, orderId: order.id });
      return false;
    }
  }

  /**
   * Check if an order status can be changed
   */
  public static async canChangeStatus(currentStatus: string, newStatus: string, userRole: string): Promise<{ allowed: boolean; reason?: string }> {
    try {
      // Define valid status transitions
      const validTransitions: Record<string, string[]> = {
        'pending': ['confirmed', 'cancelled'],
        'confirmed': ['preparing', 'cancelled'],
        'preparing': ['ready', 'cancelled'],
        'ready': ['out_for_delivery', 'cancelled'],
        'out_for_delivery': ['delivered', 'cancelled'],
        'delivered': [], // Final state
        'cancelled': [], // Final state
        'refunded': [] // Final state
      };

      const allowedStatuses = validTransitions[currentStatus] || [];

      if (!allowedStatuses.includes(newStatus)) {
        return {
          allowed: false,
          reason: `Invalid status transition from '${currentStatus}' to '${newStatus}'`
        };
      }

      // Role-based restrictions
      if (userRole === 'student' && ['preparing', 'ready', 'out_for_delivery', 'delivered'].includes(newStatus)) {
        return {
          allowed: false,
          reason: 'Students cannot update order status to preparation or delivery states'
        };
      }

      return { allowed: true };
    } catch (error: unknown) {
      logger.error('Error checking status change permission', error, { currentStatus, newStatus, userRole });
      return { allowed: false, reason: 'Internal error' };
    }
  }

  /**
   * Validate item modification for an order
   */
  public static async validateItemModification(order: Order, newItems: any[]): Promise<{ isValid: boolean; errors?: string[] }> {
    try {
      // Check if order allows modifications
      if (!['pending', 'confirmed'].includes(order.status)) {
        return {
          isValid: false,
          errors: ['Order items cannot be modified at this stage']
        };
      }

      // Validate new items
      const validation = await this.validateOrderItems(newItems, {
        schoolId: order.schoolId,
        deliveryDate: order.deliveryDate,
        deliveryTimeSlot: (order as any).deliveryTimeSlot || 'lunch'
      });

      return validation;
    } catch (error: unknown) {
      logger.error('Error validating item modification', error, { orderId: order.id });
      return {
        isValid: false,
        errors: ['Failed to validate item modification']
      };
    }
  }

  /**
   * Update an order
   */
  public static async update(id: string, updateData: any): Promise<ServiceResponse<Order>> {
    try {
      const updatedOrder = await OrderRepository.update(id, updateData);

      return {
        success: true,
        data: updatedOrder
      };
    } catch (error: unknown) {
      logger.error('Error updating order', error, { orderId: id, updateData });
      return {
        success: false,
        error: {
          message: 'Failed to update order',
          code: 'ORDER_UPDATE_FAILED',
          details: error
        }
      };
    }
  }

  /**
   * Handle status update for an order
   */
  public static async handleStatusUpdate(orderId: string, newStatus: string, context: any): Promise<void> {
    try {
      // Log status change
      logger.info('Order status updated', {
        orderId,
        newStatus,
        previousStatus: context.previousStatus,
        updatedBy: context.updatedBy,
        reason: context.reason
      });

      // Additional status-specific logic can be added here
      // For example, sending notifications, updating inventory, etc.

    } catch (error: unknown) {
      logger.error('Error handling status update', error, { orderId, newStatus, context });
      // Don't throw - this is a side effect
    }
  }

  /**
   * Cancel an order
   */
  public static async cancelOrder(orderId: string, context: { reason: string; refundRequested: boolean; cancelledBy: string }): Promise<ServiceResponse<{ refundEligible: boolean; refundAmount?: number }>> {
    try {
      // Update order status
      const updateResult = await this.updateStatus(orderId, 'cancelled', {
        cancellationReason: context.reason,
        updatedBy: context.cancelledBy
      });

      if (!updateResult.success) {
        return updateResult as any;
      }

      // Check refund eligibility
      const refundEligible = await this.isRefundEligible(orderId);
      let refundAmount = 0;

      if (refundEligible) {
        // Calculate refund amount (simplified - full refund for cancelled orders)
        const order = await OrderRepository.findById(orderId);
        if (order) {
          refundAmount = order.totalAmount;
        }
      }

      return {
        success: true,
        data: {
          refundEligible,
          refundAmount: refundEligible ? refundAmount : undefined
        }
      };
    } catch (error: unknown) {
      logger.error('Error cancelling order', error, { orderId, context });
      return {
        success: false,
        error: {
          message: 'Failed to cancel order',
          code: 'ORDER_CANCELLATION_FAILED',
          details: error
        }
      };
    }
  }

  /**
   * Update order status
   */
  public static async updateStatus(orderId: string, status: string, context: any): Promise<ServiceResponse<Order>> {
    try {
      const updateData = {
        status,
        updatedBy: context.updatedBy,
        updatedAt: new Date()
      };

      // Add status-specific fields
      if (status === 'cancelled' && context.cancellationReason) {
        (updateData as any).cancellationReason = context.cancellationReason;
      }

      if (status === 'delivered') {
        (updateData as any).deliveredAt = new Date();
      }

      const result = await this.update(orderId, updateData);
      return result;
    } catch (error: unknown) {
      logger.error('Error updating order status', error, { orderId, status, context });
      return {
        success: false,
        error: {
          message: 'Failed to update order status',
          code: 'STATUS_UPDATE_FAILED',
          details: error
        }
      };
    }
  }

  /**
   * Get comprehensive tracking information
   */
  public static async getComprehensiveTrackingInfo(orderId: string): Promise<any> {
    try {
      const [trackingInfo, deliveryStatus, preparationInfo] = await Promise.all([
        this.getTrackingInfo(orderId),
        this.getDeliveryStatus(orderId),
        this.getPreparationInfo(orderId)
      ]);

      return {
        orderId,
        trackingInfo: trackingInfo.success ? trackingInfo.data : null,
        deliveryStatus: deliveryStatus.success ? deliveryStatus.data : null,
        preparationInfo: preparationInfo.success ? preparationInfo.data : null,
        lastUpdated: new Date()
      };
    } catch (error: unknown) {
      logger.error('Error getting comprehensive tracking info', error, { orderId });
      return {
        orderId,
        error: 'Failed to get tracking information',
        lastUpdated: new Date()
      };
    }
  }

  /**
   * Validate order input with comprehensive checks
   */
  private static async validateOrderInput(input: CreateOrderInput): Promise<ServiceResponse<void>> {
    // Check delivery date is not in the past
    if (input.deliveryDate < new Date()) {
      return {
        success: false,
        error: {
          message: 'Delivery date cannot be in the past',
          code: 'INVALID_DELIVERY_DATE'
        }
      };
    }

    // Check order cutoff time
    const cutoffTime = new Date(input.deliveryDate);
    cutoffTime.setHours(cutoffTime.getHours() - this.ORDER_CUTOFF_HOURS);
    
    if (new Date() > cutoffTime) {
      return {
        success: false,
        error: {
          message: 'Order cutoff time has passed for the selected delivery date',
          code: 'ORDER_CUTOFF_PASSED'
        }
      };
    }

    // Validate items array
    if (!input.items || input.items.length === 0) {
      return {
        success: false,
        error: {
          message: 'Order must contain at least one item',
          code: 'NO_ITEMS'
        }
      };
    }

    // Validate quantities
    for (const item of input.items) {
      if (item.quantity <= 0) {
        return {
          success: false,
          error: {
            message: 'Item quantity must be greater than 0',
            code: 'INVALID_QUANTITY'
          }
        };
      }
    }

    return { success: true };
  }

  /**
   * Check dietary restrictions and allergies
   */
  private static async checkDietaryRestrictions(
    menuItems: any[],
    dietaryRestrictions?: string | null,
    allergies?: string | null
  ): Promise<ServiceResponse<void>> {
    if (!dietaryRestrictions && !allergies) {
      return { success: true };
    }

    const userRestrictions = dietaryRestrictions ? 
      JSON.parse(dietaryRestrictions) : [];
    const userAllergies = allergies ? 
      JSON.parse(allergies) : [];

    for (const menuItem of menuItems) {
      // Check allergens
      if (menuItem.allergens && userAllergies.length > 0) {
        const itemAllergens = JSON.parse(menuItem.allergens as string);
        const conflictingAllergens = itemAllergens.filter((allergen: string) => 
          userAllergies.includes(allergen)
        );
        
        if (conflictingAllergens.length > 0) {
          return {
            success: false,
            error: {
              message: `Item "${menuItem.name}" contains allergens that conflict with dietary restrictions or allergies`,
              code: 'DIETARY_RESTRICTION_CONFLICT'
            }
          };
        }
      }

      // Check dietary restrictions
      if (menuItem.tags && userRestrictions.length > 0) {
        const itemTags = JSON.parse(menuItem.tags as string);
        // This would need more sophisticated logic based on specific restrictions
        // For now, we'll do a basic check
      }
    }

    return { success: true };
  }
}

// Export singleton instance
export const orderService = new OrderService();