/**
 * HASIVU Platform - Menu Item Service
 * Business logic layer for product catalog management
 * Implements Story 2.1: Product Catalog Foundation
 * Generated by SuperClaude Wave 2: Backend Implementation - FIXED
 */
import { MenuItem, Prisma } from '@prisma/client';

// Local enum to match schema comments
export enum MenuCategory {
  BREAKFAST = 'BREAKFAST',
  LUNCH = 'LUNCH',
  SNACKS = 'SNACKS',
  DINNER = 'DINNER'
}
import { MenuItemRepository } from '../repositories/menuItem.repository';
import { logger } from '../utils/logger';
import { cache } from '../utils/cache';
import { v4 as uuidv4 } from 'uuid';

/**
 * Menu item creation input interface
 */
export interface CreateMenuItemInput {
  name: string;
  description?: string;
  category: MenuCategory;
  price: number;
  originalPrice?: number;
  currency: string;
  available?: boolean;
  featured?: boolean;
  imageUrl?: string;
  nutritionalInfo?: Record<string, any>;
  allergens?: string[];
  ingredients?: string[];
  tags?: string[];
  preparationTime?: number;
  portionSize?: string;
  calories?: number;
  sortOrder?: number;
  metadata?: Record<string, any>;
  schoolId?: string;
}

/**
 * Menu item update input interface
 */
export interface UpdateMenuItemInput {
  name?: string;
  description?: string;
  category?: MenuCategory;
  price?: number;
  originalPrice?: number;
  currency?: string;
  available?: boolean;
  featured?: boolean;
  imageUrl?: string;
  nutritionalInfo?: Record<string, any>;
  allergens?: string[];
  ingredients?: string[];
  tags?: string[];
  preparationTime?: number;
  portionSize?: string;
  calories?: number;
  sortOrder?: number;
  metadata?: Record<string, any>;
}

/**
 * Bulk availability update interface
 */
export interface BulkAvailabilityUpdate {
  id: string;
  available: boolean;
}

/**
 * Menu item filters interface
 */
export interface MenuItemFilters {
  schoolId?: string;
  category?: MenuCategory;
  available?: boolean;
  featured?: boolean;
  priceMin?: number;
  priceMax?: number;
  allergens?: string[];
  tags?: string[];
  caloriesMin?: number;
  caloriesMax?: number;
}

/**
 * Pagination options interface
 */
export interface PaginationOptions {
  page?: number;
  limit?: number;
  sortBy?: string;
  sortOrder?: 'asc' | 'desc';
}

/**
 * Menu item list result interface
 */
export interface MenuItemListResult {
  items: ExtendedMenuItem[];
  total: number;
  page: number;
  limit: number;
  totalPages: number;
}

/**
 * Extended MenuItem type with computed properties for tests
 */
export interface ExtendedMenuItem extends Omit<MenuItem, 'nutritionalInfo' | 'allergens' | 'tags' | 'metadata'> {
  ingredients?: string[];
  isActive?: boolean;
  nutritionalInfo?: any; // Override to allow parsed object instead of string
  allergens?: string[]; // Override to allow parsed array instead of string
  tags?: string[]; // Override to allow parsed array instead of string
  metadata?: any; // Override to allow parsed object instead of string
}

/**
 * Menu Item Service class
 */
export class MenuItemService {
  private static readonly CACHE_TTL = 300; // 5 minutes
  private static readonly MAX_BATCH_SIZE = 100;

  /**
   * Create new menu item
   */
  public static async createMenuItem(input: CreateMenuItemInput): Promise<ExtendedMenuItem> {
    try {
      logger.info('Creating menu item', { name: input.name, category: input.category });
      
      // Validate business rules
      await this.validateCreateInput(input);
      
      // Check for duplicate names within school context
      if (input.schoolId) {
        const existingItem = await MenuItemRepository.findByNameAndSchool(
          input.name.trim(),
          input.schoolId
        );
        if (existingItem) {
          throw new Error(`Menu item with name "${input.name}" already exists for this school`);
        }
      }
      
      // Prepare data for creation
      const createData: Prisma.MenuItemCreateInput = {
        id: uuidv4(),
        name: input.name.trim(),
        description: input.description?.trim(),
        category: input.category,
        price: new Prisma.Decimal(input.price),
        originalPrice: input.originalPrice ? new Prisma.Decimal(input.originalPrice) : undefined,
        currency: input.currency,
        available: input.available ?? true,
        featured: input.featured ?? false,
        imageUrl: input.imageUrl,
        nutritionalInfo: input.nutritionalInfo ? JSON.stringify(input.nutritionalInfo) : null,
        allergens: input.allergens ? JSON.stringify(input.allergens) : null,
        tags: input.tags ? JSON.stringify(input.tags) : null,
        preparationTime: input.preparationTime,
        portionSize: input.portionSize,
        calories: input.calories,
        sortOrder: input.sortOrder ?? 0,
        metadata: JSON.stringify(input.metadata || {}),
        ...(input.schoolId && {
          school: { connect: { id: input.schoolId } }
        })
      };
      
      const menuItem = await MenuItemRepository.create(createData);
      
      // Clear relevant caches
      await this.clearRelatedCaches(menuItem.schoolId, menuItem.category as MenuCategory);
      
      logger.info('Menu item created successfully', { menuItemId: menuItem.id });
      return this.transformMenuItem(menuItem);
    } catch (error: unknown) {
      logger.error('Failed to create menu item', error, { input });
      throw error;
    }
  }

  /**
   * Get menu item by ID
   */
  public static async getMenuItemById(id: string, includeSchool: boolean = true): Promise<ExtendedMenuItem | null> {
    try {
      const cacheKey = `menu_item:${id}:${includeSchool}`;
      const cached = await cache.get(cacheKey);
      if (cached) {
        return JSON.parse(cached);
      }
      
      const menuItem = await MenuItemRepository.findById(id, includeSchool);
      if (!menuItem) {
        logger.warn('Menu item not found', { menuItemId: id });
        return null;
      }
      
      const transformedItem = this.transformMenuItem(menuItem);
      await cache.setex(cacheKey, this.CACHE_TTL, JSON.stringify(transformedItem));
      return transformedItem;
    } catch (error: unknown) {
      logger.error('Failed to get menu item by ID', error, { menuItemId: id });
      throw error;
    }
  }

  /**
   * Get menu items with filtering and pagination
   */
  public static async getMenuItems(
    filters: MenuItemFilters = {},
    pagination: PaginationOptions = {}
  ): Promise<MenuItemListResult> {
    try {
      const page = pagination.page || 1;
      const limit = Math.min(pagination.limit || 20, 100);
      const skip = (page - 1) * limit;
      
      const options = {
        filters,
        skip,
        take: limit,
        sortBy: pagination.sortBy || 'sortOrder',
        sortOrder: pagination.sortOrder || 'asc'
      };
      
      const result = await MenuItemRepository.findMany(options);
      const totalPages = Math.ceil(result.total / limit);
      
      // Transform all items
      const transformedItems = result.items.map((item: any) => this.transformMenuItem(item));
      
      logger.info('Retrieved menu items', { 
        count: transformedItems.length, 
        total: result.total,
        page,
        filters 
      });
      
      return {
        items: transformedItems,
        total: result.total,
        page,
        limit,
        totalPages
      };
    } catch (error: unknown) {
      logger.error('Failed to get menu items', error, { filters, pagination });
      throw error;
    }
  }

  /**
   * Get menu items by category
   */
  public static async getMenuItemsByCategory(
    category: MenuCategory,
    options: { schoolId?: string; available?: boolean; limit?: number } = {}
  ): Promise<ExtendedMenuItem[]> {
    try {
      const filters: MenuItemFilters = {
        category,
        ...(options.schoolId && { schoolId: options.schoolId }),
        ...(options.available !== undefined && { available: options.available })
      };
      
      const pagination: PaginationOptions = {
        limit: options.limit || 50,
        sortBy: 'sortOrder',
        sortOrder: 'asc'
      };
      
      const result = await this.getMenuItems(filters, pagination);
      const items = result.items; // Already transformed by getMenuItems
      
      logger.info('Retrieved menu items by category', { 
        category, 
        count: items.length,
        options 
      });
      return items;
    } catch (error: unknown) {
      logger.error('Failed to get menu items by category', error, { category, options });
      throw error;
    }
  }

  /**
   * Get featured menu items
   */
  public static async getFeaturedItems(
    options: { schoolId?: string; category?: MenuCategory; limit?: number } = {}
  ): Promise<ExtendedMenuItem[]> {
    try {
      const filters: MenuItemFilters = {
        featured: true,
        available: true,
        ...(options.schoolId && { schoolId: options.schoolId }),
        ...(options.category && { category: options.category })
      };
      
      const pagination: PaginationOptions = {
        limit: options.limit || 10,
        sortBy: 'sortOrder',
        sortOrder: 'asc'
      };
      
      const result = await this.getMenuItems(filters, pagination);
      const items = result.items; // Already transformed by getMenuItems
      
      logger.info('Retrieved featured menu items', { 
        count: items.length,
        options 
      });
      return items;
    } catch (error: unknown) {
      logger.error('Failed to get featured menu items', error, { options });
      throw error;
    }
  }

  /**
   * Search menu items
   */
  public static async searchMenuItems(
    searchTerm: string,
    filters: MenuItemFilters = {},
    pagination: { page?: number; limit?: number } = {}
  ): Promise<{ items: ExtendedMenuItem[]; total: number }> {
    try {
      if (!searchTerm.trim()) {
        const result = await this.getMenuItems(filters, pagination);
        return { items: result.items, total: result.total };
      }
      
      const result = await MenuItemRepository.search(
        searchTerm.trim(),
        filters,
        pagination
      );
      
      // Transform items
      const transformedItems = result.items.map((item: any) => this.transformMenuItem(item));
      
      return { items: transformedItems, total: result.total };
      
      logger.info('Searched menu items', { 
        searchTerm, 
        count: transformedItems.length,
        total: result.total,
        filters 
      });
    } catch (error: unknown) {
      logger.error('Failed to search menu items', error, { searchTerm, filters });
      throw error;
    }
  }

  /**
   * Update menu item
   */
  public static async updateMenuItem(id: string, input: UpdateMenuItemInput): Promise<ExtendedMenuItem> {
    try {
      logger.info('Updating menu item', { menuItemId: id });
      
      // Check if menu item exists
      const existing = await MenuItemRepository.findById(id);
      if (!existing) {
        throw new Error(`Menu item with ID ${id} not found`);
      }
      
      // Validate business rules if updating critical fields
      if (input.price !== undefined || input.category !== undefined) {
        await this.validateUpdateInput(input);
      }
      
      // Check for duplicate names if name is being changed
      if (input.name && input.name !== existing.name) {
        if (existing.schoolId) {
          const duplicateItem = await MenuItemRepository.findByNameAndSchool(
            input.name.trim(),
            existing.schoolId
          );
          if (duplicateItem && duplicateItem.id !== id) {
            throw new Error(`Menu item with name "${input.name}" already exists for this school`);
          }
        }
      }
      
      // Prepare update data
      const updateData: Prisma.MenuItemUpdateInput = {};
      if (input.name !== undefined) updateData.name = input.name.trim();
      if (input.description !== undefined) updateData.description = input.description?.trim();
      if (input.category !== undefined) updateData.category = input.category;
      if (input.price !== undefined) updateData.price = new Prisma.Decimal(input.price);
      if (input.originalPrice !== undefined) {
        updateData.originalPrice = input.originalPrice ? new Prisma.Decimal(input.originalPrice) : null;
      }
      if (input.currency !== undefined) updateData.currency = input.currency;
      if (input.available !== undefined) updateData.available = input.available;
      if (input.featured !== undefined) updateData.featured = input.featured;
      if (input.imageUrl !== undefined) updateData.imageUrl = input.imageUrl;
      if (input.nutritionalInfo !== undefined) {
        updateData.nutritionalInfo = input.nutritionalInfo ? JSON.stringify(input.nutritionalInfo) : null;
      }
      if (input.allergens !== undefined) updateData.allergens = JSON.stringify(input.allergens);
      if (input.tags !== undefined) updateData.tags = JSON.stringify(input.tags);
      if (input.preparationTime !== undefined) updateData.preparationTime = input.preparationTime;
      if (input.portionSize !== undefined) updateData.portionSize = input.portionSize;
      if (input.calories !== undefined) updateData.calories = input.calories;
      if (input.sortOrder !== undefined) updateData.sortOrder = input.sortOrder;
      if (input.metadata !== undefined) updateData.metadata = JSON.stringify(input.metadata);
      
      const menuItem = await MenuItemRepository.update(id, updateData);
      
      // Clear relevant caches
      await this.clearRelatedCaches(menuItem.schoolId, menuItem.category as MenuCategory);
      await cache.del(`menu_item:${id}:true`);
      await cache.del(`menu_item:${id}:false`);
      
      logger.info('Menu item updated successfully', { menuItemId: menuItem.id });
      return this.transformMenuItem(menuItem);
    } catch (error: unknown) {
      logger.error('Failed to update menu item', error, { menuItemId: id, input });
      throw error;
    }
  }

  /**
   * Delete menu item (soft delete - mark as unavailable)
   */
  public static async deleteMenuItem(id: string, hard: boolean = false): Promise<ExtendedMenuItem> {
    try {
      logger.info('Deleting menu item', { menuItemId: id, hard });
      
      const existing = await MenuItemRepository.findById(id);
      if (!existing) {
        throw new Error(`Menu item with ID ${id} not found`);
      }
      
      let menuItem: MenuItem;
      if (hard) {
        menuItem = await MenuItemRepository.delete(id);
      } else {
        // Soft delete - mark as unavailable
        menuItem = await MenuItemRepository.update(id, { available: false });
      }
      
      // Clear relevant caches
      await this.clearRelatedCaches(menuItem.schoolId, menuItem.category as MenuCategory);
      await cache.del(`menu_item:${id}:true`);
      await cache.del(`menu_item:${id}:false`);
      
      logger.info('Menu item deleted successfully', { 
        menuItemId: menuItem.id, 
        hard 
      });
      return this.transformMenuItem(menuItem);
    } catch (error: unknown) {
      logger.error('Failed to delete menu item', error, { menuItemId: id });
      throw error;
    }
  }

  /**
   * Update sort orders for multiple menu items
   */
  public static async updateSortOrders(
    updates: Array<{ id: string; sortOrder: number }>
  ): Promise<void> {
    try {
      if (updates.length === 0) {
        return;
      }
      
      if (updates.length > this.MAX_BATCH_SIZE) {
        throw new Error(`Cannot update more than ${this.MAX_BATCH_SIZE} items at once`);
      }
      
      logger.info('Updating menu item sort orders', { count: updates.length });
      
      // Validate all IDs exist
      const ids = updates.map(u => u.id);
      const existingItems = await Promise.all(
        ids.map(id => MenuItemRepository.findById(id))
      );
      
      const missingItems = existingItems
        .map((item, index) => item ? null : ids[index])
        .filter(Boolean);
      
      if (missingItems.length > 0) {
        throw new Error(`Menu items not found: ${missingItems.join(', ')}`);
      }
      
      // Execute batch update
      await MenuItemRepository.batchUpdateSortOrders(updates);
      
      // Clear caches for affected schools and categories
      const schoolCategories = new Set<string>();
      existingItems.forEach(item => {
        if (item?.schoolId && item?.category) {
          schoolCategories.add(`${item.schoolId}:${item.category}`);
        }
      });
      
      await Promise.all(
        Array.from(schoolCategories).map(key => {
          const [schoolId, category] = key.split(':');
          return this.clearRelatedCaches(schoolId, category as MenuCategory);
        })
      );
      
      logger.info('Menu item sort orders updated successfully', { 
        count: updates.length 
      });
    } catch (error: unknown) {
      logger.error('Failed to update sort orders', error, { updates });
      throw error;
    }
  }

  /**
   * Toggle featured status for menu item
   */
  public static async toggleFeatured(id: string): Promise<ExtendedMenuItem> {
    try {
      const existing = await this.getMenuItemById(id);
      if (!existing) {
        throw new Error(`Menu item with ID ${id} not found`);
      }
      
      return await this.updateMenuItem(id, { featured: !existing.featured });
    } catch (error: unknown) {
      logger.error('Failed to toggle featured status', error, { menuItemId: id });
      throw error;
    }
  }

  /**
   * Toggle availability for menu item
   */
  public static async toggleAvailability(id: string): Promise<ExtendedMenuItem> {
    try {
      const existing = await this.getMenuItemById(id);
      if (!existing) {
        throw new Error(`Menu item with ID ${id} not found`);
      }
      
      return await this.updateMenuItem(id, { available: !existing.available });
    } catch (error: unknown) {
      logger.error('Failed to toggle availability', error, { menuItemId: id });
      throw error;
    }
  }

  /**
   * Get menu items by allergen restrictions
   */
  public static async getMenuItemsByAllergens(
    excludeAllergens: string[],
    options: { schoolId?: string; category?: MenuCategory } = {}
  ): Promise<ExtendedMenuItem[]> {
    try {
      const filters: MenuItemFilters = {
        available: true,
        ...(options.schoolId && { schoolId: options.schoolId }),
        ...(options.category && { category: options.category })
      };
      
      const result = await this.getMenuItems(filters);
      
      // Filter out items that contain excluded allergens
      const filteredItems = result.items.filter(item => {
        if (!item.allergens) return true;
        
        try {
          const itemAllergens = Array.isArray(item.allergens) 
            ? item.allergens 
            : JSON.parse(item.allergens as string) as string[];
          return !excludeAllergens.some(allergen => 
            itemAllergens.includes(allergen)
          );
        } catch {
          return true; // If allergens parsing fails, include the item
        }
      });
      
      logger.info('Retrieved menu items by allergen restrictions', {
        excludeAllergens,
        totalItems: result.items.length,
        filteredItems: filteredItems.length,
        options
      });
      
      return filteredItems;
    } catch (error: unknown) {
      logger.error('Failed to get menu items by allergens', error, {
        excludeAllergens,
        options
      });
      throw error;
    }
  }

  /**
   * Get nutritional summary for multiple menu items
   */
  public static async getNutritionalSummary(
    itemIds: string[]
  ): Promise<{ totalCalories: number; allergens: string[]; nutritionalInfo: Record<string, any> }> {
    try {
      const items = await Promise.all(
        itemIds.map(id => this.getMenuItemById(id))
      );
      
      const validItems = items.filter(Boolean) as ExtendedMenuItem[];
      
      let totalCalories = 0;
      const allAllergens = new Set<string>();
      const nutritionalInfo: Record<string, any> = {};
      
      validItems.forEach(item => {
        if (item.calories) {
          totalCalories += item.calories;
        }
        
        if (item.allergens) {
          try {
            const itemAllergens = Array.isArray(item.allergens)
              ? item.allergens
              : JSON.parse(item.allergens as string) as string[];
            itemAllergens.forEach(allergen => allAllergens.add(allergen));
          } catch {
            // Skip invalid allergen data
          }
        }
        
        if (item.nutritionalInfo) {
          try {
            const itemNutrition = typeof item.nutritionalInfo === 'string'
              ? JSON.parse(item.nutritionalInfo)
              : item.nutritionalInfo;
            Object.keys(itemNutrition).forEach(key => {
              if (typeof itemNutrition[key] === 'number') {
                nutritionalInfo[key] = (nutritionalInfo[key] || 0) + itemNutrition[key];
              }
            });
          } catch {
            // Skip invalid nutritional data
          }
        }
      });
      
      return {
        totalCalories,
        allergens: Array.from(allAllergens),
        nutritionalInfo
      };
    } catch (error: unknown) {
      logger.error('Failed to get nutritional summary', error, { itemIds });
      throw error;
    }
  }

  /**
   * Validate create input
   */
  private static async validateCreateInput(input: CreateMenuItemInput): Promise<void> {
    if (!input.name?.trim()) {
      throw new Error('Menu item name is required');
    }
    
    if (input.name.length > 200) {
      throw new Error('Menu item name cannot exceed 200 characters');
    }
    
    if (input.description && input.description.length > 1000) {
      throw new Error('Menu item description cannot exceed 1000 characters');
    }
    
    if (input.price <= 0) {
      throw new Error('Menu item price must be greater than 0');
    }
    
    if (input.originalPrice && input.originalPrice <= 0) {
      throw new Error('Original price must be greater than 0');
    }
    
    if (input.originalPrice && input.originalPrice <= input.price) {
      throw new Error('Original price must be greater than current price');
    }
    
    if (input.preparationTime && input.preparationTime < 0) {
      throw new Error('Preparation time cannot be negative');
    }
    
    if (input.calories && input.calories < 0) {
      throw new Error('Calories cannot be negative');
    }
  }

  /**
   * Validate update input
   */
  private static async validateUpdateInput(input: UpdateMenuItemInput): Promise<void> {
    if (input.name !== undefined && !input.name?.trim()) {
      throw new Error('Menu item name cannot be empty');
    }
    
    if (input.name && input.name.length > 200) {
      throw new Error('Menu item name cannot exceed 200 characters');
    }
    
    if (input.description && input.description.length > 1000) {
      throw new Error('Menu item description cannot exceed 1000 characters');
    }
    
    if (input.price !== undefined && input.price <= 0) {
      throw new Error('Menu item price must be greater than 0');
    }
    
    if (input.originalPrice !== undefined && input.originalPrice !== null && input.originalPrice <= 0) {
      throw new Error('Original price must be greater than 0');
    }
    
    if (input.preparationTime !== undefined && input.preparationTime < 0) {
      throw new Error('Preparation time cannot be negative');
    }
    
    if (input.calories !== undefined && input.calories < 0) {
      throw new Error('Calories cannot be negative');
    }
  }

  /**
   * Transform raw MenuItem from database to include parsed JSON fields and computed properties
   */
  private static transformMenuItem(rawItem: any): ExtendedMenuItem {
    if (!rawItem) return null;
    
    try {
      // Parse JSON fields
      let nutritionalInfo = null;
      let allergens = [];
      let tags = [];
      let metadata = {};
      
      if (rawItem.nutritionalInfo) {
        try {
          nutritionalInfo = typeof rawItem.nutritionalInfo === 'string' 
            ? JSON.parse(rawItem.nutritionalInfo) 
            : rawItem.nutritionalInfo;
        } catch (e) {
          logger.warn('Failed to parse nutritional info JSON', { itemId: rawItem.id });
        }
      }
      
      if (rawItem.allergens) {
        try {
          allergens = typeof rawItem.allergens === 'string' 
            ? JSON.parse(rawItem.allergens) 
            : rawItem.allergens;
        } catch (e) {
          logger.warn('Failed to parse allergens JSON', { itemId: rawItem.id });
        }
      }
      
      if (rawItem.tags) {
        try {
          tags = typeof rawItem.tags === 'string' 
            ? JSON.parse(rawItem.tags) 
            : rawItem.tags;
        } catch (e) {
          logger.warn('Failed to parse tags JSON', { itemId: rawItem.id });
        }
      }
      
      if (rawItem.metadata) {
        try {
          metadata = typeof rawItem.metadata === 'string' 
            ? JSON.parse(rawItem.metadata) 
            : rawItem.metadata;
        } catch (e) {
          logger.warn('Failed to parse metadata JSON', { itemId: rawItem.id });
        }
      }
      
      // Extract ingredients from nutritional info or metadata
      let ingredients: string[] = [];
      if (nutritionalInfo && typeof nutritionalInfo === 'object' && (nutritionalInfo as any).ingredients) {
        ingredients = Array.isArray((nutritionalInfo as any).ingredients) ? (nutritionalInfo as any).ingredients : [];
      } else if (metadata && typeof metadata === 'object' && (metadata as any).ingredients) {
        ingredients = Array.isArray((metadata as any).ingredients) ? (metadata as any).ingredients : [];
      }
      
      return {
        ...rawItem,
        nutritionalInfo,
        allergens,
        tags,
        metadata,
        ingredients,
        isActive: rawItem.available === true, // Computed property for tests
      } as ExtendedMenuItem;
    } catch (error: unknown) {
      logger.warn('Failed to transform menu item', { error: error instanceof Error ? error.message : String(error), itemId: rawItem?.id });
      return rawItem as ExtendedMenuItem;
    }
  }

  /**
   * Bulk create menu items
   */
  public static async bulkCreateMenuItems(items: CreateMenuItemInput[]): Promise<ExtendedMenuItem[]> {
    try {
      if (items.length === 0) return [];
      
      if (items.length > this.MAX_BATCH_SIZE) {
        throw new Error(`Cannot create more than ${this.MAX_BATCH_SIZE} items at once`);
      }
      
      logger.info('Bulk creating menu items', { count: items.length });
      
      // Validate all inputs
      await Promise.all(items.map((item: any) => this.validateCreateInput(item)));
      
      // Create all items
      const results = await Promise.all(
        items.map((item: any) => this.createMenuItem(item))
      );
      
      logger.info('Bulk menu items created successfully', { count: results.length });
      return results;
    } catch (error: unknown) {
      logger.error('Failed to bulk create menu items', error, { count: items.length });
      throw error;
    }
  }

  /**
   * Bulk update menu availability
   */
  public static async bulkUpdateAvailability(updates: BulkAvailabilityUpdate[]): Promise<ExtendedMenuItem[]> {
    try {
      if (updates.length === 0) return [];
      
      if (updates.length > this.MAX_BATCH_SIZE) {
        throw new Error(`Cannot update more than ${this.MAX_BATCH_SIZE} items at once`);
      }
      
      logger.info('Bulk updating menu item availability', { count: updates.length });
      
      // Update all items
      const results = await Promise.all(
        updates.map(update => 
          this.updateMenuItem(update.id, { available: update.available })
        )
      );
      
      logger.info('Bulk availability updates completed', { count: results.length });
      return results;
    } catch (error: unknown) {
      logger.error('Failed to bulk update availability', error, { count: updates.length });
      throw error;
    }
  }

  /**
   * Clear related caches
   */
  private static async clearRelatedCaches(
    schoolId?: string | null,
    category?: MenuCategory
  ): Promise<void> {
    try {
      const cacheKeys = [
        'menu_items:*',
        'featured_items:*',
        ...(schoolId ? [`school:${schoolId}:menu_items:*`] : []),
        ...(category ? [`category:${category}:*`] : [])
      ];
      
      // Note: InMemoryCache.deletePattern method not available, clear entire cache
      cache.clear();
    } catch (error: unknown) {
      logger.warn('Failed to clear caches', error);
    }
  }

  /**
   * Clear all menu item caches (instance method for tests)
   */
  public async clearCache(): Promise<void> {
    try {
      cache.clear();
      logger.info('Menu item caches cleared');
    } catch (error: unknown) {
      logger.warn('Failed to clear menu item caches', error);
    }
  }

  /**
   * Disconnect from external resources (instance method for tests)
   */
  public async disconnect(): Promise<void> {
    try {
      // No specific resources to disconnect from in this service
      logger.info('Menu item service disconnected');
    } catch (error: unknown) {
      logger.warn('Failed to disconnect menu item service', error);
    }
  }

  // Instance methods delegating to static methods for testing compatibility
  
  /**
   * Create new menu item (instance method)
   */
  public async createMenuItem(input: CreateMenuItemInput): Promise<ExtendedMenuItem> {
    return MenuItemService.createMenuItem(input);
  }

  /**
   * Get menu item by ID (instance method)
   */
  public async getMenuItemById(id: string, includeSchool: boolean = true): Promise<ExtendedMenuItem | null> {
    return MenuItemService.getMenuItemById(id, includeSchool);
  }

  /**
   * Get menu items with filtering and pagination (instance method)
   */
  public async getMenuItems(
    filters: MenuItemFilters = {},
    pagination: PaginationOptions = {}
  ): Promise<MenuItemListResult> {
    return MenuItemService.getMenuItems(filters, pagination);
  }

  /**
   * Update menu item (instance method)
   */
  public async updateMenuItem(id: string, input: UpdateMenuItemInput): Promise<ExtendedMenuItem> {
    return MenuItemService.updateMenuItem(id, input);
  }

  /**
   * Delete menu item (instance method)
   */
  public async deleteMenuItem(id: string, hard: boolean = false): Promise<ExtendedMenuItem> {
    return MenuItemService.deleteMenuItem(id, hard);
  }

  /**
   * Get menu items by category (instance method)
   */
  public async getMenuItemsByCategory(
    category: MenuCategory,
    options: { schoolId?: string; available?: boolean; limit?: number } = {}
  ): Promise<ExtendedMenuItem[]> {
    return MenuItemService.getMenuItemsByCategory(category, options);
  }

  /**
   * Get featured menu items (instance method)
   */
  public async getFeaturedItems(
    options: { schoolId?: string; category?: MenuCategory; limit?: number } = {}
  ): Promise<ExtendedMenuItem[]> {
    return MenuItemService.getFeaturedItems(options);
  }

  /**
   * Search menu items by name and description (instance method)
   */
  public async searchMenuItems(
    searchOptions: {
      query: string;
      schoolId?: string;
      filters?: MenuItemFilters;
      pagination?: { page?: number; limit?: number };
      limit?: number;
    }
  ): Promise<ExtendedMenuItem[]> {
    const searchTerm = searchOptions.query;
    const filters: MenuItemFilters = {
      ...(searchOptions.schoolId && { schoolId: searchOptions.schoolId }),
      ...(searchOptions.filters || {})
    };
    
    const pagination: PaginationOptions = {
      page: searchOptions.pagination?.page || 1,
      limit: searchOptions.pagination?.limit || searchOptions.limit || 50,
      sortBy: 'name',
      sortOrder: 'asc'
    };
    
    const result = await MenuItemService.searchMenuItems(searchTerm, filters, pagination);
    return result.items;
  }

  /**
   * Bulk create menu items (instance method)
   */
  public async bulkCreateMenuItems(items: CreateMenuItemInput[]): Promise<ExtendedMenuItem[]> {
    return MenuItemService.bulkCreateMenuItems(items);
  }

  /**
   * Bulk update menu availability (instance method)
   */
  public async bulkUpdateAvailability(updates: BulkAvailabilityUpdate[]): Promise<ExtendedMenuItem[]> {
    return MenuItemService.bulkUpdateAvailability(updates);
  }

  /**
   * Transform raw MenuItem from database (instance method for tests)
   */
  public transformMenuItem(rawItem: any): ExtendedMenuItem {
    return MenuItemService.transformMenuItem(rawItem);
  }

  /**
   * Get menu statistics
   */
  public static async getMenuStats(schoolId?: string): Promise<{
    totalItems: number;
    averagePrice: number;
    byCategory: Record<string, number>;
  }> {
    const stats = await MenuItemRepository.getStatistics(schoolId);
    
    return {
      totalItems: stats.totalItems,
      averagePrice: Number(stats.averagePrice) || 0,
      byCategory: stats.itemsByCategory
    };
  }
}

// Export singleton instance
export const menuItemService = new MenuItemService();