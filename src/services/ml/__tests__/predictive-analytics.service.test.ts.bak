/**
 * HASIVU PREDICTIVE ANALYTICS SERVICE TESTS
 * Epic 3 â†’ Story 1: Comprehensive ML Platform Testing
 *
 * Unit and integration tests for the predictive analytics engine
 * with mocked dependencies and realistic test scenarios.
 */

import { PredictiveAnalyticsService } from '../predictive-analytics.service';
import { MLflowService } from '../mlflow.service';
import { ModelArtifactService } from '../model-artifact.service';
import { RealtimePredictionService } from '../realtime-prediction.service';
import { FederatedLearningService } from '../federated-learning.service';
import { FeatureEngineeringService } from '../feature-engineering.service';
import { RecommendationEngine } from '../recommendation-engine.service';
import { ModelMonitoringService } from '../model-monitoring.service';
import { ExplainabilityService } from '../explainability.service';
import { AutoMLService } from '../automl.service';

// Mock dependencies
jest.mock('../mlflow.service');
jest.mock('../model-artifact.service');
jest.mock('../realtime-prediction.service');
jest.mock('../federated-learning.service');
jest.mock('../feature-engineering.service');
jest.mock('../recommendation-engine.service');
jest.mock('../model-monitoring.service');
jest.mock('../explainability.service');
jest.mock('../automl.service');
jest.mock('../../logger.service');
jest.mock('../../circuit-breaker.service');
jest.mock('../../cache.service');
jest.mock('../../database.service');

describe('PredictiveAnalyticsService', () => {
  let service: any;
  let mockMLflow: any;
  let mockModelArtifact: any;
  let mockRealtimePrediction: any;
  let mockFeatureEngineering: any;
  let mockRecommendationEngine: any;
  let mockModelMonitoring: any;
  let mockExplainability: any;

  beforeEach(async () => {
    // Reset all mocks
    jest.clearAllMocks();

    // Create service instance using singleton pattern
    service = PredictiveAnalyticsService.getInstance();

    // Setup mock implementations
    mockMLflow = service['mlflow'] as jest.Mocked<MLflowService>;
    mockModelArtifact = service['modelArtifact'] as jest.Mocked<ModelArtifactService>;
    mockRealtimePrediction = service['realtimePrediction'] as jest.Mocked<RealtimePredictionService>;
    mockFeatureEngineering = service['featureEngineering'] as jest.Mocked<FeatureEngineeringService>;
    mockRecommendationEngine = service['recommendationEngine'] as jest.Mocked<RecommendationEngine>;
    mockModelMonitoring = service['modelMonitoring'] as jest.Mocked<ModelMonitoringService>;
    mockExplainability = service['explainability'] as jest.Mocked<ExplainabilityService>;

    // Service is initialized automatically via singleton pattern
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  describe('Initialization', () => {
    it('should initialize all services successfully', async () => {
      expect(mockMLflow.initialize).toHaveBeenCalled();
      expect(mockModelArtifact.initialize).toHaveBeenCalled();
      expect(mockRealtimePrediction.initialize).toHaveBeenCalled();
      expect(mockFeatureEngineering.initialize).toHaveBeenCalled();
      expect(mockRecommendationEngine.initialize).toHaveBeenCalled();
      expect(mockModelMonitoring.initialize).toHaveBeenCalled();
      expect(mockExplainability.initialize).toHaveBeenCalled();
    });

    // Initialization tests removed - service initializes automatically via singleton pattern
  });

  describe('Prediction', () => {
    const samplePredictionRequest = {
      modelType: 'student_behavior' as const,
      schoolId: 'school-123',
      inputData: {
        student_age: 12,
        grade: '7th',
        dietary_preferences: ['vegetarian'],
        historical_choices: ['salad', 'pizza'],
        time_of_day: '12:00'
      },
      predictionHorizon: '1d' as const,
      confidence: true,
      explanation: true,
      personalization: {
        userId: 'user-123',
        userType: 'student' as const,
        preferences: {
          spice_level: 'mild',
          meal_size: 'regular'
        }
      }
    };

    const samplePredictionResponse = {
      prediction: { meal_choice: 'vegetarian_pasta', probability: 0.85 },
      confidence: 0.85,
      uncertainty: {
        lower_bound: 0.75,
        upper_bound: 0.95,
        std_deviation: 0.05
      },
      explanation: {
        feature_importance: {
          dietary_preferences: 0.4,
          historical_choices: 0.3,
          student_age: 0.2,
          time_of_day: 0.1
        },
        natural_language: 'The student is likely to choose vegetarian pasta based on their dietary preferences and past choices.'
      },
      model_metadata: {
        model_id: 'student_behavior_v1.2',
        version: '1.2',
        training_date: '2024-01-01T00:00:00Z',
        performance_metrics: {
          accuracy: 0.92,
          precision: 0.89,
          recall: 0.87
        }
      },
      recommendation: {
        actions: [
          {
            action: 'offer_similar_meals',
            impact_score: 0.8,
            confidence: 0.85,
            rationale: 'Student shows preference for vegetarian options'
          }
        ],
        priority: 'medium' as const
      }
    };

    beforeEach(() => {
      // Mock feature engineering
      mockFeatureEngineering.extractFeatures = jest.fn().mockResolvedValue({
        student_age_normalized: 0.5,
        dietary_preferences_encoded: [1, 0, 0, 0],
        historical_choices_embedding: [0.1, 0.2, 0.3],
        time_of_day_encoded: 12
      });

      // Mock real-time prediction
      mockRealtimePrediction.predict = jest.fn().mockResolvedValue({
        value: { meal_choice: 'vegetarian_pasta', probability: 0.85 },
        confidence: 0.85,
        modelId: 'student_behavior_v1.2',
        version: '1.2',
        latency: 45,
        fromCache: false
      });

      // Mock explainability
      mockExplainability.generateExplanation = jest.fn().mockResolvedValue({
        feature_importance: {
          dietary_preferences: 0.4,
          historical_choices: 0.3,
          student_age: 0.2,
          time_of_day: 0.1
        },
        natural_language: 'The student is likely to choose vegetarian pasta based on their dietary preferences and past choices.',
        shap_values: {
          dietary_preferences: 0.2,
          historical_choices: 0.15,
          student_age: 0.1,
          time_of_day: 0.05
        }
      });

      // Mock recommendation engine
      mockRecommendationEngine.generateRecommendations = jest.fn().mockResolvedValue({
        actions: [
          {
            action: 'offer_similar_meals',
            impact_score: 0.8,
            confidence: 0.85,
            rationale: 'Student shows preference for vegetarian options'
          }
        ],
        priority: 'medium'
      });
    });

    it('should make successful prediction with all features', async () => {
      const result = await service.predict(samplePredictionRequest);

      expect(result).toMatchObject({
        prediction: expect.any(Object),
        confidence: expect.any(Number),
        uncertainty: expect.any(Object),
        explanation: expect.any(Object),
        model_metadata: expect.any(Object),
        recommendation: expect.any(Object)
      });

      expect(mockFeatureEngineering.extractFeatures).toHaveBeenCalledWith(
        samplePredictionRequest.inputData,
        samplePredictionRequest.modelType,
        samplePredictionRequest.schoolId
      );

      expect(mockRealtimePrediction.predict).toHaveBeenCalled();
      expect(mockExplainability.generateExplanation).toHaveBeenCalled();
      expect(mockRecommendationEngine.generateRecommendations).toHaveBeenCalled();
    });

    it('should validate prediction request', async () => {
      const invalidRequest = {
        ...samplePredictionRequest,
        modelType: 'invalid_model' as any
      };

      await expect(service.predict(invalidRequest)).rejects.toThrow();
    });

    it('should handle prediction failures gracefully', async () => {
      mockRealtimePrediction.predict = jest.fn().mockRejectedValue(new Error('Prediction failed'));

      await expect(service.predict(samplePredictionRequest)).rejects.toThrow('Prediction failed');
    });

    it('should use cached results when available', async () => {
      // Mock cache hit
      service['cache'].get = jest.fn().mockResolvedValue(samplePredictionResponse);

      const result = await service.predict(samplePredictionRequest);

      expect(result).toEqual(samplePredictionResponse);
      expect(mockRealtimePrediction.predict).not.toHaveBeenCalled();
    });

    it('should handle personalization parameters', async () => {
      const requestWithPersonalization = {
        ...samplePredictionRequest,
        personalization: {
          userId: 'user-456',
          userType: 'parent' as const,
          preferences: {
            health_conscious: true,
            budget_sensitive: false
          }
        }
      };

      await service.predict(requestWithPersonalization);

      expect(mockRealtimePrediction.predict).toHaveBeenCalledWith(
        expect.objectContaining({
          personalization: requestWithPersonalization.personalization
        })
      );
    });
  });

  describe('Model Training', () => {
    const sampleTrainingData = Array.from({ length: 1000 }, (_, i) => ({
      student_id: `student_${i}`,
      age: 10 + Math.floor(Math.random() * 8),
      grade: `${Math.floor(Math.random() * 12) + 1}th`,
      dietary_preferences: ['vegetarian', 'regular', 'vegan'][Math.floor(Math.random() * 3)],
      meal_choice: ['pizza', 'salad', 'burger', 'pasta'][Math.floor(Math.random() * 4)],
      timestamp: new Date(Date.now() - Math.random() * 365 * 24 * 60 * 60 * 1000)
    }));

    const sampleConfig = {
      architecture: 'neural_network',
      hyperparameters: {
        layers: [128, 64, 32],
        activation: 'relu',
        dropout: 0.2,
        learning_rate: 0.001
      },
      training_config: {
        epochs: 100,
        batch_size: 32,
        learning_rate: 0.001,
        validation_split: 0.2,
        early_stopping: true
      }
    };

    beforeEach(() => {
      // Mock AutoML service
      const mockAutoML = service['autoML'] as jest.Mocked<AutoMLService>;
      mockAutoML.trainModel = jest.fn().mockResolvedValue('model_12345');

      // Mock MLflow registration
      mockMLflow.registerModel = jest.fn().mockResolvedValue(undefined);

      // Mock model monitoring
      mockModelMonitoring.addModel = jest.fn().mockResolvedValue(undefined);
    });

    it('should train model successfully', async () => {
      const modelId = await service.trainModel(
        'student_behavior',
        sampleTrainingData,
        sampleConfig
      );

      expect(modelId).toBe('model_12345');
      expect(service['autoML'].trainModel).toHaveBeenCalledWith({
        modelType: 'student_behavior',
        trainingData: sampleTrainingData,
        config: sampleConfig,
        optimization_objectives: ['accuracy', 'latency', 'fairness']
      });
    });

    it('should register model with MLflow', async () => {
      await service.trainModel('student_behavior', sampleTrainingData, sampleConfig);

      expect(mockMLflow.registerModel).toHaveBeenCalledWith(
        'model_12345',
        expect.objectContaining({
          modelType: 'student_behavior',
          config: sampleConfig,
          training_data_size: sampleTrainingData.length
        })
      );
    });

    it('should add model to monitoring', async () => {
      await service.trainModel('student_behavior', sampleTrainingData, sampleConfig);

      expect(mockModelMonitoring.addModel).toHaveBeenCalledWith(
        'model_12345',
        expect.objectContaining({
          modelType: 'student_behavior'
        })
      );
    });

    it('should handle federated learning training', async () => {
      const federatedConfig = {
        enabled: true,
        min_participants: 3,
        max_participants: 10,
        rounds: 5,
        privacy_budget: { epsilon: 1.0, delta: 1e-5 },
        aggregation_method: 'fedavg' as const
      };

      const mockFederatedLearning = service['federatedLearning'] as any;
      mockFederatedLearning.trainFederatedModel = jest.fn().mockResolvedValue('federated_model_123');

      const modelId = await service.trainModel(
        'student_behavior',
        sampleTrainingData,
        sampleConfig,
        federatedConfig
      );

      expect(mockFederatedLearning.trainFederatedModel).toHaveBeenCalledWith({
        modelType: 'student_behavior',
        trainingData: sampleTrainingData,
        config: sampleConfig,
        federatedConfig
      });
    });

    it('should emit model_trained event', async () => {
      const emitSpy = jest.spyOn(service, 'emit');

      await service.trainModel('student_behavior', sampleTrainingData, sampleConfig);

      expect(emitSpy).toHaveBeenCalledWith('model_trained', {
        modelId: 'model_12345',
        modelType: 'student_behavior'
      });
    });
  });

  describe('Analytics', () => {
    const sampleAnalytics = {
      performance_metrics: {
        predictions_served: 10000,
        average_latency: 45,
        accuracy_by_model: {
          student_behavior: 0.92,
          demand_forecasting: 0.88
        },
        data_drift_score: 0.05,
        model_drift_score: 0.03,
        active_models: 6,
        federated_participants: 12,
        privacy_budget_remaining: 0.8
      },
      model_performance: {
        student_behavior: {
          accuracy: 0.92,
          precision: 0.89,
          recall: 0.87,
          f1Score: 0.88,
          latency: { avg: 42, p95: 65, p99: 85 }
        }
      },
      federated_learning_status: {
        active_participants: 12,
        rounds_completed: 15,
        current_round: 16,
        privacy_budget_used: 0.2
      },
      insights: [
        {
          type: 'performance',
          message: 'Student behavior model showing excellent accuracy',
          severity: 'info' as const,
          recommendations: ['Continue current training schedule']
        }
      ]
    };

    beforeEach(() => {
      mockModelMonitoring.getPerformanceReport = jest.fn().mockResolvedValue(sampleAnalytics.model_performance);

      const mockFederatedLearning = service['federatedLearning'] as any;
      mockFederatedLearning.getStatus = jest.fn().mockResolvedValue(sampleAnalytics.federated_learning_status);
    });

    it('should return comprehensive analytics', async () => {
      const result = await service.getAnalytics();

      expect(result).toMatchObject({
        performance_metrics: expect.any(Object),
        model_performance: expect.any(Object),
        federated_learning_status: expect.any(Object),
        insights: expect.any(Array)
      });
    });

    it('should filter analytics by school ID', async () => {
      const schoolId = 'school-123';
      await service.getAnalytics(schoolId);

      expect(mockModelMonitoring.getPerformanceReport).toHaveBeenCalledWith(
        schoolId,
        undefined
      );
    });

    it('should include privacy metrics when requested', async () => {
      const mockFederatedLearning = service['federatedLearning'] as jest.Mocked<FederatedLearningService>;
      mockFederatedLearning.getPrivacyMetrics = jest.fn().mockResolvedValue({
        totalEpsilonSpent: 2.0,
        totalDeltaSpent: 1e-4,
        remainingBudget: { epsilon: 8.0, delta: 9e-4 }
      });

      const result = await service.getAnalytics(undefined, undefined, true);

      expect(result.privacy_metrics).toBeDefined();
      expect(mockFederatedLearning.getPrivacyMetrics).toHaveBeenCalled();
    });

    it('should filter analytics by time range', async () => {
      const timeRange = {
        start: new Date('2024-01-01'),
        end: new Date('2024-01-31')
      };

      await service.getAnalytics(undefined, timeRange);

      expect(mockModelMonitoring.getPerformanceReport).toHaveBeenCalledWith(
        undefined,
        timeRange
      );
    });
  });

  describe('Model Retraining', () => {
    beforeEach(() => {
      mockModelMonitoring.checkDrift = jest.fn().mockResolvedValue(0.15); // Above threshold

      // Mock AutoML
      const mockAutoML = service['autoML'] as jest.Mocked<AutoMLService>;
      mockAutoML.optimizeConfiguration = jest.fn().mockResolvedValue({
        algorithm: 'neural_network',
        hyperparameters: { learning_rate: 0.001 }
      });

      // Mock database query
      service['db'].query = jest.fn().mockResolvedValue([
        { id: 1, features: {}, target: {} },
        { id: 2, features: {}, target: {} }
      ]);

      // Mock A/B testing setup
      mockRealtimePrediction.setupABTest = jest.fn().mockResolvedValue(undefined);
    });

    it('should trigger retraining when drift detected', async () => {
      const trainModelSpy = jest.spyOn(service, 'trainModel');
      trainModelSpy.mockResolvedValue('new_model_123');

      const result = await service.retrain('student_behavior', 'school-123');

      expect(result).toBe('new_model_123');
      expect(mockModelMonitoring.checkDrift).toHaveBeenCalledWith('student_behavior', 'school-123');
      expect(trainModelSpy).toHaveBeenCalled();
    });

    it('should skip retraining when drift is below threshold', async () => {
      mockModelMonitoring.checkDrift = jest.fn().mockResolvedValue(0.05); // Below threshold

      const result = await service.retrain('student_behavior', 'school-123');

      expect(result).toBe('not_needed');
    });

    it('should force retraining when requested', async () => {
      mockModelMonitoring.checkDrift = jest.fn().mockResolvedValue(0.05); // Below threshold
      const trainModelSpy = jest.spyOn(service, 'trainModel');
      trainModelSpy.mockResolvedValue('forced_model_123');

      const result = await service.retrain('student_behavior', 'school-123', true);

      expect(result).toBe('forced_model_123');
      expect(trainModelSpy).toHaveBeenCalled();
    });

    it('should setup A/B testing for new model', async () => {
      const trainModelSpy = jest.spyOn(service, 'trainModel');
      trainModelSpy.mockResolvedValue('new_model_456');

      await service.retrain('student_behavior', 'school-123');

      expect(mockRealtimePrediction.setupABTest).toHaveBeenCalledWith({
        modelType: 'student_behavior',
        currentModelId: expect.any(String),
        newModelId: 'new_model_456',
        trafficSplit: 0.1
      });
    });
  });

  describe('Recommendations', () => {
    const sampleRecommendations = [
      {
        type: 'meal_suggestion',
        title: 'Recommended Meal',
        description: 'Based on your preferences, we suggest trying the vegetarian pasta',
        impact_score: 0.8,
        confidence: 0.85,
        actions: [
          {
            action: 'add_to_favorites',
            parameters: { meal_id: 'pasta_123' }
          }
        ],
        explanation: 'This recommendation is based on your dietary preferences and past choices'
      }
    ];

    beforeEach(() => {
      mockRecommendationEngine.getPersonalizedRecommendations = jest.fn().mockResolvedValue(sampleRecommendations);
    });

    it('should get personalized recommendations', async () => {
      const result = await service.getRecommendations(
        'user-123',
        'student',
        'school-123',
        { current_meal_time: 'lunch' }
      );

      expect(result).toEqual(sampleRecommendations);
      expect(mockRecommendationEngine.getPersonalizedRecommendations).toHaveBeenCalledWith({
        userId: 'user-123',
        userType: 'student',
        schoolId: 'school-123',
        context: { current_meal_time: 'lunch' },
        includeExplanations: true
      });
    });

    it('should handle different user types', async () => {
      await service.getRecommendations('user-456', 'parent', 'school-123');

      expect(mockRecommendationEngine.getPersonalizedRecommendations).toHaveBeenCalledWith({
        userId: 'user-456',
        userType: 'parent',
        schoolId: 'school-123',
        context: {},
        includeExplanations: true
      });
    });
  });

  describe('Error Handling', () => {
    it('should handle service unavailability gracefully', async () => {
      mockRealtimePrediction.predict = jest.fn().mockRejectedValue(new Error('Service unavailable'));

      const request = {
        modelType: 'student_behavior' as const,
        schoolId: 'school-123',
        inputData: { test: 'data' }
      };

      await expect(service.predict(request)).rejects.toThrow('Service unavailable');
    });

    it('should handle timeout errors', async () => {
      jest.setTimeout(1000);

      mockRealtimePrediction.predict = jest.fn().mockImplementation(
        () => new Promise((resolve) => setTimeout(resolve, 2000))
      );

      const request = {
        modelType: 'student_behavior' as const,
        schoolId: 'school-123',
        inputData: { test: 'data' }
      };

      // This would timeout in a real scenario
      await expect(service.predict(request)).rejects.toThrow();
    });
  });
});