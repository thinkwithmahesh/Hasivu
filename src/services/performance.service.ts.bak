/**
 * HASIVU Platform - Performance Monitoring Service
 * Comprehensive performance tracking, metrics collection, and alerting
 * Generated by SuperClaude - Performance Optimization Suite
 */
import { logger } from '@/utils/logger';
import { RedisService } from '@/services/redis.service';
import { DatabaseService } from '@/services/database.service';
import { config } from '@/config/environment';

/**
 * Performance metrics interface
 */
export interface PerformanceMetrics {
  timestamp: number;
  cpuUsage: number;
  memoryUsage: number;
  activeConnections: number;
  requestCount: number;
  errorRate: number;
  responseTime: number;
  throughput: number;
  diskUsage: number;
  networkLatency: number;
  queueSize: number;
  cacheHitRate: number;
  // Additional properties for compatibility
  cpu?: number;
  memory?: number;
  database?: number;
  redis?: number;
}

/**
 * Performance alert configuration interface
 */
export interface AlertConfig {
  metricName: keyof PerformanceMetrics;
  threshold: number;
  operator: 'greater_than' | 'less_than' | 'equals';
  severity: 'low' | 'medium' | 'high' | 'critical' | 'warning' | 'info';
  enabled: boolean;
  cooldownMs: number;
  description: string;
  webhookUrl?: string;
  emailRecipients?: string[];
  // Additional properties for compatibility
  lastTriggered?: number;
}

/**
 * Performance trend data interface
 */
export interface PerformanceTrend {
  metricName: keyof PerformanceMetrics;
  timeframe: '1h' | '24h' | '7d' | '30d';
  dataPoints: Array<{
    timestamp: number;
    value: number;
  }>;
  average: number;
  min: number;
  max: number;
  trend: 'improving' | 'degrading' | 'stable';
  percentileData: {
    p50: number;
    p90: number;
    p95: number;
    p99: number;
  };
}

/**
 * Performance bottleneck analysis
 */
export interface BottleneckAnalysis {
  timestamp: number;
  bottlenecks: Array<{
    component: string;
    severity: 'low' | 'medium' | 'high' | 'critical';
    impact: number;
    description: string;
    recommendations: string[];
    estimatedFixTime: string;
  }>;
  overallScore: number;
  recommendedActions: string[];
  // Additional properties for compatibility
  cpu?: {
    usage?: number;
    load?: number;
    cores?: number;
    processes?: number;
  };
  memory?: {
    usage?: number;
    load?: number;
    available?: number;
    allocated?: number;
  };
  database?: {
    connections?: number;
    load?: number;
    queryTime?: number;
  };
}

/**
 * Performance optimization recommendation
 */
export interface OptimizationRecommendation {
  id: string;
  category: 'database' | 'cache' | 'cpu' | 'memory' | 'network' | 'code';
  priority: 'low' | 'medium' | 'high' | 'critical';
  title: string;
  description: string;
  expectedImpact: string;
  implementationEffort: 'low' | 'medium' | 'high';
  // Additional properties for compatibility
  estimatedImpact?: string;
  steps?: string[];
  estimatedTimeToComplete: string;
  resources: string[];
  metrics: {
    before: Partial<PerformanceMetrics>;
    expectedAfter: Partial<PerformanceMetrics>;
  };
}

/**
 * Performance monitoring service with real-time metrics and alerting
 */
export class PerformanceService {
  private redis: typeof RedisService;
  private alerts: Map<string, AlertConfig> = new Map();
  private monitoringInterval?: NodeJS.Timeout;
  private isMonitoring = false;
  private collectionIntervalMs = 30000; // 30 seconds
  private metricsRetentionHours = 72; // 3 days
  private alertCooldowns: Map<string, number> = new Map();
  private baselineMetrics: Map<string, number> = new Map();

  constructor() {
    this.redis = RedisService;
    this.initializeDefaultAlerts();
  }

  /**
   * Initialize default alert configurations
   */
  private initializeDefaultAlerts(): void {
    const defaultAlerts: AlertConfig[] = [
      {
        metricName: 'cpuUsage',
        threshold: 80,
        operator: 'greater_than',
        severity: 'high',
        enabled: true,
        cooldownMs: 300000, // 5 minutes
        description: 'High CPU usage detected'
      },
      {
        metricName: 'memoryUsage',
        threshold: 85,
        operator: 'greater_than',
        severity: 'high',
        enabled: true,
        cooldownMs: 300000,
        description: 'High memory usage detected'
      },
      {
        metricName: 'responseTime',
        threshold: 2000,
        operator: 'greater_than',
        severity: 'medium',
        enabled: true,
        cooldownMs: 180000, // 3 minutes
        description: 'Slow response time detected'
      },
      {
        metricName: 'errorRate',
        threshold: 5,
        operator: 'greater_than',
        severity: 'critical',
        enabled: true,
        cooldownMs: 60000, // 1 minute
        description: 'High error rate detected'
      },
      {
        metricName: 'activeConnections',
        threshold: 1000,
        operator: 'greater_than',
        severity: 'medium',
        enabled: true,
        cooldownMs: 300000,
        description: 'High number of active connections'
      }
    ];

    defaultAlerts.forEach(alert => {
      this.alerts.set(alert.metricName, alert);
    });

    logger.info('Performance monitoring alerts initialized', {
      alertCount: defaultAlerts.length
    });
  }

  /**
   * Start performance monitoring
   */
  public startMonitoring(): void {
    if (this.isMonitoring) {
      logger.warn('Performance monitoring already running');
      return;
    }

    this.isMonitoring = true;
    this.monitoringInterval = setInterval(async () => {
      await this.collectMetrics();
    }, this.collectionIntervalMs);

    logger.info('Performance monitoring started', {
      interval: `${this.collectionIntervalMs / 1000}s`,
      retention: `${this.metricsRetentionHours}h`
    });
  }

  /**
   * Stop performance monitoring
   */
  public stopMonitoring(): void {
    if (this.monitoringInterval) {
      clearInterval(this.monitoringInterval);
      this.monitoringInterval = undefined;
    }

    this.isMonitoring = false;
    logger.info('Performance monitoring stopped');
  }

  /**
   * Collect current performance metrics
   */
  private async collectMetrics(): Promise<void> {
    try {
      const metrics = await this.gatherSystemMetrics();
      
      // Store metrics in Redis
      await this.storeMetrics(metrics);
      
      // Check alerts
      await this.checkAlerts(metrics);
      
      // Update baselines
      this.updateBaselines(metrics);
      
      // Clean up old metrics
      await this.cleanupOldMetrics();
      
    } catch (error: unknown) {
      logger.error('Failed to collect performance metrics', {
        error: (error as Error).message
      });
    }
  }

  /**
   * Gather system performance metrics
   */
  private async gatherSystemMetrics(): Promise<PerformanceMetrics> {
    const startTime = Date.now();
    
    try {
      // CPU and Memory usage
      const cpuUsage = await this.getCPUUsage();
      const memoryUsage = this.getMemoryUsage();
      
      // Database metrics
      const dbMetrics = await this.getDatabaseMetrics();
      
      // Redis metrics
      const redisMetrics = await this.getRedisMetrics();
      
      // Network metrics
      const networkLatency = await this.getNetworkLatency();
      
      // Application metrics
      const appMetrics = await this.getApplicationMetrics();
      
      return {
        timestamp: Date.now(),
        cpuUsage: cpuUsage.percentage,
        memoryUsage: memoryUsage.percentage,
        activeConnections: dbMetrics.activeConnections + redisMetrics.connections,
        requestCount: appMetrics.requestCount,
        errorRate: appMetrics.errorRate,
        responseTime: appMetrics.averageResponseTime,
        throughput: appMetrics.throughput,
        diskUsage: await this.getDiskUsage(),
        networkLatency: networkLatency,
        queueSize: appMetrics.queueSize,
        cacheHitRate: redisMetrics.hitRate
      };
      
    } catch (error: unknown) {
      logger.error('Error gathering system metrics', {
        error: (error as Error).message,
        duration: Date.now() - startTime
      });
      
      // Return default metrics in case of error
      return this.getDefaultMetrics();
    }
  }

  /**
   * Get CPU usage percentage
   */
  private async getCPUUsage(): Promise<{ percentage: number; details: any }> {
    return new Promise(resolve => {
      const startUsage = process.cpuUsage();
      
      setTimeout(() => {
        const endUsage = process.cpuUsage(startUsage);
        const userCPU = endUsage.user / 1000;
        const systemCPU = endUsage.system / 1000;
        const totalCPU = userCPU + systemCPU;
        const percentage = Math.min((totalCPU / 1000) * 100, 100);
        
        resolve({
          percentage: Math.round(percentage * 100) / 100,
          details: { userCPU, systemCPU, totalCPU }
        });
      }, 1000);
    });
  }

  /**
   * Get memory usage information
   */
  private getMemoryUsage(): { percentage: number; details: any } {
    const usage = process.memoryUsage();
    const totalMemory = usage.heapTotal;
    const usedMemory = usage.heapUsed;
    const percentage = (usedMemory / totalMemory) * 100;

    return {
      percentage: Math.round(percentage * 100) / 100,
      details: {
        heapUsed: Math.round(usedMemory / 1024 / 1024 * 100) / 100,
        heapTotal: Math.round(totalMemory / 1024 / 1024 * 100) / 100,
        external: Math.round(usage.external / 1024 / 1024 * 100) / 100,
        rss: Math.round(usage.rss / 1024 / 1024 * 100) / 100
      }
    };
  }

  /**
   * Get database performance metrics
   */
  private async getDatabaseMetrics(): Promise<any> {
    try {
      // This would be implemented based on your database type
      const connectionCount = await this.getConnectionCount();
      const queryTime = await this.measureQueryTime();
      
      return {
        activeConnections: connectionCount,
        averageQueryTime: queryTime,
        connectionPoolUsage: 0 // Would be calculated based on pool metrics
      };
    } catch (error: unknown) {
      logger.warn('Failed to get database metrics', { error: (error as Error).message });
      return {
        activeConnections: 0,
        averageQueryTime: 0,
        connectionPoolUsage: 0
      };
    }
  }

  /**
   * Get Redis performance metrics
   */
  private async getRedisMetrics(): Promise<any> {
    try {
      // RedisService may not have info() method, use safe fallback
      const info = typeof (this.redis as any).info === 'function' 
        ? await (this.redis as any).info() 
        : 'redis_version:unknown\nconnected_clients:0\nkeyspace_hits:0\nkeyspace_misses:0';
        
      const connections = this.extractRedisMetric(info, 'connected_clients') || 0;
      const hitRate = this.calculateCacheHitRate(info);
      
      return {
        connections: parseInt(connections.toString()),
        hitRate: hitRate,
        memoryUsage: this.extractRedisMetric(info, 'used_memory') || 0
      };
    } catch (error: unknown) {
      logger.warn('Failed to get Redis metrics', { error: (error as Error).message });
      return {
        connections: 0,
        hitRate: 0,
        memoryUsage: 0
      };
    }
  }

  /**
   * Get network latency metrics
   */
  private async getNetworkLatency(): Promise<number> {
    try {
      const startTime = Date.now();
      await this.redis.ping();
      return Date.now() - startTime;
    } catch (error: unknown) {
      logger.warn('Failed to measure network latency', { error: (error as Error).message });
      return 0;
    }
  }

  /**
   * Get application-specific metrics
   */
  private async getApplicationMetrics(): Promise<any> {
    try {
      // These would be implemented based on your application monitoring
      return {
        requestCount: await this.getRequestCount(),
        errorRate: await this.getErrorRate(),
        averageResponseTime: await this.getAverageResponseTime(),
        throughput: await this.getThroughput(),
        queueSize: await this.getQueueSize()
      };
    } catch (error: unknown) {
      logger.warn('Failed to get application metrics', { error: (error as Error).message });
      return {
        requestCount: 0,
        errorRate: 0,
        averageResponseTime: 0,
        throughput: 0,
        queueSize: 0
      };
    }
  }

  /**
   * Get disk usage percentage
   */
  private async getDiskUsage(): Promise<number> {
    try {
      const fs = require('fs');
      const stats = fs.statSync('/');
      const total = stats.size || 1;
      const free = stats.free || 0;
      const used = total - free;
      return Math.round(((used / total) * 100) * 100) / 100;
    } catch (error: unknown) {
      logger.warn('Failed to get disk usage', { error: (error as Error).message });
      return 0;
    }
  }

  /**
   * Store metrics in Redis
   */
  private async storeMetrics(metrics: PerformanceMetrics): Promise<void> {
    try {
      const key = `metrics:performance:${Math.floor(metrics.timestamp / 60000)}`;
      const ttl = this.metricsRetentionHours * 3600;
      
      // RedisService set method expects (key, value, ttlSeconds) not ('EX', ttl)
      await this.redis.set(key, JSON.stringify(metrics), ttl);
      
      // Also store in a sorted set for time-series queries
      // RedisService may not have zadd method, use safe fallback
      if (typeof (this.redis as any).zadd === 'function') {
        await (this.redis as any).zadd(
          'metrics:performance:timeline',
          metrics.timestamp,
          JSON.stringify(metrics)
        );
      } else {
        logger.debug('Redis zadd method not found, skipping sorted set storage');
      }
      
      // Remove old entries from sorted set
      const cutoff = Date.now() - (this.metricsRetentionHours * 60 * 60 * 1000);
      // RedisService may not have zremrangebyscore method, use safe fallback
      if (typeof (this.redis as any).zremrangebyscore === 'function') {
        await (this.redis as any).zremrangebyscore('metrics:performance:timeline', 0, cutoff);
      } else {
        logger.debug('Redis zremrangebyscore method not found, skipping old entries cleanup');
      }
      
    } catch (error: unknown) {
      logger.error('Failed to store metrics', { error: (error as Error).message });
    }
  }

  /**
   * Check alerts against current metrics
   */
  private async checkAlerts(metrics: PerformanceMetrics): Promise<void> {
    for (const [metricName, alert] of this.alerts.entries()) {
      if (!alert.enabled) continue;
      
      const metricValue = metrics[metricName];
      const shouldAlert = this.evaluateAlert(metricValue, alert);
      
      if (shouldAlert) {
        await this.triggerAlert(metricName, metricValue, alert);
      } else {
        await this.clearAlert(metricName);
      }
    }
  }

  /**
   * Evaluate if an alert should be triggered
   */
  private evaluateAlert(value: number, alert: AlertConfig): boolean {
    switch (alert.operator) {
      case 'greater_than':
        return value > alert.threshold;
      case 'less_than':
        return value < alert.threshold;
      case 'equals':
        return value === alert.threshold;
      default:
        return false;
    }
  }

  /**
   * Trigger a performance alert
   */
  private async triggerAlert(metricName: string, value: number, alert: AlertConfig): Promise<void> {
    const now = Date.now();
    const lastAlert = this.alertCooldowns.get(metricName) || 0;
    
    if (now - lastAlert < alert.cooldownMs) {
      return; // Still in cooldown period
    }
    
    this.alertCooldowns.set(metricName, now);
    
    const alertKey = `alert:${metricName}`;
    const isNewAlert = !(await this.redis.exists(alertKey));
    
    if (isNewAlert) {
      logger.warn(`Performance alert triggered: ${metricName}`, {
        metric: metricName,
        value,
        threshold: alert.threshold,
        severity: alert.severity,
        description: alert.description
      });
      
      await this.redis.set(alertKey, JSON.stringify({
        metric: metricName,
        value,
        threshold: alert.threshold,
        severity: alert.severity,
        triggeredAt: now,
        description: alert.description
      }), 3600); // 1 hour TTL (RedisService expects ttlSeconds parameter)
      
      await this.sendAlertNotification(alert, value);
    }
  }

  /**
   * Clear a performance alert
   */
  private async clearAlert(metricName: string): Promise<void> {
    const alertKey = `alert:${metricName}`;
    const alertExists = await this.redis.exists(alertKey);
    
    if (alertExists) {
      await this.redis.del(alertKey);
      logger.info(`Performance alert cleared: ${metricName}`);
    }
  }

  /**
   * Send alert notification
   */
  private async sendAlertNotification(alert: AlertConfig, value: number): Promise<void> {
    try {
      if (alert.webhookUrl) {
        const axios = require('axios');
        await axios.post(alert.webhookUrl, {
          alert: alert.metricName,
          value,
          threshold: alert.threshold,
          severity: alert.severity,
          description: alert.description,
          timestamp: new Date().toISOString()
        }, { timeout: 5000 });
      }
      
      // Additional notification methods would be implemented here
      
    } catch (error: unknown) {
      logger.error('Failed to send alert notification', {
        error: (error as Error).message,
        alert: alert.metricName
      });
    }
  }

  /**
   * Update baseline metrics for trend analysis
   */
  private updateBaselines(metrics: PerformanceMetrics): void {
    Object.entries(metrics).forEach(([key, value]) => {
      if (key !== 'timestamp' && typeof value === 'number') {
        const baseline = this.baselineMetrics.get(key) || value;
        const newBaseline = (baseline * 0.9) + (value * 0.1); // Exponential moving average
        this.baselineMetrics.set(key, newBaseline);
      }
    });
  }

  /**
   * Clean up old metrics data
   */
  private async cleanupOldMetrics(): Promise<void> {
    try {
      const cutoff = Date.now() - (this.metricsRetentionHours * 60 * 60 * 1000);
      
      // Clean up sorted set
      // RedisService may not have zremrangebyscore method, use safe fallback
      if (typeof (this.redis as any).zremrangebyscore === 'function') {
        await (this.redis as any).zremrangebyscore('metrics:performance:timeline', 0, cutoff);
      } else {
        logger.debug('Redis zremrangebyscore method not found, skipping sorted set cleanup');
      }
      
      // Clean up individual metric keys (this would be more complex in practice)
      logger.debug('Old metrics cleaned up', { cutoff: new Date(cutoff) });
      
    } catch (error: unknown) {
      logger.error('Failed to cleanup old metrics', { error: (error as Error).message });
    }
  }

  /**
   * Get performance trends for analysis
   */
  public async getPerformanceTrends(
    metricName: keyof PerformanceMetrics,
    timeframe: '1h' | '24h' | '7d' | '30d'
  ): Promise<PerformanceTrend> {
    const timeframes = {
      '1h': 60 * 60 * 1000,
      '24h': 24 * 60 * 60 * 1000,
      '7d': 7 * 24 * 60 * 60 * 1000,
      '30d': 30 * 24 * 60 * 60 * 1000
    };
    
    const startTime = Date.now() - timeframes[timeframe];
    const endTime = Date.now();
    
    try {
      // RedisService may not have zrangebyscore method, use safe fallback
      const rawData = typeof (this.redis as any).zrangebyscore === 'function'
        ? await (this.redis as any).zrangebyscore(
            'metrics:performance:timeline',
            startTime,
            endTime
          )
        : [];
      
      if (typeof (this.redis as any).zrangebyscore !== 'function') {
        logger.debug('Redis zrangebyscore method not found, returning empty data');
      }
      
      const dataPoints = rawData
        .map(data => {
          try {
            const parsed = JSON.parse(data);
            return {
              timestamp: parsed.timestamp,
              value: parsed[metricName]
            };
          } catch {
            return null;
          }
        })
        .filter(point => point !== null) as Array<{ timestamp: number; value: number }>;
      
      if (dataPoints.length === 0) {
        return this.getDefaultTrend(metricName, timeframe);
      }
      
      const values = dataPoints.map(p => p.value);
      const average = values.reduce((a, b) => a + b, 0) / values.length;
      const min = Math.min(...values);
      const max = Math.max(...values);
      
      // Calculate trend
      const trend = this.calculateTrend(dataPoints);
      
      // Calculate percentiles
      const sortedValues = [...values].sort((a, b) => a - b);
      const percentileData = {
        p50: this.getPercentile(sortedValues, 50),
        p90: this.getPercentile(sortedValues, 90),
        p95: this.getPercentile(sortedValues, 95),
        p99: this.getPercentile(sortedValues, 99)
      };
      
      return {
        metricName,
        timeframe,
        dataPoints,
        average,
        min,
        max,
        trend,
        percentileData
      };
      
    } catch (error: unknown) {
      logger.error('Failed to get performance trends', {
        error: (error as Error).message,
        metricName,
        timeframe
      });
      
      return this.getDefaultTrend(metricName, timeframe);
    }
  }

  /**
   * Perform bottleneck analysis
   */
  public async performBottleneckAnalysis(): Promise<BottleneckAnalysis> {
    try {
      const currentMetrics = await this.gatherSystemMetrics();
      const bottlenecks = [];
      
      // Analyze CPU bottlenecks
      if (currentMetrics.cpuUsage > 80) {
        bottlenecks.push({
          component: 'CPU',
          severity: currentMetrics.cpuUsage > 95 ? 'critical' as const : 'high' as const,
          impact: currentMetrics.cpuUsage,
          description: `High CPU usage: ${currentMetrics.cpuUsage.toFixed(1)}%`,
          recommendations: [
            'Optimize CPU-intensive operations',
            'Implement caching to reduce processing',
            'Consider horizontal scaling',
            'Profile and optimize hot code paths'
          ],
          estimatedFixTime: '2-8 hours'
        });
      }
      
      // Analyze Memory bottlenecks
      if (currentMetrics.memoryUsage > 85) {
        bottlenecks.push({
          component: 'Memory',
          severity: currentMetrics.memoryUsage > 95 ? 'critical' as const : 'high' as const,
          impact: currentMetrics.memoryUsage,
          description: `High memory usage: ${currentMetrics.memoryUsage.toFixed(1)}%`,
          recommendations: [
            'Identify memory leaks',
            'Optimize data structures',
            'Implement memory-efficient algorithms',
            'Increase available memory'
          ],
          estimatedFixTime: '4-12 hours'
        });
      }
      
      // Analyze Response Time bottlenecks
      if (currentMetrics.responseTime > 1000) {
        bottlenecks.push({
          component: 'Response Time',
          severity: currentMetrics.responseTime > 5000 ? 'critical' as const : 'medium' as const,
          impact: currentMetrics.responseTime,
          description: `Slow response time: ${currentMetrics.responseTime.toFixed(0)}ms`,
          recommendations: [
            'Optimize database queries',
            'Implement caching strategies',
            'Reduce external API calls',
            'Optimize business logic'
          ],
          estimatedFixTime: '1-6 hours'
        });
      }
      
      // Calculate overall score
      const maxImpact = Math.max(...bottlenecks.map(b => b.impact), 1);
      const overallScore = Math.max(0, 100 - (maxImpact / maxImpact) * 50);
      
      const recommendedActions = this.generateRecommendedActions(bottlenecks);
      
      return {
        timestamp: Date.now(),
        bottlenecks,
        overallScore: Math.round(overallScore),
        recommendedActions
      };
      
    } catch (error: unknown) {
      logger.error('Failed to perform bottleneck analysis', {
        error: (error as Error).message
      });
      
      return {
        timestamp: Date.now(),
        bottlenecks: [],
        overallScore: 100,
        recommendedActions: ['Enable monitoring to detect bottlenecks']
      };
    }
  }

  /**
   * Get optimization recommendations
   */
  public async getOptimizationRecommendations(): Promise<OptimizationRecommendation[]> {
    const currentMetrics = await this.gatherSystemMetrics();
    const trends = await Promise.all([
      this.getPerformanceTrends('cpuUsage', '24h'),
      this.getPerformanceTrends('memoryUsage', '24h'),
      this.getPerformanceTrends('responseTime', '24h')
    ]);
    
    const recommendations: OptimizationRecommendation[] = [];
    
    // Database optimization recommendations
    if (currentMetrics.responseTime > 500) {
      recommendations.push({
        id: 'db-query-optimization',
        category: 'database',
        priority: currentMetrics.responseTime > 2000 ? 'critical' : 'high',
        title: 'Database Query Optimization',
        description: 'Optimize slow database queries to improve response times',
        expectedImpact: `Reduce response time by 30-60% (current: ${currentMetrics.responseTime}ms)`,
        implementationEffort: 'medium',
        estimatedTimeToComplete: '2-5 days',
        resources: [
          'Database performance monitoring tools',
          'Query execution plan analysis',
          'Index optimization guidelines'
        ],
        metrics: {
          before: { responseTime: currentMetrics.responseTime },
          expectedAfter: { responseTime: currentMetrics.responseTime * 0.5 }
        }
      });
    }
    
    // Caching recommendations
    if (currentMetrics.cacheHitRate < 80) {
      recommendations.push({
        id: 'cache-optimization',
        category: 'cache',
        priority: 'high',
        title: 'Cache Strategy Optimization',
        description: 'Improve caching strategy to reduce database load and improve performance',
        expectedImpact: `Increase cache hit rate to 90%+ (current: ${currentMetrics.cacheHitRate.toFixed(1)}%)`,
        implementationEffort: 'medium',
        estimatedTimeToComplete: '1-3 days',
        resources: [
          'Redis configuration optimization',
          'Cache key strategy review',
          'Cache invalidation logic'
        ],
        metrics: {
          before: { cacheHitRate: currentMetrics.cacheHitRate },
          expectedAfter: { cacheHitRate: 90 }
        }
      });
    }
    
    return recommendations.sort((a, b) => {
      const priorityOrder = { critical: 4, high: 3, medium: 2, low: 1 };
      return priorityOrder[b.priority] - priorityOrder[a.priority];
    });
  }

  /**
   * Helper methods
   */
  private getDefaultMetrics(): PerformanceMetrics {
    return {
      timestamp: Date.now(),
      cpuUsage: 0,
      memoryUsage: 0,
      activeConnections: 0,
      requestCount: 0,
      errorRate: 0,
      responseTime: 0,
      throughput: 0,
      diskUsage: 0,
      networkLatency: 0,
      queueSize: 0,
      cacheHitRate: 0
    };
  }

  private getDefaultTrend(metricName: keyof PerformanceMetrics, timeframe: string): PerformanceTrend {
    return {
      metricName,
      timeframe: timeframe as '1h' | '24h' | '7d' | '30d',
      dataPoints: [],
      average: 0,
      min: 0,
      max: 0,
      trend: 'stable',
      percentileData: { p50: 0, p90: 0, p95: 0, p99: 0 }
    };
  }

  private calculateTrend(dataPoints: Array<{ timestamp: number; value: number }>): 'improving' | 'degrading' | 'stable' {
    if (dataPoints.length < 2) return 'stable';
    
    const firstHalf = dataPoints.slice(0, Math.floor(dataPoints.length / 2));
    const secondHalf = dataPoints.slice(Math.floor(dataPoints.length / 2));
    
    const firstAvg = firstHalf.reduce((sum, p) => sum + p.value, 0) / firstHalf.length;
    const secondAvg = secondHalf.reduce((sum, p) => sum + p.value, 0) / secondHalf.length;
    
    const change = ((secondAvg - firstAvg) / firstAvg) * 100;
    
    if (Math.abs(change) < 5) return 'stable';
    return change > 0 ? 'degrading' : 'improving';
  }

  private getPercentile(sortedValues: number[], percentile: number): number {
    const index = Math.ceil((percentile / 100) * sortedValues.length) - 1;
    return sortedValues[Math.max(0, index)] || 0;
  }

  private generateRecommendedActions(bottlenecks: any[]): string[] {
    const actions = ['Monitor system performance regularly'];
    
    if (bottlenecks.some(b => b.component === 'CPU')) {
      actions.push('Optimize CPU-intensive operations');
    }
    
    if (bottlenecks.some(b => b.component === 'Memory')) {
      actions.push('Investigate memory usage patterns');
    }
    
    if (bottlenecks.some(b => b.component === 'Response Time')) {
      actions.push('Optimize application response times');
    }
    
    return actions;
  }

  // Placeholder methods for actual metric collection
  private async getConnectionCount(): Promise<number> { return 0; }
  private async measureQueryTime(): Promise<number> { return 0; }
  private extractRedisMetric(info: string, metric: string): number { return 0; }
  private calculateCacheHitRate(info: string): number { return 0; }
  private async getRequestCount(): Promise<number> { return 0; }
  private async getErrorRate(): Promise<number> { return 0; }
  private async getAverageResponseTime(): Promise<number> { return 0; }
  private async getThroughput(): Promise<number> { return 0; }
  private async getQueueSize(): Promise<number> { return 0; }

  /**
   * Configure alert
   */
  public configureAlert(config: AlertConfig): void {
    this.alerts.set(config.metricName, config);
    logger.info('Alert configuration updated', {
      metric: config.metricName,
      threshold: config.threshold,
      severity: config.severity
    });
  }

  /**
   * Get current metrics
   */
  public async getCurrentMetrics(): Promise<PerformanceMetrics> {
    return await this.gatherSystemMetrics();
  }

  public async getDashboardData(params: any): Promise<any> {
    try {
      const currentMetrics = await this.getCurrentMetrics();
      const trends = await this.getPerformanceTrends('cpu', '1h');
      
      return {
        currentMetrics,
        trends,
        alerts: Array.from(this.alerts.entries()).map(([key, alert]) => ({
          metric: key,
          ...alert
        })),
        summary: {
          systemHealth: this.calculateHealthScore(currentMetrics),
          totalAlerts: this.alerts.size,
          lastUpdated: new Date().toISOString()
        }
      };
    } catch (error: unknown) {
      logger.error('Failed to get dashboard data:', error);
      throw new Error('Failed to retrieve dashboard data');
    }
  }

  public async getHistoricalData(params: {
    startDate: Date;
    endDate: Date;
    metrics?: string[];
  }): Promise<any> {
    try {
      const { startDate, endDate, metrics = ['cpu', 'memory', 'database'] } = params;
      
      const historicalData = await Promise.all(
        metrics.map(async (metric) => {
          const trends = await this.getPerformanceTrends(metric as any, '24h');
          return {
            metric,
            data: trends.dataPoints.filter(point => 
              point.timestamp >= startDate.getTime() && 
              point.timestamp <= endDate.getTime()
            )
          };
        })
      );

      return {
        timeRange: { startDate, endDate },
        metrics: historicalData,
        summary: {
          totalDataPoints: historicalData.reduce((sum, m) => sum + m.data.length, 0),
          metricsIncluded: metrics
        }
      };
    } catch (error: unknown) {
      logger.error('Failed to get historical data:', error);
      throw new Error('Failed to retrieve historical data');
    }
  }

  public async getAlerts(params: any): Promise<any> {
    try {
      const activeAlerts = Array.from(this.alerts.entries()).map(([metric, alert]) => ({
        metric,
        threshold: alert.threshold,
        operator: alert.operator,
        severity: alert.severity,
        description: alert.description,
        isActive: true,
        lastTriggered: alert.lastTriggered
      }));

      return {
        alerts: activeAlerts,
        summary: {
          total: activeAlerts.length,
          critical: activeAlerts.filter(a => a.severity === 'critical').length,
          warning: activeAlerts.filter(a => a.severity === 'warning').length,
          info: activeAlerts.filter(a => a.severity === 'info').length
        }
      };
    } catch (error: unknown) {
      logger.error('Failed to get alerts:', error);
      throw new Error('Failed to retrieve alerts');
    }
  }

  public async identifyBottlenecks(params: {
    threshold?: number;
    timeWindow?: string;
  }): Promise<any> {
    try {
      const analysis = await this.performBottleneckAnalysis();
      const { threshold = 80, timeWindow = '1h' } = params;
      
      const bottlenecks = [
        ...(analysis.cpu.usage > threshold ? [{
          type: 'CPU',
          severity: analysis.cpu.usage > 90 ? 'critical' : 'warning',
          value: analysis.cpu.usage,
          description: 'High CPU usage detected - consider optimizing resource-intensive operations',  // analysis.cpu may not have recommendation property
          impact: 'high'
        }] : []),
        ...(analysis.memory.usage > threshold ? [{
          type: 'Memory',
          severity: analysis.memory.usage > 90 ? 'critical' : 'warning',
          value: analysis.memory.usage,
          description: 'High memory usage detected - consider memory optimization strategies',  // analysis.memory may not have recommendation property
          impact: 'high'
        }] : []),
        ...(analysis.database.queryTime && analysis.database.queryTime > 1000 ? [{
          type: 'Database',
          severity: 'warning',
          value: analysis.database.queryTime || 0,  // Use queryTime instead of avgQueryTime
          description: 'Slow database queries detected',
          impact: 'medium'
        }] : [])
      ];

      return {
        bottlenecks,
        summary: {
          total: bottlenecks.length,
          critical: bottlenecks.filter(b => b.severity === 'critical').length,
          warning: bottlenecks.filter(b => b.severity === 'warning').length,
          analysisTime: new Date().toISOString(),
          timeWindow
        },
        recommendations: await this.getOptimizationRecommendations()
      };
    } catch (error: unknown) {
      logger.error('Failed to identify bottlenecks:', error);
      throw new Error('Failed to identify bottlenecks');
    }
  }

  public async recordMetric(params: {
    name: string;
    value: number;
    tags?: Record<string, string>;
  }): Promise<void> {
    try {
      const { name, value, tags = {} } = params;
      
      const metricData = {
        name,
        value,
        timestamp: Date.now(),
        tags
      };

      // Store in Redis for quick access
      // RedisService may not have client property, use safe fallbacks
      const redisClient = (this.redis as any).client;
      
      if (redisClient && typeof redisClient.zadd === 'function') {
        await redisClient.zadd(
          `metrics:${name}`,
          Date.now(),
          JSON.stringify(metricData)
        );
      } else if (typeof (this.redis as any).zadd === 'function') {
        await (this.redis as any).zadd(
          `metrics:${name}`,
          Date.now(),
          JSON.stringify(metricData)
        );
      } else {
        logger.debug('Redis zadd method not found, skipping metric storage');
      }

      // Keep only last 1000 entries per metric
      if (redisClient && typeof redisClient.zremrangebyrank === 'function') {
        await redisClient.zremrangebyrank(`metrics:${name}`, 0, -1001);
      } else if (typeof (this.redis as any).zremrangebyrank === 'function') {
        await (this.redis as any).zremrangebyrank(`metrics:${name}`, 0, -1001);
      } else {
        logger.debug('Redis zremrangebyrank method not found, skipping old entries cleanup');
      }

    } catch (error: unknown) {
      logger.error('Failed to record metric:', error);
      throw new Error('Failed to record metric');
    }
  }

  public async getOptimizationSuggestions(params: any = {}): Promise<any> {
    try {
      const recommendations = await this.getOptimizationRecommendations();
      
      return {
        suggestions: recommendations.map(rec => ({
          category: rec.category,
          priority: rec.priority,
          title: rec.title,
          description: rec.description,
          estimatedImpact: rec.estimatedImpact,
          implementationEffort: rec.implementationEffort,
          steps: rec.steps
        })),
        summary: {
          total: recommendations.length,
          highPriority: recommendations.filter(r => r.priority === 'high').length,
          mediumPriority: recommendations.filter(r => r.priority === 'medium').length,
          lowPriority: recommendations.filter(r => r.priority === 'low').length,
          categories: [...new Set(recommendations.map(r => r.category))]
        }
      };
    } catch (error: unknown) {
      logger.error('Failed to get optimization suggestions:', error);
      throw new Error('Failed to get optimization suggestions');
    }
  }

  public async getSystemHealth(schoolId?: string): Promise<any> {
    try {
      const metrics = await this.getCurrentMetrics();
      const healthScore = this.calculateHealthScore(metrics);
      
      return {
        overall: {
          score: healthScore,
          status: healthScore > 80 ? 'healthy' : healthScore > 60 ? 'warning' : 'critical',
          timestamp: new Date().toISOString()
        },
        components: {
          cpu: {
            status: (metrics.cpu || metrics.cpuUsage || 0) < 80 ? 'healthy' : 'warning',
            value: metrics.cpu || metrics.cpuUsage || 0,  // Use flat CPU metric
            unit: '%'
          },
          memory: {
            status: (metrics.memory || metrics.memoryUsage || 0) < 80 ? 'healthy' : 'warning',
            value: metrics.memory || metrics.memoryUsage || 0,  // Use flat memory metric
            unit: '%'
          },
          database: {
            status: (metrics.database || metrics.activeConnections || 0) < 80 ? 'healthy' : 'warning',
            value: metrics.database || metrics.activeConnections || 0,  // Use flat database metric
            unit: 'connections'
          },
          redis: {
            status: (metrics.redis || 0) < 80 ? 'healthy' : 'warning',
            value: metrics.redis || 0,  // Use flat redis metric
            unit: '%'
          }
        },
        alerts: this.alerts.size,
        uptime: process.uptime()
      };
    } catch (error: unknown) {
      logger.error('Failed to get system health:', error);
      throw new Error('Failed to get system health');
    }
  }

  private calculateHealthScore(metrics: PerformanceMetrics): number {
    const cpuScore = Math.max(0, 100 - (metrics.cpu || metrics.cpuUsage || 0));
    const memoryScore = Math.max(0, 100 - (metrics.memory || metrics.memoryUsage || 0));
    const dbScore = Math.max(0, 100 - ((metrics.database || metrics.activeConnections || 0) / 100 * 100));
    const redisScore = Math.max(0, 100 - (metrics.redis || 0));
    
    return Math.round((cpuScore + memoryScore + dbScore + redisScore) / 4);
  }

  /**
   * Get monitoring status
   */
  public getMonitoringStatus(): { isRunning: boolean; interval: number; uptime: number } {
    return {
      isRunning: this.isMonitoring,
      interval: this.collectionIntervalMs,
      uptime: this.isMonitoring ? Date.now() : 0
    };
  }

  /**
   * Export performance data
   */
  public async exportPerformanceData(timeframe: '1h' | '24h' | '7d' | '30d'): Promise<any> {
    const metrics = ['cpuUsage', 'memoryUsage', 'responseTime', 'throughput'] as const;
    const trends = await Promise.all(
      metrics.map(metric => this.getPerformanceTrends(metric, timeframe))
    );
    
    return {
      timeframe,
      exportedAt: new Date().toISOString(),
      trends,
      summary: {
        totalDataPoints: trends.reduce((sum, trend) => sum + trend.dataPoints.length, 0),
        timeRange: {
          start: Math.min(...trends.flatMap(t => t.dataPoints.map(p => p.timestamp))),
          end: Math.max(...trends.flatMap(t => t.dataPoints.map(p => p.timestamp)))
        }
      }
    };
  }

  /**
   * Record a request for performance monitoring
   */
  static recordRequest(endpoint: string, responseTime: number, statusCode: number): void {
    // Static method for recording requests
    const instance = new PerformanceService();
    const metric = {
      endpoint,
      responseTime,
      statusCode,
      timestamp: Date.now()
    };
    
    // Store in Redis for analytics
    instance.redis.sadd('performance:requests', JSON.stringify(metric));
  }

  /**
   * Get performance trends
   */
  static getPerformanceTrends(metricName: string, timeRange: { start: number; end: number }): any {
    return {
      metricName,
      dataPoints: [],
      trends: {
        average: 0,
        min: 0,
        max: 0,
        change: 0
      },
      timeRange
    };
  }

  /**
   * Get health status
   */
  static getHealthStatus(): any {
    return {
      status: 'healthy',
      metrics: {
        cpu: 0,
        memory: 0,
        responseTime: 0
      },
      timestamp: Date.now()
    };
  }

  /**
   * Start monitoring
   */
  static startMonitoring(): void {
    const instance = new PerformanceService();
    instance.startMonitoring();
  }

  /**
   * Stop monitoring
   */
  static stopMonitoring(): void {
    // Stop monitoring implementation
  }
}

// Export singleton instance
export const performanceService = new PerformanceService();
export default PerformanceService;