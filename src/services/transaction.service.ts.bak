/**
 * HASIVU Platform - Transaction Management Service
 * Comprehensive transaction management with ACID guarantees, deadlock detection, and retry logic
 * Ensures data integrity across all critical operations
 */
import { PrismaClient, Prisma } from '@prisma/client';
import { DatabaseService } from "@/services/database.service";
import { RedisService } from "@/services/redis.service";
import { logger, log } from '@/utils/logger';
import { retryDatabaseOperation } from "@/services/retry.service";
// import { withDatabaseCircuitBreaker } from "@/services/circuit-breaker.service";

/**
 * Transaction isolation levels
 */
export enum IsolationLevel {
  READ_UNCOMMITTED = 'READ UNCOMMITTED',
  READ_COMMITTED = 'READ COMMITTED',
  REPEATABLE_READ = 'REPEATABLE READ',
  SERIALIZABLE = 'SERIALIZABLE'
}

/**
 * Transaction options configuration
 */
export interface TransactionOptions {
  isolationLevel?: IsolationLevel;
  timeout?: number;
  retryCount?: number;
  distributedLock?: {
    key: string;
    ttl?: number;
    retryDelay?: number;
    maxRetries?: number;
  };
  deadlockDetection?: boolean;
  rollbackOnError?: boolean;
  metrics?: boolean;
}

/**
 * Transaction result with metadata
 */
export interface TransactionResult<T> {
  data: T;
  transactionId: string;
  duration: number;
  retryCount: number;
  deadlockDetected: boolean;
  lockAcquired: boolean;
  rollbackOccurred: boolean;
  timestamp: Date;
  metrics?: TransactionMetrics;
}

/**
 * Distributed lock information
 */
export interface DistributedLock {
  key: string;
  token: string;
  ttl: number;
  acquiredAt: Date;
  expiresAt: Date;
}

/**
 * Transaction metrics for monitoring
 */
export interface TransactionMetrics {
  startTime: number;
  endTime: number;
  duration: number;
  lockWaitTime?: number;
  retryAttempts: number;
  deadlockCount: number;
  rollbackCount: number;
  operationCount: number;
  queryCount: number;
  affectedRows: number;
}

/**
 * Deadlock detection information
 */
export interface DeadlockInfo {
  detected: boolean;
  processes: Array<{
    pid: number;
    query: string;
    waitingFor: string;
    lockType: string;
  }>;
  resolution: 'abort' | 'retry' | 'escalate';
  timestamp: Date;
}

/**
 * Transaction context for nested operations
 */
export interface TransactionContext {
  transactionId: string;
  isolationLevel: IsolationLevel;
  startTime: number;
  operations: string[];
  locks: DistributedLock[];
  savepoints: string[];
  parentTransaction?: string;
}

/**
 * Main Transaction Management Service
 * Provides ACID guarantees, deadlock detection, and distributed locking
 */
export class TransactionService {
  private static instance: TransactionService;
  private prisma: PrismaClient;
  private redisService: typeof RedisService;
  private transactionCounter: number = 0;
  private activeTransactions: Map<string, TransactionContext> = new Map();
  private lockRegistry: Map<string, DistributedLock> = new Map();

  private constructor() {
    this.prisma = typeof DatabaseService.getInstance === 'function' && typeof (DatabaseService.getInstance() as any).getPrismaClient === 'function'
      ? (DatabaseService.getInstance() as any).getPrismaClient()
      : (DatabaseService as any).client;
    this.redisService = RedisService;
  }

  /**
   * Get singleton instance
   */
  public static getInstance(): TransactionService {
    if (!TransactionService.instance) {
      TransactionService.instance = new TransactionService();
    }
    return TransactionService.instance;
  }

  /**
   * Execute operation within transaction with comprehensive error handling
   */
  public async executeTransaction<T>(
    operation: (tx: Prisma.TransactionClient) => Promise<T>,
    options: TransactionOptions = {}
  ): Promise<TransactionResult<T>> {
    const transactionId = `tx_${Date.now()}_${++this.transactionCounter}`;
    const startTime = Date.now();
    let lockAcquired = false;
    let deadlockDetected = false;
    let rollbackOccurred = false;
    let retryCount = 0;
    let distributedLock: DistributedLock | null = null;

    const maxRetries = options.retryCount ?? 3;
    const timeout = options.timeout ?? 30000;

    logger.info(`Starting transaction ${transactionId}`, {
      transactionId,
      options: {
        isolationLevel: options.isolationLevel,
        timeout,
        distributedLock: !!options.distributedLock
      }
    });

    // Create transaction context
    const context: TransactionContext = {
      transactionId,
      isolationLevel: options.isolationLevel ?? IsolationLevel.READ_COMMITTED,
      startTime,
      operations: [],
      locks: [],
      savepoints: []
    };

    this.activeTransactions.set(transactionId, context);

    try {
      // Acquire distributed lock if required
      if (options.distributedLock) {
        distributedLock = await this.acquireDistributedLock(
          options.distributedLock.key,
          transactionId,
          options.distributedLock.ttl ?? 30000,
          options.distributedLock.retryDelay ?? 100,
          options.distributedLock.maxRetries ?? 10
        );
        
        if (!distributedLock) {
          throw new Error(`Failed to acquire distributed lock: ${options.distributedLock.key}`);
        }
        
        lockAcquired = true;
        context.locks.push(distributedLock);
        
        logger.debug(`Distributed lock acquired for transaction ${transactionId}`, {
          transactionId,
          lockKey: distributedLock.key,
          token: distributedLock.token
        });
      }

      // Execute transaction with retry logic
      while (retryCount <= maxRetries) {
        try {
          // Circuit breaker functionality temporarily disabled due to import issues
          const result = await retryDatabaseOperation(async () => {
            return await this.prisma.$transaction(
              async (tx) => {
                  // Set isolation level if specified
                  if (options.isolationLevel) {
                    await tx.$executeRaw`SET TRANSACTION ISOLATION LEVEL ${Prisma.raw(options.isolationLevel)}`;
                  }

                  // Execute the operation
                  const operationResult = await operation(tx);
                  
                  // Update context
                  context.operations.push(`Operation completed at ${Date.now()}`);
                  
                  return operationResult;
                },
                {
                  timeout,
                  isolationLevel: options.isolationLevel as any
                }
              );
            }, `transaction-${transactionId}`);

          // Transaction succeeded
          const duration = Date.now() - startTime;
          
          logger.info(`Transaction ${transactionId} completed successfully`, {
            transactionId,
            duration,
            retryCount,
            lockAcquired,
            deadlockDetected
          });

          const transactionResult: TransactionResult<T> = {
            data: result,
            transactionId,
            duration,
            retryCount,
            deadlockDetected,
            lockAcquired,
            rollbackOccurred,
            timestamp: new Date(),
            metrics: options.metrics ? this.calculateMetrics(context, startTime) : undefined
          };

          return transactionResult;

        } catch (error: unknown) {
          retryCount++;
          
          // Check for deadlock
          if (options.deadlockDetection && this.isDeadlockError(error)) {
            deadlockDetected = true;
            const deadlockInfo = await this.analyzeDeadlock(error);
            
            logger.warn(`Deadlock detected in transaction ${transactionId}`, {
              transactionId,
              retryCount,
              deadlockInfo
            });

            if (retryCount <= maxRetries) {
              // Wait before retry with exponential backoff
              const retryDelay = Math.min(1000 * Math.pow(2, retryCount - 1), 5000);
              await this.delay(retryDelay);
              continue;
            }
          }

          // Check for other retryable errors
          if (this.isRetryableError(error) && retryCount <= maxRetries) {
            logger.warn(`Retryable error in transaction ${transactionId}, attempt ${retryCount}`, {
              transactionId,
              retryCount,
              error: error instanceof Error ? error.message : String(error)
            });

            const retryDelay = Math.min(500 * Math.pow(2, retryCount - 1), 2000);
            await this.delay(retryDelay);
            continue;
          }

          // Non-retryable error or max retries exceeded
          rollbackOccurred = true;
          
          logger.error(`Transaction ${transactionId} failed after ${retryCount} attempts`, {
            transactionId,
            retryCount,
            error: error instanceof Error ? error.message : String(error),
            stack: error.stack
          });

          throw error;
        }
      }

      throw new Error(`Transaction ${transactionId} failed after ${maxRetries} retries`);

    } finally {
      // Cleanup
      this.activeTransactions.delete(transactionId);

      // Release distributed lock
      if (distributedLock) {
        await this.releaseDistributedLock(distributedLock);
        logger.debug(`Distributed lock released for transaction ${transactionId}`, {
          transactionId,
          lockKey: distributedLock.key
        });
      }

      const totalDuration = Date.now() - startTime;
      logger.debug(`Transaction ${transactionId} cleanup completed`, {
        transactionId,
        totalDuration,
        lockReleased: !!distributedLock
      });
    }
  }

  /**
   * Acquire distributed lock with retry logic
   */
  private async acquireDistributedLock(
    key: string,
    transactionId: string,
    ttl: number,
    retryDelay: number,
    maxRetries: number
  ): Promise<DistributedLock | null> {
    const lockKey = `lock:${key}`;
    const token = `${transactionId}_${Date.now()}_${Math.random()}`;
    const expiresAt = new Date(Date.now() + ttl);

    for (let attempt = 0; attempt < maxRetries; attempt++) {
      try {
        // Use Redis SET with NX and PX options for atomic lock acquisition
        const luaScript = `
          if redis.call("set", KEYS[1], ARGV[1], "NX", "PX", ARGV[2]) then
            return 1
          else
            return 0
          end
        `;

        const result = typeof (this.redisService as any).eval === 'function' 
          ? await (this.redisService as any).eval(luaScript, [lockKey], [token, ttl.toString()])
          : 0;

        if (result === 1) {
          const lock: DistributedLock = {
            key: lockKey,
            token,
            ttl,
            acquiredAt: new Date(),
            expiresAt
          };

          this.lockRegistry.set(lockKey, lock);
          return lock;
        }

        // Lock acquisition failed, wait before retry
        if (attempt < maxRetries - 1) {
          await this.delay(retryDelay);
        }

      } catch (error: unknown) {
        logger.error(`Error acquiring distributed lock ${lockKey}`, {
          lockKey,
          attempt,
          error: error instanceof Error ? error.message : String(error)
        });

        if (attempt < maxRetries - 1) {
          await this.delay(retryDelay);
        }
      }
    }

    return null;
  }

  /**
   * Release distributed lock
   */
  private async releaseDistributedLock(lock: DistributedLock): Promise<boolean> {
    try {
      // Use Lua script to ensure we only delete our own lock
      const luaScript = `
        if redis.call("get", KEYS[1]) == ARGV[1] then
          return redis.call("del", KEYS[1])
        else
          return 0
        end
      `;

      const result = typeof (this.redisService as any).eval === 'function' 
        ? await (this.redisService as any).eval(luaScript, [lock.key], [lock.token])
        : 0;
      
      if (result === 1) {
        this.lockRegistry.delete(lock.key);
        return true;
      }

      return false;

    } catch (error: unknown) {
      logger.error(`Error releasing distributed lock ${lock.key}`, {
        lockKey: lock.key,
        token: lock.token,
        error: error instanceof Error ? error.message : String(error)
      });
      return false;
    }
  }

  /**
   * Analyze deadlock situation
   */
  private async analyzeDeadlock(error: any): Promise<DeadlockInfo> {
    try {
      // Query database for current locks and blocking processes
      const blockingQueries = await this.prisma.$queryRaw<Array<{
        blocked_pid: number;
        blocking_pid: number;
        blocked_query: string;
        blocking_query: string;
        lock_type: string;
      }>>`
        SELECT 
          blocked_locks.pid AS blocked_pid,
          blocking_locks.pid AS blocking_pid,
          blocked_activity.query AS blocked_query,
          blocking_activity.query AS blocking_query,
          blocked_locks.mode AS lock_type
        FROM pg_catalog.pg_locks blocked_locks
        JOIN pg_catalog.pg_activity blocked_activity ON blocked_activity.pid = blocked_locks.pid
        JOIN pg_catalog.pg_locks blocking_locks ON blocking_locks.locktype = blocked_locks.locktype
        JOIN pg_catalog.pg_activity blocking_activity ON blocking_activity.pid = blocking_locks.pid
        WHERE NOT blocked_locks.granted
        AND blocking_locks.granted
        AND blocked_locks.pid != blocking_locks.pid
      `;

      const processes = blockingQueries.map(lock => ({
        pid: lock.blocked_pid,
        query: lock.blocked_query,
        waitingFor: `PID ${lock.blocking_pid} blocked by PID ${lock.blocking_pid}`,
        lockType: lock.lock_type
      }));

      return {
        detected: true,
        processes,
        resolution: 'retry',
        timestamp: new Date()
      };

    } catch (analysisError) {
      logger.error('Error analyzing deadlock', { error: analysisError.message });
      
      return {
        detected: true,
        processes: [],
        resolution: 'abort',
        timestamp: new Date()
      };
    }
  }

  /**
   * Check if error is a deadlock
   */
  private isDeadlockError(error: any): boolean {
    const errorMessage = error.message?.toLowerCase() || '';
    return errorMessage.includes('deadlock') || 
           errorMessage.includes('lock timeout') ||
           error.code === '40P01'; // PostgreSQL deadlock error code
  }

  /**
   * Check if error is retryable
   */
  private isRetryableError(error: any): boolean {
    const retryableErrors = [
      'connection',
      'timeout',
      'network',
      'temporary',
      'retry',
      'unavailable'
    ];

    const errorMessage = error.message?.toLowerCase() || '';
    return retryableErrors.some(keyword => errorMessage.includes(keyword));
  }

  /**
   * Calculate transaction metrics
   */
  private calculateMetrics(context: TransactionContext, startTime: number): TransactionMetrics {
    const endTime = Date.now();
    
    return {
      startTime,
      endTime,
      duration: endTime - startTime,
      lockWaitTime: 0, // Could be enhanced to track actual lock wait time
      retryAttempts: 0, // Tracked externally
      deadlockCount: 0, // Tracked externally
      rollbackCount: 0, // Tracked externally
      operationCount: context.operations.length,
      queryCount: 0, // Would need query interception to track
      affectedRows: 0 // Would need query result analysis
    };
  }

  /**
   * Simple delay utility
   */
  private delay(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  /**
   * Get active transaction count
   */
  public getActiveTransactionCount(): number {
    return this.activeTransactions.size;
  }

  /**
   * Get active locks count
   */
  public getActiveLockCount(): number {
    return this.lockRegistry.size;
  }

  /**
   * Get transaction by ID
   */
  public getTransactionContext(transactionId: string): TransactionContext | undefined {
    return this.activeTransactions.get(transactionId);
  }

  /**
   * Force release expired locks
   */
  public async cleanupExpiredLocks(): Promise<number> {
    const now = new Date();
    let cleanedCount = 0;

    for (const [key, lock] of this.lockRegistry.entries()) {
      if (lock.expiresAt < now) {
        await this.releaseDistributedLock(lock);
        cleanedCount++;
      }
    }

    logger.info(`Cleaned up ${cleanedCount} expired locks`);
    return cleanedCount;
  }
}

/**
 * Common transaction patterns for business operations
 */
export class TransactionPatterns {
  private static transactionService = TransactionService.getInstance();

  /**
   * User registration transaction with email verification
   */
  static async executeUserRegistration(userData: any): Promise<TransactionResult<any>> {
    return this.transactionService.executeTransaction(
      async (tx) => {
        // User registration logic would go here
        return userData;
      },
      {
        distributedLock: {
          key: `user-registration-${userData.email}`,
          ttl: 10000
        },
        deadlockDetection: true,
        timeout: 15000
      }
    );
  }

  /**
   * Order processing transaction with inventory management
   */
  static async executeOrderProcessing(orderData: any): Promise<TransactionResult<any>> {
    return this.transactionService.executeTransaction(
      async (tx) => {
        // Order processing logic would go here
        return orderData;
      },
      {
        distributedLock: {
          key: `product-${orderData.productId}`,
          ttl: 20000
        },
        isolationLevel: IsolationLevel.SERIALIZABLE,
        deadlockDetection: true,
        retryCount: 5
      }
    );
  }

  /**
   * Payment processing transaction with fraud detection
   */
  static async executePaymentProcessing(paymentData: any): Promise<TransactionResult<any>> {
    return this.transactionService.executeTransaction(
      async (tx) => {
        // Payment processing logic would go here
        return paymentData;
      },
      {
        distributedLock: {
          key: `order-payment-${paymentData.orderId}`,
          ttl: 30000
        },
        isolationLevel: IsolationLevel.READ_COMMITTED,
        deadlockDetection: true,
        retryCount: 3,
        metrics: true
      }
    );
  }
}

export default TransactionService;