/**
 * HASIVU Platform - Redis Service
 * Redis caching service with health monitoring
 * Implements comprehensive caching operations
 * Generated by SuperClaude Wave 3: Epic 3 Implementation - INFRASTRUCTURE
 */
import { logger } from '../utils/logger';

/**
 * Redis health status interface
 */
export interface RedisHealth {
  status: 'healthy' | 'degraded' | 'unhealthy';
  responseTime: number;
  connected: boolean;
  errors: string[];
}

/**
 * Simple in-memory cache implementation that mimics Redis interface
 * Used for development and testing when Redis is not available
 */
class RedisService {
  private static instance: RedisService;
  private cache: Map<string, { value: string; expiry?: number }>;
  private connected: boolean;

  constructor() {
    this.cache = new Map();
    this.connected = false;
  }

  /**
   * Get singleton instance
   */
  public static getInstance(): RedisService {
    if (!RedisService.instance) {
      RedisService.instance = new RedisService();
    }
    return RedisService.instance;
  }

  /**
   * Static connect method for backward compatibility
   */
  public static async connect(): Promise<void> {
    return RedisService.getInstance().connect();
  }

  /**
   * Connect to Redis (mock implementation)
   */
  async connect(): Promise<void> {
    try {
      this.connected = true;
      logger.info('Redis service initialized (mock)');
    } catch (error: unknown) {
      logger.error('Failed to initialize Redis service', error);
      throw error;
    }
  }

  /**
   * Disconnect from Redis
   */
  async disconnect(): Promise<void> {
    try {
      this.connected = false;
      this.cache.clear();
      logger.info('Redis service disconnected');
    } catch (error: unknown) {
      logger.error('Failed to disconnect Redis service', error);
      throw error;
    }
  }

  /**
   * Get value from cache
   */
  async get(key: string): Promise<string | null> {
    try {
      const item = this.cache.get(key);
      
      if (!item) {
        return null;
      }

      // Check if expired
      if (item.expiry && Date.now() > item.expiry) {
        this.cache.delete(key);
        return null;
      }

      return item.value;
    } catch (error: unknown) {
      logger.error('Redis GET operation failed', error, { key });
      return null;
    }
  }

  /**
   * Set value in cache
   */
  async set(key: string, value: string, ttlSeconds?: number): Promise<string> {
    try {
      const expiry = ttlSeconds ? Date.now() + (ttlSeconds * 1000) : undefined;
      this.cache.set(key, { value, expiry });
      
      logger.debug('Redis SET operation completed', { key, ttl: ttlSeconds });
      return 'OK';
    } catch (error: unknown) {
      logger.error('Redis SET operation failed', error, { key });
      throw error;
    }
  }

  /**
   * Set value with expiration (in seconds)
   */
  async setex(key: string, seconds: number, value: string): Promise<string> {
    return this.set(key, value, seconds);
  }

  /**
   * Delete key from cache
   */
  async del(key: string): Promise<number> {
    try {
      const existed = this.cache.has(key);
      this.cache.delete(key);
      
      logger.debug('Redis DEL operation completed', { key, existed });
      return existed ? 1 : 0;
    } catch (error: unknown) {
      logger.error('Redis DEL operation failed', error, { key });
      return 0;
    }
  }

  /**
   * Check if key exists
   */
  async exists(key: string): Promise<number> {
    try {
      const item = this.cache.get(key);
      
      if (!item) {
        return 0;
      }

      // Check if expired
      if (item.expiry && Date.now() > item.expiry) {
        this.cache.delete(key);
        return 0;
      }

      return 1;
    } catch (error: unknown) {
      logger.error('Redis EXISTS operation failed', error, { key });
      return 0;
    }
  }

  /**
   * Set expiration for key
   */
  async expire(key: string, seconds: number): Promise<number> {
    try {
      const item = this.cache.get(key);
      
      if (!item) {
        return 0;
      }

      const expiry = Date.now() + (seconds * 1000);
      this.cache.set(key, { ...item, expiry });
      
      logger.debug('Redis EXPIRE operation completed', { key, seconds });
      return 1;
    } catch (error: unknown) {
      logger.error('Redis EXPIRE operation failed', error, { key });
      return 0;
    }
  }

  /**
   * Get time to live for key
   */
  async ttl(key: string): Promise<number> {
    try {
      const item = this.cache.get(key);
      
      if (!item) {
        return -2; // Key does not exist
      }

      if (!item.expiry) {
        return -1; // Key exists but has no expiration
      }

      const remaining = Math.ceil((item.expiry - Date.now()) / 1000);
      return remaining > 0 ? remaining : -2;
    } catch (error: unknown) {
      logger.error('Redis TTL operation failed', error, { key });
      return -2;
    }
  }

  /**
   * Increment value
   */
  async incr(key: string): Promise<number> {
    try {
      const current = await this.get(key);
      const value = current ? parseInt(current) + 1 : 1;
      
      await this.set(key, value.toString());
      
      logger.debug('Redis INCR operation completed', { key, value });
      return value;
    } catch (error: unknown) {
      logger.error('Redis INCR operation failed', error, { key });
      throw error;
    }
  }

  /**
   * Decrement value
   */
  async decr(key: string): Promise<number> {
    try {
      const current = await this.get(key);
      const value = current ? parseInt(current) - 1 : -1;
      
      await this.set(key, value.toString());
      
      logger.debug('Redis DECR operation completed', { key, value });
      return value;
    } catch (error: unknown) {
      logger.error('Redis DECR operation failed', error, { key });
      throw error;
    }
  }

  /**
   * Add to set
   */
  async sadd(key: string, ...members: string[]): Promise<number> {
    try {
      const current = await this.get(key);
      const set = current ? new Set(JSON.parse(current)) : new Set();
      
      let added = 0;
      members.forEach(member => {
        if (!set.has(member)) {
          set.add(member);
          added++;
        }
      });
      
      await this.set(key, JSON.stringify(Array.from(set)));
      
      logger.debug('Redis SADD operation completed', { key, added });
      return added;
    } catch (error: unknown) {
      logger.error('Redis SADD operation failed', error, { key });
      throw error;
    }
  }

  /**
   * Get set members
   */
  async smembers(key: string): Promise<string[]> {
    try {
      const current = await this.get(key);
      return current ? JSON.parse(current) : [];
    } catch (error: unknown) {
      logger.error('Redis SMEMBERS operation failed', error, { key });
      return [];
    }
  }

  /**
   * Check if member exists in set
   */
  async sismember(key: string, member: string): Promise<number> {
    try {
      const members = await this.smembers(key);
      return members.includes(member) ? 1 : 0;
    } catch (error: unknown) {
      logger.error('Redis SISMEMBER operation failed', error, { key });
      return 0;
    }
  }

  /**
   * Get cache statistics
   */
  getStats(): { size: number; connected: boolean } {
    return {
      size: this.cache.size,
      connected: this.connected
    };
  }

  /**
   * Clear all cache
   */
  async flushall(): Promise<string> {
    try {
      this.cache.clear();
      logger.info('Redis cache cleared');
      return 'OK';
    } catch (error: unknown) {
      logger.error('Redis FLUSHALL operation failed', error);
      throw error;
    }
  }

  /**
   * Call Redis command (generic method for unsupported commands)
   */
  async call(command: string, ...args: string[]): Promise<any> {
    // This is a mock implementation - in a real Redis client, this would execute the command
    logger.debug('Redis CALL operation', { command, args });
    return null;
  }

  /**
   * Add to sorted set
   */
  async zadd(key: string, score: number, member: string): Promise<number> {
    try {
      // Mock implementation for sorted set
      const current = await this.get(key);
      const set = current ? JSON.parse(current) : {};
      set[member] = score;
      await this.set(key, JSON.stringify(set));
      return 1;
    } catch (error: unknown) {
      logger.error('Redis ZADD operation failed', error, { key });
      throw error;
    }
  }

  /**
   * Get keys matching a pattern
   */
  async keys(pattern: string): Promise<string[]> {
    try {
      const matchingKeys: string[] = [];
      const regex = new RegExp(pattern.replace(/\*/g, '.*').replace(/\?/g, '.'));

      for (const key of this.cache.keys()) {
        if (regex.test(key)) {
          matchingKeys.push(key);
        }
      }

      return matchingKeys;
    } catch (error: unknown) {
      logger.error('Redis KEYS operation failed', error, { pattern });
      return [];
    }
  }

  /**
   * Test connection and get health status
   */
  async ping(): Promise<string> {
    return 'PONG';
  }

  /**
   * Get health status
   */
  async getHealth(): Promise<RedisHealth> {
    const startTime = Date.now();
    
    try {
      await this.ping();
      const responseTime = Date.now() - startTime;
      
      return {
        status: 'healthy',
        responseTime,
        connected: this.connected,
        errors: []
      };
    } catch (error: unknown) {
      const responseTime = Date.now() - startTime;
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';
      
      return {
        status: 'unhealthy',
        responseTime,
        connected: false,
        errors: [errorMessage]
      };
    }
  }

  /**
   * Cleanup expired keys (called periodically)
   */
  private cleanupExpired(): void {
    const now = Date.now();
    const expiredKeys: string[] = [];
    
    this.cache.forEach((item, key) => {
      if (item.expiry && now > item.expiry) {
        expiredKeys.push(key);
      }
    });
    
    expiredKeys.forEach(key => {
      this.cache.delete(key);
    });
    
    if (expiredKeys.length > 0) {
      logger.debug('Cleaned up expired cache keys', { count: expiredKeys.length });
    }
  }
}

// Create and export singleton instance
const redisService = new RedisService();

// Start periodic cleanup
setInterval(() => {
  (redisService as any).cleanupExpired();
}, 60000); // Run every minute

export { redisService as RedisService };
export default redisService;