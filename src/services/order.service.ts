/**
 * HASIVU Platform - Order Management Service
 * Business logic layer for parent ordering system
 * Implements Epic 3: Parent Ordering System with comprehensive features
 * Generated by SuperClaude Wave 3: Epic 3 Implementation - COMPREHENSIVE
 */
import { Order, OrderItem, PaymentOrder, DeliveryVerification, Prisma } from '@prisma/client';
import { OrderRepository } from '../repositories/order.repository';
import { OrderItemRepository } from '../repositories/orderItem.repository';
import { PaymentOrderRepository } from '../repositories/paymentOrder.repository';
import { MenuItemRepository } from '../repositories/menuItem.repository';
import { UserRepository } from '../repositories/user.repository';
import { DatabaseService } from './database.service';
import { PaymentService } from './payment.service';
import { NotificationService } from './notification.service';
import { RedisService } from './redis.service';
import { logger } from '../utils/logger';
import { cache } from '../utils/cache';
import { v4 as uuidv4 } from 'uuid';

/**
 * Order status enum (local definition for missing Prisma export)
 */
export enum OrderStatus {
  PENDING = 'PENDING',
  CONFIRMED = 'CONFIRMED',
  PREPARING = 'PREPARING',
  READY = 'READY',
  OUT_FOR_DELIVERY = 'OUT_FOR_DELIVERY',
  DELIVERED = 'DELIVERED',
  CANCELLED = 'CANCELLED'
}

/**
 * Order creation input interface
 */
export interface CreateOrderInput {
  studentId: string;
  parentId: string;
  schoolId: string;
  items: Array<{
    menuItemId: string;
    quantity: number;
    specialInstructions?: string;
    customizations?: Record<string, any>;
  }>;
  deliveryDate: Date;
  deliveryType: 'pickup' | 'delivery';
  deliveryTime?: string;
  deliveryAddress?: string;
  specialInstructions?: string;
  metadata?: Record<string, any>;
}

/**
 * Cart item interface
 */
export interface CartItem {
  menuItemId: string;
  quantity: number;
  price: number;
  specialInstructions?: string;
  customizations?: Record<string, any>;
}

/**
 * Cart interface
 */
export interface Cart {
  items: CartItem[];
  totalAmount: number;
  lastUpdated: Date;
  expiresAt: Date;
}

/**
 * Add to cart input interface
 */
export interface AddToCartInput {
  studentId: string;
  menuItemId: string;
  quantity: number;
  specialInstructions?: string;
  customizations?: Record<string, any>;
}

/**
 * Payment data interface
 */
export interface ProcessPaymentInput {
  orderId: string;
  paymentMethod: 'razorpay' | 'wallet' | 'cash';
  paymentDetails?: Record<string, any>;
  amountPaid?: number;
}

/**
 * Order tracking data interface
 */
export interface OrderTrackingData extends Order {
  timeline: Array<{
    status: OrderStatus;
    timestamp: Date;
    message?: string;
  }>;
  estimatedDelivery?: Date;
  canCancel: boolean;
  deliveryDetails?: {
    verifiedAt: Date;
    location: string;
    rfidData: Record<string, any>;
  };
}

/**
 * Orders query interface
 */
export interface OrdersQuery {
  page?: number;
  limit?: number;
  status?: OrderStatus;
  dateFrom?: Date;
  dateTo?: Date;
  schoolId?: string;
  sortBy?: string;
  sortOrder?: 'asc' | 'desc';
}

/**
 * Analytics query interface
 */
export interface AnalyticsQuery {
  schoolId?: string;
  startDate: Date;
  endDate: Date;
  groupBy?: 'day' | 'week' | 'month';
}

/**
 * Order analytics interface
 */
export interface OrderAnalytics {
  totalOrders: number;
  totalRevenue: number;
  deliveryRate: number;
  cancellationRate: number;
  averageOrderValue: number;
  ordersByStatus: Record<OrderStatus, number>;
  revenueByDay: Array<{ date: string; revenue: number; orders: number }>;
}

/**
 * Popular items interface
 */
export interface PopularItemsQuery {
  schoolId?: string;
  startDate?: Date;
  endDate?: Date;
  limit?: number;
}

/**
 * Service response interface
 */
export interface ServiceResponse<T> {
  success: boolean;
  data?: T;
  error?: {
    message: string;
    code: string;
    details?: any;
  };
}

/**
 * Order Management Service class
 */
export class OrderService {
  private static readonly CACHE_TTL = 300; // 5 minutes
  private static readonly CART_EXPIRY = 3600; // 1 hour
  private static readonly MAX_QUANTITY_PER_ITEM = 10;
  private static readonly ORDER_CUTOFF_HOURS = 2; // Hours before delivery
  private static readonly VALID_STATUS_TRANSITIONS: Record<OrderStatus, OrderStatus[]> = {
    [OrderStatus.PENDING]: [OrderStatus.CONFIRMED, OrderStatus.CANCELLED],
    [OrderStatus.CONFIRMED]: [OrderStatus.PREPARING, OrderStatus.CANCELLED],
    [OrderStatus.PREPARING]: [OrderStatus.READY, OrderStatus.CANCELLED],
    [OrderStatus.READY]: [OrderStatus.OUT_FOR_DELIVERY, OrderStatus.DELIVERED, OrderStatus.CANCELLED],
    [OrderStatus.OUT_FOR_DELIVERY]: [OrderStatus.DELIVERED, OrderStatus.CANCELLED],
    [OrderStatus.DELIVERED]: [],
    [OrderStatus.CANCELLED]: []
  };

  /**
   * Create new order with comprehensive validation
   */
  public static async createOrder(input: CreateOrderInput): Promise<ServiceResponse<Order>> {
    try {
      logger.info('Creating order', { 
        studentId: input.studentId, 
        itemCount: input.items.length 
      });

      // Validate business rules
      const validation = await this.validateOrderInput(input);
      if (!validation.success) {
        return validation as unknown as ServiceResponse<Order>;
      }

      // Get menu items with availability check
      const menuItemIds = input.items.map(item => item.menuItemId);
      const menuItems = await MenuItemRepository.findMany({
        filters: { 
          schoolId: input.schoolId,
          available: true 
        },
        ids: menuItemIds
      });

      if (menuItems.items.length !== menuItemIds.length) {
        const foundIds = menuItems.items.map(item => item.id);
        const missingIds = menuItemIds.filter(id => !foundIds.includes(id));
        return {
          success: false,
          error: {
            message: `Menu items not available: ${missingIds.join(', ')}`,
            code: 'ITEMS_UNAVAILABLE'
          }
        };
      }

      // Check dietary restrictions and allergies
      const student = await UserRepository.findById(input.studentId);
      // Note: dietaryRestrictions and allergies fields not available in current User schema
      const dietaryRestrictions = (student as any)?.dietaryRestrictions;
      const allergies = (student as any)?.allergies;
      if (dietaryRestrictions || allergies) {
        const restrictionCheck = await this.checkDietaryRestrictions(
          menuItems.items,
          dietaryRestrictions,
          allergies
        );
        if (!restrictionCheck.success) {
          return restrictionCheck as unknown as ServiceResponse<Order>;
        }
      }

      // Calculate total amount and prepare order items
      let totalAmount = 0;
      const orderItems: Array<Prisma.OrderItemCreateManyOrderInput> = [];

      for (const inputItem of input.items) {
        const menuItem = menuItems.items.find(mi => mi.id === inputItem.menuItemId);
        if (!menuItem) continue;

        // Validate quantity
        if (inputItem.quantity > this.MAX_QUANTITY_PER_ITEM) {
          return {
            success: false,
            error: {
              message: `Quantity for ${menuItem.name} exceeds maximum allowed (${this.MAX_QUANTITY_PER_ITEM})`,
              code: 'QUANTITY_EXCEEDED'
            }
          };
        }

        const itemTotal = Number(menuItem.price) * inputItem.quantity;
        totalAmount += itemTotal;

        orderItems.push({
          id: uuidv4(),
          menuItemId: inputItem.menuItemId,
          quantity: inputItem.quantity,
          unitPrice: Number(menuItem.price),
          totalPrice: Number(menuItem.price) * inputItem.quantity,
          // Use 'notes' field as per Prisma schema, not specialInstructions
          notes: inputItem.specialInstructions || null,
          customizations: inputItem.customizations ? JSON.stringify(inputItem.customizations) : "{}"
        });
      }

      // Create order in transaction
      const order = await DatabaseService.transaction(async (tx) => {
        // Create order
        const orderData: Prisma.OrderCreateInput = {
          id: uuidv4(),
          orderNumber: `ORD-${Date.now()}`,
          // Use correct relation connects as per Prisma schema
          user: { connect: { id: input.parentId } },
          student: { connect: { id: input.studentId } },
          school: { connect: { id: input.schoolId } },
          totalAmount: totalAmount,
          status: 'pending',
          deliveryDate: input.deliveryDate,
          // Store additional details in metadata since they're not in schema
          metadata: JSON.stringify({
            deliveryType: input.deliveryType,
            deliveryTime: input.deliveryTime,
            deliveryAddress: input.deliveryAddress,
            specialInstructions: input.specialInstructions,
            ...input.metadata
          })
        };

        const createdOrder = await tx.order.create({ data: orderData });

        // Create order items
        await tx.orderItem.createMany({
          data: orderItems.map(item => ({
            ...item,
            orderId: createdOrder.id
          }))
        });

        return createdOrder;
      });

      // Clear cart after successful order creation
      await this.clearCart(input.studentId);

      // Send order confirmation notification
      await NotificationService.sendOrderConfirmation({
        orderId: order.id,
        studentId: input.studentId,
        parentId: input.parentId,
        totalAmount: totalAmount,
        deliveryDate: input.deliveryDate
      }).catch(error => {
        logger.warn('Failed to send order confirmation notification', error);
      });

      logger.info('Order created successfully', { 
        orderId: order.id,
        totalAmount: totalAmount
      });

      return {
        success: true,
        data: order
      };
    } catch (error) {
      logger.error('Failed to create order', error, { input });
      
      // Handle specific database errors
      if (error instanceof Error && error.message.includes('Unique constraint')) {
        return {
          success: false,
          error: {
            message: 'Order already exists',
            code: 'DUPLICATE_ORDER'
          }
        };
      }

      return {
        success: false,
        error: {
          message: 'Failed to create order',
          code: 'ORDER_CREATION_FAILED',
          details: error
        }
      };
    }
  }

  /**
   * Add item to cart with Redis caching
   */
  public static async addToCart(input: AddToCartInput): Promise<ServiceResponse<Cart>> {
    try {
      logger.info('Adding item to cart', { 
        studentId: input.studentId,
        menuItemId: input.menuItemId
      });

      // Validate menu item
      const menuItem = await MenuItemRepository.findById(input.menuItemId);
      if (!menuItem || !menuItem.available) {
        return {
          success: false,
          error: {
            message: `Menu item not available`,
            code: 'ITEM_UNAVAILABLE'
          }
        };
      }

      // Validate quantity
      if (input.quantity > this.MAX_QUANTITY_PER_ITEM) {
        return {
          success: false,
          error: {
            message: `Quantity exceeds maximum allowed (${this.MAX_QUANTITY_PER_ITEM})`,
            code: 'QUANTITY_EXCEEDED'
          }
        };
      }

      // Get existing cart
      const cartKey = `cart:${input.studentId}`;
      const existingCartData = await RedisService.get(cartKey);
      let cart: Cart = existingCartData ? 
        JSON.parse(existingCartData) : 
        { items: [], totalAmount: 0, lastUpdated: new Date(), expiresAt: new Date() };

      // Find existing item or add new one
      const existingItemIndex = cart.items.findIndex(
        item => item.menuItemId === input.menuItemId
      );

      const itemPrice = Number(menuItem.price);
      const cartItem: CartItem = {
        menuItemId: input.menuItemId,
        quantity: input.quantity,
        price: itemPrice,
        specialInstructions: input.specialInstructions,
        customizations: input.customizations
      };

      if (existingItemIndex >= 0) {
        // Update existing item quantity
        cart.items[existingItemIndex].quantity += input.quantity;
        cart.items[existingItemIndex].specialInstructions = input.specialInstructions;
        cart.items[existingItemIndex].customizations = input.customizations;
      } else {
        // Add new item
        cart.items.push(cartItem);
      }

      // Recalculate total
      cart.totalAmount = cart.items.reduce(
        (total, item) => total + (item.price * item.quantity), 
        0
      );
      cart.lastUpdated = new Date();
      cart.expiresAt = new Date(Date.now() + this.CART_EXPIRY * 1000);

      // Save to Redis
      await RedisService.set(cartKey, JSON.stringify(cart), this.CART_EXPIRY);

      logger.info('Item added to cart successfully', { 
        studentId: input.studentId,
        cartTotal: cart.totalAmount,
        itemCount: cart.items.length
      });

      return {
        success: true,
        data: cart
      };
    } catch (error) {
      logger.error('Failed to add item to cart', error, { input });
      return {
        success: false,
        error: {
          message: 'Failed to add item to cart',
          code: 'CART_UPDATE_FAILED',
          details: error
        }
      };
    }
  }

  /**
   * Update order status with validation and history tracking
   */
  public static async updateOrderStatus(
    orderId: string, 
    newStatus: OrderStatus,
    message?: string
  ): Promise<ServiceResponse<Order>> {
    try {
      logger.info('Updating order status', { orderId, newStatus });

      // Get existing order
      const existingOrder = await OrderRepository.findById(orderId);
      if (!existingOrder) {
        return {
          success: false,
          error: {
            message: `Order with ID ${orderId} not found`,
            code: 'ORDER_NOT_FOUND'
          }
        };
      }

      // Validate status transition
      const validTransitions = this.VALID_STATUS_TRANSITIONS[existingOrder.status as OrderStatus];
      if (!validTransitions.includes(newStatus)) {
        return {
          success: false,
          error: {
            message: `Invalid status transition from ${existingOrder.status} to ${newStatus}`,
            code: 'INVALID_STATUS_TRANSITION'
          }
        };
      }

      // Update status history (field not available in current schema)
      const currentHistory = (existingOrder as any).statusHistory ? 
        JSON.parse((existingOrder as any).statusHistory as string) : [];
      
      const newHistoryEntry = {
        status: newStatus,
        timestamp: new Date(),
        message: message || `Order status updated to ${newStatus}`
      };
      
      currentHistory.push(newHistoryEntry);

      // Update order
      const updatedOrder = await OrderRepository.update(orderId, {
        status: newStatus,
        // Note: statusHistory field not available in current Order schema
        updatedAt: new Date()
      });

      // Send status update notification
      await NotificationService.sendOrderStatusUpdate({
        orderId: orderId,
        studentId: existingOrder.studentId,
        // Note: parentId field not available in current Order schema
        parentId: (existingOrder as any).parentId || existingOrder.userId,
        newStatus: newStatus,
        message: message
      }).catch(error => {
        logger.warn('Failed to send status update notification', error);
      });

      logger.info('Order status updated successfully', { orderId, newStatus });

      return {
        success: true,
        data: updatedOrder
      };
    } catch (error) {
      logger.error('Failed to update order status', error, { orderId, newStatus });
      return {
        success: false,
        error: {
          message: 'Failed to update order status',
          code: 'STATUS_UPDATE_FAILED',
          details: error
        }
      };
    }
  }

  /**
   * Process order payment with comprehensive integration
   */
  public static async processOrderPayment(
    input: ProcessPaymentInput
  ): Promise<ServiceResponse<any>> {
    try {
      logger.info('Processing order payment', { 
        orderId: input.orderId,
        paymentMethod: input.paymentMethod
      });

      // Get order
      const order = await OrderRepository.findById(input.orderId);
      if (!order) {
        return {
          success: false,
          error: {
            message: `Order with ID ${input.orderId} not found`,
            code: 'ORDER_NOT_FOUND'
          }
        };
      }

      // Create payment order record
      const paymentOrderData: Prisma.PaymentOrderCreateInput = {
        id: uuidv4(),
        razorpayOrderId: `razorpay_${uuidv4()}`, // Generate temporary ID - will be updated by payment gateway
        userId: order.userId,
        orderId: input.orderId,
        amount: Math.round(order.totalAmount * 100), // Razorpay expects amount in paise
        currency: 'INR',
        status: 'pending',
        expiresAt: new Date(Date.now() + 24 * 60 * 60 * 1000), // 24 hours from now
        metadata: JSON.stringify(input.paymentDetails || {})
      };

      const paymentOrder = await PaymentOrderRepository.create(paymentOrderData);

      // Process payment based on method
      let paymentResult;
      
      if (input.paymentMethod === 'cash') {
        // Cash payment - mark as completed
        paymentResult = {
          success: true,
          data: {
            paymentId: paymentOrder.id,
            status: 'captured',
            paymentMethod: 'cash'
          }
        };
      } else {
        // Process through payment service
        paymentResult = await PaymentService.processPayment({
          orderId: input.orderId,
          amount: Number(order.totalAmount),
          currency: 'INR',
          paymentMethodId: input.paymentMethod
        });
      }

      if (!paymentResult.success) {
        // Update payment order status
        await PaymentOrderRepository.update(paymentOrder.id, {
          status: 'failed',
          metadata: JSON.stringify({
            error: paymentResult.error?.message,
            failedAt: new Date().toISOString()
          })
        });

        return {
          success: false,
          error: {
            message: paymentResult.error?.message || 'Payment failed',
            code: 'PAYMENT_FAILED',
            details: paymentResult.error
          }
        };
      }

      // Update payment order status
      await PaymentOrderRepository.update(paymentOrder.id, {
        status: paymentResult.data.status,
        metadata: JSON.stringify({
          paymentId: paymentResult.data.paymentId,
          paidAt: new Date().toISOString(),
          paymentDetails: paymentResult.data
        })
      });

      // Update order status if payment successful
      if (paymentResult.data.status === 'captured') {
        await this.updateOrderStatus(input.orderId, OrderStatus.CONFIRMED, 'Payment confirmed');
      }

      logger.info('Order payment processed successfully', { 
        orderId: input.orderId,
        paymentStatus: paymentResult.data.status
      });

      return {
        success: true,
        data: {
          paymentId: paymentResult.data.paymentId,
          paymentStatus: paymentResult.data.status,
          paymentMethod: input.paymentMethod
        }
      };
    } catch (error) {
      logger.error('Failed to process order payment', error, { input });
      return {
        success: false,
        error: {
          message: 'Failed to process payment',
          code: 'PAYMENT_PROCESSING_FAILED',
          details: error
        }
      };
    }
  }

  /**
   * Get order tracking information with timeline
   */
  public static async getOrderTracking(orderId: string): Promise<ServiceResponse<OrderTrackingData>> {
    try {
      const cacheKey = `order_tracking:${orderId}`;
      const cached = await cache.get(cacheKey);
      if (cached) {
        return { success: true, data: JSON.parse(cached) };
      }

      const order = await OrderRepository.findByIdWithIncludes(orderId, {
        orderItems: {
          include: {
            menuItem: true
          }
        },
        deliveryVerifications: {
          include: {
            card: true,
            reader: true
          }
        }
      });

      if (!order) {
        return {
          success: false,
          error: {
            message: `Order with ID ${orderId} not found`,
            code: 'ORDER_NOT_FOUND'
          }
        };
      }

      // Parse status history
      // statusHistory not available in current Order schema, use empty timeline
      const timeline: any[] = [];

      // Calculate estimated delivery
      let estimatedDelivery: Date | undefined;
      if (order.status !== OrderStatus.DELIVERED && order.status !== OrderStatus.CANCELLED) {
        estimatedDelivery = new Date(order.deliveryDate);
        estimatedDelivery.setHours(12, 0, 0, 0); // Default to noon
      }

      // Check if order can be cancelled
      const canCancel = ['PENDING', 'CONFIRMED'].includes(order.status);

      // Get delivery details if available
      let deliveryDetails;
      // Cast order to include deliveryVerifications since it's included in query
      const orderWithIncludes = order as typeof order & { 
        deliveryVerifications?: Array<any>
      };
      
      if (orderWithIncludes.deliveryVerifications && orderWithIncludes.deliveryVerifications.length > 0) {
        const verification = orderWithIncludes.deliveryVerifications[0];
        deliveryDetails = {
          verifiedAt: verification.verifiedAt,
          location: verification.rfidReader?.location || 'Unknown',
          rfidData: {
            cardNumber: verification.rfidCard?.cardNumber,
            readerLocation: verification.rfidReader?.location
          }
        };
      }

      const trackingData: OrderTrackingData = {
        ...order,
        timeline,
        estimatedDelivery,
        canCancel,
        deliveryDetails
      };

      await cache.setex(cacheKey, this.CACHE_TTL, JSON.stringify(trackingData));

      return {
        success: true,
        data: trackingData
      };
    } catch (error) {
      logger.error('Failed to get order tracking', error, { orderId });
      return {
        success: false,
        error: {
          message: 'Failed to get order tracking',
          code: 'TRACKING_FAILED',
          details: error
        }
      };
    }
  }

  /**
   * Get orders by student with filtering and pagination
   */
  public static async getOrdersByStudent(
    studentId: string,
    query: OrdersQuery = {}
  ): Promise<ServiceResponse<{ orders: Order[]; pagination: any }>> {
    try {
      const page = query.page || 1;
      const limit = Math.min(query.limit || 10, 50);
      const skip = (page - 1) * limit;

      const filters: any = { studentId };
      if (query.status) filters.status = query.status;
      if (query.dateFrom || query.dateTo) {
        filters.createdAt = {};
        if (query.dateFrom) filters.createdAt.gte = query.dateFrom;
        if (query.dateTo) filters.createdAt.lte = query.dateTo;
      }
      if (query.schoolId) filters.schoolId = query.schoolId;

      const result = await OrderRepository.findMany({
        filters,
        skip,
        take: limit,
        sortBy: query.sortBy || 'createdAt',
        sortOrder: query.sortOrder || 'desc',
        include: {
          orderItems: {
            include: {
              menuItem: true
            }
          }
        }
      });

      const total = await OrderRepository.count(filters);
      const totalPages = Math.ceil(total / limit);

      return {
        success: true,
        data: {
          orders: result.items,
          pagination: {
            page,
            limit,
            total,
            totalPages
          }
        }
      };
    } catch (error) {
      logger.error('Failed to get orders by student', error, { studentId, query });
      return {
        success: false,
        error: {
          message: 'Failed to get orders',
          code: 'ORDERS_FETCH_FAILED',
          details: error
        }
      };
    }
  }

  /**
   * Cancel order with refund processing
   */
  public static async cancelOrder(
    orderId: string,
    reason: string
  ): Promise<ServiceResponse<Order>> {
    try {
      logger.info('Cancelling order', { orderId, reason });

      const order = await OrderRepository.findById(orderId);
      if (!order) {
        return {
          success: false,
          error: {
            message: `Order with ID ${orderId} not found`,
            code: 'ORDER_NOT_FOUND'
          }
        };
      }

      // Check if order can be cancelled
      if (!['PENDING', 'CONFIRMED', 'PREPARING'].includes(order.status)) {
        return {
          success: false,
          error: {
            message: `Order with status ${order.status} cannot be cancelled`,
            code: 'CANCELLATION_NOT_ALLOWED'
          }
        };
      }

      // Process refund if payment was made
      let refundResult;
      const paymentOrder = await PaymentOrderRepository.findByOrderId(orderId);
      if (paymentOrder && paymentOrder.status === 'captured') {
        // TODO: Implement processRefund method in PaymentService
        // Extract paymentId from metadata since it's not a direct field
        const metadata = JSON.parse(paymentOrder.metadata || '{}');
        const paymentId = metadata.paymentId || '';
        
        // Placeholder for refund processing - method doesn't exist yet
        refundResult = {
          success: false,
          error: { message: 'Refund processing not implemented', code: 'NOT_IMPLEMENTED' }
        };

        if (!refundResult.success) {
          logger.warn('Refund processing failed', { orderId, error: refundResult.error });
        }
      }

      // Update order status
      const cancelledOrder = await this.updateOrderStatus(orderId, OrderStatus.CANCELLED, `Cancelled: ${reason}`);
      if (!cancelledOrder.success) {
        return cancelledOrder;
      }

      // Add refund information to response
      const result = {
        ...cancelledOrder.data,
        refundStatus: refundResult?.success ? refundResult.data?.status : 'not_applicable'
      };

      return {
        success: true,
        data: result
      };
    } catch (error) {
      logger.error('Failed to cancel order', error, { orderId, reason });
      return {
        success: false,
        error: {
          message: 'Failed to cancel order',
          code: 'CANCELLATION_FAILED',
          details: error
        }
      };
    }
  }

  /**
   * Get order analytics for reporting
   */
  public static async getOrderAnalytics(
    query: AnalyticsQuery
  ): Promise<ServiceResponse<OrderAnalytics>> {
    try {
      const filters: any = {
        createdAt: {
          gte: query.startDate,
          lte: query.endDate
        }
      };
      if (query.schoolId) filters.schoolId = query.schoolId;

      // Get aggregated data
      const analytics = await OrderRepository.getAnalytics(filters, query.groupBy);

      const result: OrderAnalytics = {
        totalOrders: analytics.totalOrders,
        totalRevenue: analytics.totalRevenue,
        deliveryRate: (analytics.deliveredOrders / analytics.totalOrders) * 100,
        cancellationRate: (analytics.cancelledOrders / analytics.totalOrders) * 100,
        averageOrderValue: analytics.totalRevenue / analytics.totalOrders,
        ordersByStatus: {
          [OrderStatus.PENDING]: analytics.ordersByStatus?.[OrderStatus.PENDING] || 0,
          [OrderStatus.CONFIRMED]: analytics.ordersByStatus?.[OrderStatus.CONFIRMED] || 0,
          [OrderStatus.PREPARING]: analytics.ordersByStatus?.[OrderStatus.PREPARING] || 0,
          [OrderStatus.READY]: analytics.ordersByStatus?.[OrderStatus.READY] || 0,
          [OrderStatus.OUT_FOR_DELIVERY]: analytics.ordersByStatus?.[OrderStatus.OUT_FOR_DELIVERY] || 0,
          [OrderStatus.DELIVERED]: analytics.ordersByStatus?.[OrderStatus.DELIVERED] || 0,
          [OrderStatus.CANCELLED]: analytics.ordersByStatus?.[OrderStatus.CANCELLED] || 0
        },
        revenueByDay: analytics.revenueByDay
      };

      return {
        success: true,
        data: result
      };
    } catch (error) {
      logger.error('Failed to get order analytics', error, { query });
      return {
        success: false,
        error: {
          message: 'Failed to get analytics',
          code: 'ANALYTICS_FAILED',
          details: error
        }
      };
    }
  }

  /**
   * Get popular menu items based on order data
   */
  public static async getPopularItems(
    query: PopularItemsQuery
  ): Promise<ServiceResponse<any[]>> {
    try {
      const filters: any = {};
      if (query.schoolId) filters.schoolId = query.schoolId;
      if (query.startDate || query.endDate) {
        filters.createdAt = {};
        if (query.startDate) filters.createdAt.gte = query.startDate;
        if (query.endDate) filters.createdAt.lte = query.endDate;
      }

      const popularItems = await OrderItemRepository.getPopularItems(
        filters,
        query.limit || 10
      );

      return {
        success: true,
        data: popularItems
      };
    } catch (error) {
      logger.error('Failed to get popular items', error, { query });
      return {
        success: false,
        error: {
          message: 'Failed to get popular items',
          code: 'POPULAR_ITEMS_FAILED',
          details: error
        }
      };
    }
  }

  /**
   * Clear cart for student
   */
  public static async clearCart(studentId: string): Promise<void> {
    try {
      const cartKey = `cart:${studentId}`;
      await RedisService.del(cartKey);
      logger.info('Cart cleared', { studentId });
    } catch (error) {
      logger.warn('Failed to clear cart', { studentId, error });
    }
  }

  /**
   * Get cart for student
   */
  public static async getCart(studentId: string): Promise<ServiceResponse<Cart | null>> {
    try {
      const cartKey = `cart:${studentId}`;
      const cartData = await RedisService.get(cartKey);
      
      if (!cartData) {
        return {
          success: true,
          data: null
        };
      }

      const cart: Cart = JSON.parse(cartData);
      
      // Check if cart has expired
      if (new Date() > new Date(cart.expiresAt)) {
        await RedisService.del(cartKey);
        return {
          success: true,
          data: null
        };
      }

      return {
        success: true,
        data: cart
      };
    } catch (error) {
      logger.error('Failed to get cart', error, { studentId });
      return {
        success: false,
        error: {
          message: 'Failed to get cart',
          code: 'CART_FETCH_FAILED',
          details: error
        }
      };
    }
  }

  /**
   * Validate order input with comprehensive checks
   */
  private static async validateOrderInput(input: CreateOrderInput): Promise<ServiceResponse<void>> {
    // Check delivery date is not in the past
    if (input.deliveryDate < new Date()) {
      return {
        success: false,
        error: {
          message: 'Delivery date cannot be in the past',
          code: 'INVALID_DELIVERY_DATE'
        }
      };
    }

    // Check order cutoff time
    const cutoffTime = new Date(input.deliveryDate);
    cutoffTime.setHours(cutoffTime.getHours() - this.ORDER_CUTOFF_HOURS);
    
    if (new Date() > cutoffTime) {
      return {
        success: false,
        error: {
          message: 'Order cutoff time has passed for the selected delivery date',
          code: 'ORDER_CUTOFF_PASSED'
        }
      };
    }

    // Validate items array
    if (!input.items || input.items.length === 0) {
      return {
        success: false,
        error: {
          message: 'Order must contain at least one item',
          code: 'NO_ITEMS'
        }
      };
    }

    // Validate quantities
    for (const item of input.items) {
      if (item.quantity <= 0) {
        return {
          success: false,
          error: {
            message: 'Item quantity must be greater than 0',
            code: 'INVALID_QUANTITY'
          }
        };
      }
    }

    return { success: true };
  }

  /**
   * Check dietary restrictions and allergies
   */
  private static async checkDietaryRestrictions(
    menuItems: any[],
    dietaryRestrictions?: string | null,
    allergies?: string | null
  ): Promise<ServiceResponse<void>> {
    if (!dietaryRestrictions && !allergies) {
      return { success: true };
    }

    const userRestrictions = dietaryRestrictions ? 
      JSON.parse(dietaryRestrictions) : [];
    const userAllergies = allergies ? 
      JSON.parse(allergies) : [];

    for (const menuItem of menuItems) {
      // Check allergens
      if (menuItem.allergens && userAllergies.length > 0) {
        const itemAllergens = JSON.parse(menuItem.allergens as string);
        const conflictingAllergens = itemAllergens.filter((allergen: string) => 
          userAllergies.includes(allergen)
        );
        
        if (conflictingAllergens.length > 0) {
          return {
            success: false,
            error: {
              message: `Item "${menuItem.name}" contains allergens that conflict with dietary restrictions or allergies`,
              code: 'DIETARY_RESTRICTION_CONFLICT'
            }
          };
        }
      }

      // Check dietary restrictions
      if (menuItem.tags && userRestrictions.length > 0) {
        const itemTags = JSON.parse(menuItem.tags as string);
        // This would need more sophisticated logic based on specific restrictions
        // For now, we'll do a basic check
      }
    }

    return { success: true };
  }
}

// Export singleton instance
export const orderService = new OrderService();