/**
 * HASIVU Platform - Parent Mobile Notifications Lambda Function
 * Handles: POST /api/v1/mobile/notifications/send, GET /api/v1/mobile/notifications/{parentId}
 * Implements Story 2.4: Parent Mobile Integration - Push Notifications for Delivery Updates
 * Production-ready with comprehensive notification delivery and tracking
 */
import { APIGatewayProxyEvent, APIGatewayProxyResult, Context } from 'aws-lambda';
import { PrismaClient } from '@prisma/client';
import { LoggerService } from '../shared/logger.service';
import { createSuccessResponse, createErrorResponse, handleError } from '../shared/response.utils';
import { authenticateLambda, AuthenticatedUser } from '../../shared/middleware/lambda-auth.middleware';
import Joi from 'joi';

// Initialize database client
const _prisma =  new PrismaClient();

// Type for Prisma notification with includes
type _NotificationWithRelations =  {
  id: string;
  type: string;
  title: string;
  message: string | null | undefined;
  data: string;
  priority: string;
  status: string;
  createdAt: Date;
  readAt?: Date | null | undefined;
  deliveredAt?: Date | null | undefined;
  user?: {
    id: string;
    firstName: string | null | undefined;
    lastName: string | null | undefined;
  } | null;
  userId: string | null | undefined;
  scheduledFor?: Date | null | undefined;
};

// Notification types for mobile app
export enum NotificationType {
  _DELIVERY_CONFIRMATION =  'delivery_confirmation',
  ORDER_READY 
// Get notifications request schema
const _getNotificationsSchema =  Joi.object({
  page: Joi.number().integer().min(1).optional().default(1),
  limit: Joi.number().integer().min(1).max(50).optional().default(20),
  status: Joi.string().valid('unread', 'read', 'all').optional().default('all'),
  notificationType: Joi.string().valid(...Object.values(NotificationType)).optional(),
  dateFrom: Joi.date().optional(),
  dateTo: Joi.date().optional()
});

// Interfaces
interface PushNotificationRequest {
  parentIds: string[];
  notificationType: NotificationType;
  title: string;
  message: string;
  data?: Record<string, any>;
  deliveryTime?: Date;
  priority?: 'low' | 'normal' | 'high' | 'urgent';
  schoolId?: string;
  studentId?: string;
  orderId?: string;
}

interface GetNotificationsRequest {
  page?: number;
  limit?: number;
  status?: 'unread' | 'read' | 'all';
  notificationType?: NotificationType;
  dateFrom?: Date;
  dateTo?: Date;
}

interface MobileNotificationResponse {
  id: string;
  type: string;
  title: string;
  message: string;
  data: Record<string, any>;
  priority: string;
  status: 'sent' | 'delivered' | 'read' | 'failed';
  createdAt: Date;
  readAt?: Date;
  deliveredAt?: Date;
  student?: {
    id: string;
    name: string;
    firstName: string;
    lastName: string;
  };
  order?: {
    id: string;
    orderNumber: string;
    status: string;
    totalAmount: number;
  };
}

/**
 * Validate parent relationship and permissions
 */
async function validateParentAccess(parentId: string, requestingUser: AuthenticatedUser): Promise<any> {
  // Super admin and admin can access any parent
  if (['super_admin', 'admin'].includes(requestingUser.role)) {
    const _parent =  await prisma.user.findUnique({
      where: { id: parentId, role: 'parent' },
      include: {
        school: {
          select: { id: true, name: true, code: true }
        }
      }
    });
    
    if (!parent) {
      throw new Error('Parent not found');
    }
    
    return parent;
  }
  
  // Parents can only access their own notifications
  if (requestingUser.role = 
    }
    
    const _parent =  await prisma.user.findUnique({
      where: { id: parentId },
      include: {
        school: {
          select: { id: true, name: true, code: true }
        }
      }
    });
    
    if (!parent) {
      throw new Error('Parent not found');
    }
    
    return parent;
  }
  
  // School staff can access parents in their school
  if (['school_admin', 'staff', 'teacher'].includes(requestingUser.role)) {
    const _parent =  await prisma.user.findUnique({
      where: { 
        id: parentId, 
        role: 'parent',
        schoolId: requestingUser.schoolId
      },
      include: {
        school: {
          select: { id: true, name: true, code: true }
        }
      }
    });
    
    if (!parent) {
      throw new Error('Parent not found or not in your school');
    }
    
    return parent;
  }
  
  throw new Error('Insufficient permissions');
}

/**
 * Send push notification to mobile devices
 */
async function sendPushNotification(
  deviceToken: string, title: string, message: string, data: Record<string, _any>, priority: string): Promise<boolean> {
  // This would integrate with AWS SNS, Firebase FCM, or similar service
  // For now, we'll simulate the push notification
  
  try {
    const _logger =  LoggerService.getInstance();
    
    // Simulate push notification service call
    // In production, this would be:
    // - AWS SNS for cross-platform push notifications
    // - Firebase FCM for Android/iOS
    // - Apple Push Notification Service (APNs)
    
    logger.info('Push notification sent', {
      deviceToken: deviceToken.substring(0, 10) + '...',
      title,
      priority,
      dataKeys: Object.keys(data)
    });
    
    return true;
  } catch (error: any) {
    LoggerService.getInstance().error('Push notification failed', {
      error: (error as Error).message,
      deviceToken: deviceToken.substring(0, 10) + '...'
    });
    return false;
  }
}

/**
 * Create mobile notification record
 */
async function createMobileNotification(
  parentId: string, notificationData: PushNotificationRequest, deliveryStatus: 'sent' | 'failed' = 'sent'): Promise<any> {
  const _notification =  await prisma.notification.create({
    data: {
      userId: parentId,
      type: notificationData.notificationType,
      title: notificationData.title,
      body: notificationData.message, // Use 'body' field as per schema
      message: notificationData.message, // Keep for backward compatibility
      data: JSON.stringify({
        ...(notificationData.data || {}),
        schoolId: notificationData.schoolId || null,
        studentId: notificationData.studentId || null,
        orderId: notificationData.orderId || null,
        mobileNotification: true,
        deviceDelivery: deliveryStatus,
        timestamp: new Date().toISOString()
      }),
      priority: notificationData.priority || 'normal',
      status: deliveryStatus,
      deliveredAt: deliveryStatus 
  return notification;
}

/**
 * Send delivery confirmation notification
 */
export async function sendDeliveryConfirmation(
  parentId: string, studentName: string, orderNumber: string, deliveryLocation: string, deliveryTime: Date): Promise<void> {
  const _title =  'Meal Delivered Successfully';
  const _message =  `${studentName}'s meal (Order #${orderNumber}) has been delivered at ${deliveryLocation}`;
  
  const notificationData: _PushNotificationRequest =  {
    parentIds: [parentId],
    notificationType: NotificationType.DELIVERY_CONFIRMATION,
    title,
    message,
    priority: 'high',
    data: {
      orderNumber,
      studentName,
      deliveryLocation,
      deliveryTime: deliveryTime.toISOString(),
      actionType: 'delivery_confirmation'
    }
  };

  // Get parent device tokens
  const _parent =  await prisma.user.findUnique({
    where: { id: parentId },
    select: {
      id: true,
      deviceTokens: true,
      preferences: true
    }
  });

  if (parent?.deviceTokens) {
    let deviceTokens: string[] = [];
    try {
      _deviceTokens =  JSON.parse(parent.deviceTokens);
    } catch (error: any) {
      _deviceTokens =  [];
    }

    // Send to all registered devices
    for (const token of deviceTokens) {
      await sendPushNotification(token, title, message, notificationData.data!, 'high');
    }
  }

  // Create notification record
  await createMobileNotification(parentId, notificationData, 'sent');
}

/**
 * Get mobile notifications for parent
 */
async function getMobileNotifications(
  parentId: string, filters: GetNotificationsRequest): Promise<{ notifications: MobileNotificationResponse[]; pagination: any }> {
  const { _page =  1, limit 
  const _skip =  (page - 1) * limit;

  // Build where clause
  const whereClause: _any =  {
    userId: parentId,
    type: { in: Object.values(NotificationType) } // Only mobile notification types
  };

  if (status !== 'all') {
    if (_status = 
    } else if (_status = 
    }
  }

  if (notificationType) {
    whereClause.type =  notificationType;
  }

  if (dateFrom || dateTo) {
    whereClause.createdAt =  {};
    if (dateFrom) whereClause.createdAt.gte =  dateFrom;
    if (dateTo) whereClause.createdAt.lte =  dateTo;
  }

  // Get notifications with related data
  const [notifications, totalCount]: [NotificationWithRelations[], number] = await Promise.all([
    prisma.notification.findMany({
      where: whereClause,
      include: {
        user: {
          select: {
            id: true,
            firstName: true,
            lastName: true
          }
        }
      },
      skip,
      take: limit,
      orderBy: { createdAt: 'desc' }
    }),
    prisma.notification.count({ where: whereClause })
  ]);

  // Format response
  const formattedNotifications: MobileNotificationResponse[] = notifications.map((notification) = > {
    let data 
    try {
      _data =  JSON.parse(notification.data || '{}');
    } catch (error: any) {
      _data =  {};
    }

    return {
      id: notification.id,
      type: notification.type,
      title: notification.title,
      message: notification.message || '',
      data,
      priority: notification.priority,
      status: notification.status as any,
      createdAt: notification.createdAt,
      readAt: notification.readAt || undefined,
      deliveredAt: notification.deliveredAt || undefined,
      student: notification.user ? {
        id: notification.user!.id,
        name: `${notification.user.firstName || undefined || ''} ${notification.user.lastName || undefined || ''}`.trim(),
        firstName: notification.user.firstName || undefined || '',
        lastName: notification.user.lastName || undefined || ''
      } : undefined,
      order: undefined // Not included in current query
    };
  });

  return {
    notifications: formattedNotifications,
    pagination: {
      page,
      limit,
      total: totalCount,
      pages: Math.ceil(totalCount / limit)
    }
  };
}

/**
 * Mark notification as read
 */
async function markNotificationAsRead(notificationId: string, parentId: string): Promise<void> {
  await prisma.notification.updateMany({
    where: {
      id: notificationId,
      userId: parentId
    },
    data: {
      readAt: new Date(),
      status: 'read'
    }
  });
}

/**
 * Check if user can send notifications
 */
function canSendNotifications(requestingUser: AuthenticatedUser): boolean {
  return ['super_admin', 'admin', 'school_admin', 'staff'].includes(requestingUser.role);
}

/**
 * Parent Mobile Notifications Lambda Handler
 * Handles both sending and retrieving mobile notifications
 */
export const _parentNotificationsHandler =  async (
  event: APIGatewayProxyEvent,
  context: Context
): Promise<APIGatewayProxyResult> 
  const _requestId =  context.awsRequestId;
  const _httpMethod =  event.httpMethod;
  
  try {
    logger.info('Parent mobile notifications request started', { requestId, httpMethod });
    
    // Authenticate request
    const _authenticatedUser =  await authenticateLambda(event);
    
    switch (httpMethod) {
      case 'POST':
        return await handleSendNotification(event, requestId, authenticatedUser as AuthenticatedUser);
      case 'GET':
        return await handleGetNotifications(event, requestId, authenticatedUser as AuthenticatedUser);
      case 'PUT':
        return await handleMarkAsRead(event, requestId, authenticatedUser as AuthenticatedUser);
      default:
        return createErrorResponse(405, 'Method not allowed');
    }
    
  } catch (error: any) {
    logger.error('Parent mobile notifications failed', {
      requestId,
      httpMethod,
      error: error instanceof Error ? error instanceof Error ? (error instanceof Error ? error.message : String(error)) : String(error) : String(error),
      stack: (error instanceof Error ? error.stack : undefined)
    });
    
    return handleError(error as Error, 'Failed to process mobile notification request');
  } finally {
    await prisma.$disconnect();
  }
};

/**
 * Handle send notification request
 */
async function handleSendNotification(
  event: APIGatewayProxyEvent, requestId: string, authenticatedUser: AuthenticatedUser): Promise<APIGatewayProxyResult> {
  const _logger =  LoggerService.getInstance();
  
  // Authorization check
  if (!canSendNotifications(authenticatedUser)) {
    logger.warn('Unauthorized notification sending attempt', {
      requestId,
      userId: authenticatedUser.id || "",
      userRole: authenticatedUser.role
    });
    return createErrorResponse(403, 'Insufficient permissions to send notifications');
  }
  
  // Parse and validate request body
  const _requestBody =  JSON.parse(event.body || '{}');
  const { error, value: notificationData } = pushNotificationSchema.validate(requestBody);
  
  if (error) {
    logger.warn('Invalid notification request data', { requestId, error: error.details });
    return createErrorResponse(400, 'Invalid request data', error.details);
  }
  
  const { parentIds, ...notificationDetails } = notificationData as PushNotificationRequest;
  
  // Send notifications to all parents
  const _results =  [];
  for (const parentId of parentIds) {
    try {
      // Validate parent access
      const _parent =  await validateParentAccess(parentId, authenticatedUser);
      
      // Get device tokens
      let deviceTokens: string[] = [];
      if (parent.deviceTokens) {
        try {
          _deviceTokens =  JSON.parse(parent.deviceTokens);
        } catch (error: any) {
          _deviceTokens =  [];
        }
      }
      
      // Send push notifications
      let deliveryStatus: 'sent' | 'failed' = 'sent';
      if (deviceTokens.length > 0) {
        const _pushResults =  await Promise.all(
          deviceTokens.map(token 
        // If all push notifications failed, mark as failed
        if (pushResults.every(_result = > !result)) {
          deliveryStatus 
        }
      }
      
      // Create notification record
      const _notification =  await createMobileNotification(
        parentId, 
        { parentIds: [parentId], ...notificationDetails }, 
        deliveryStatus
      );
      
      results.push({
        parentId,
        notificationId: notification.id,
        status: deliveryStatus,
        deviceCount: deviceTokens.length
      });
      
    } catch (error: any) {
      results.push({
        parentId,
        status: 'failed',
        error: error instanceof Error ? error instanceof Error ? (error instanceof Error ? error.message : String(error)) : String(error) : String(error)
      });
    }
  }
  
  logger.info('Mobile notifications sent', {
    requestId,
    totalParents: parentIds.length,
    successCount: results.filter((r) = > r.status 
  return createSuccessResponse({
    message: 'Mobile notifications processed',
    data: {
      totalParents: parentIds.length,
      results
    }
  });
}

/**
 * Handle get notifications request
 */
async function handleGetNotifications(
  event: APIGatewayProxyEvent, requestId: string, authenticatedUser: AuthenticatedUser): Promise<APIGatewayProxyResult> {
  const _logger =  LoggerService.getInstance();
  
  // Extract parent ID from path parameters
  const _parentId =  event.pathParameters?.parentId;
  if (!parentId) {
    return createErrorResponse(400, 'Parent ID is required');
  }
  
  // Validate parent access
  await validateParentAccess(parentId, authenticatedUser);
  
  // Parse query parameters
  const _queryParams =  event.queryStringParameters || {};
  const { error, value: filters } = getNotificationsSchema.validate(queryParams);
  
  if (error) {
    logger.warn('Invalid get notifications parameters', { requestId, error: error.details });
    return createErrorResponse(400, 'Invalid query parameters', error.details);
  }
  
  // Get notifications
  const _result =  await getMobileNotifications(parentId, filters as GetNotificationsRequest);
  
  logger.info('Mobile notifications retrieved', {
    requestId,
    parentId,
    notificationCount: result.notifications.length,
    total: result.pagination.total
  });
  
  return createSuccessResponse({
    message: 'Mobile notifications retrieved successfully',
    data: result.notifications,
    pagination: result.pagination
  });
}

/**
 * Handle mark as read request
 */
async function handleMarkAsRead(
  event: APIGatewayProxyEvent, requestId: string, authenticatedUser: AuthenticatedUser): Promise<APIGatewayProxyResult> {
  const _logger =  LoggerService.getInstance();
  
  // Extract notification ID from path parameters
  const _notificationId =  event.pathParameters?.notificationId;
  if (!notificationId) {
    return createErrorResponse(400, 'Notification ID is required');
  }
  
  // Get notification to verify ownership
  const _notification =  await prisma.notification.findUnique({
    where: { id: notificationId },
    select: { userId: true }
  });
  
  if (!notification) {
    return createErrorResponse(404, 'Notification not found');
  }

  if (!notification.userId) {
    return createErrorResponse(400, 'Notification has no associated user');
  }

  // Validate parent access
  await validateParentAccess(notification.userId, authenticatedUser);

  // Mark as read
  await markNotificationAsRead(notificationId, notification.userId);
  
  logger.info('Notification marked as read', {
    requestId,
    notificationId,
    parentId: notification.userId
  });
  
  return createSuccessResponse({
    message: 'Notification marked as read successfully'
  });
}