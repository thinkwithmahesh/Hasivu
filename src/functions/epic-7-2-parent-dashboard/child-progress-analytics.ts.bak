/**
 * Epic 7.2: Advanced Parent Dashboard & Insights Portal
 * Lambda Function: child-progress-analytics
 *
 * Individual child nutrition and learning progress tracking with comprehensive analytics.
 * Provides detailed nutrition analysis, meal tracking, progress visualization,
 * and integration with Epic 7.1 nutrition functions for AI-powered insights.
 *
 * Features:
 * - Comprehensive nutrition tracking and analysis
 * - Meal history and pattern recognition
 * - Progress metrics and goal tracking
 * - Growth and development monitoring
 * - Comparative analysis and benchmarking
 * - Integration with AI nutrition analysis
 * - Real-time progress updates
 * - Parent-friendly progress reports
 */

import { APIGatewayProxyEvent, APIGatewayProxyResult, Context } from 'aws-lambda';
import { LoggerService } from '../../services/logger.service';
import { LambdaDatabaseService } from '../../functions/shared/database.service';
import { createSuccessResponse, createErrorResponse, handleError } from '../../functions/shared/response.utils';
import { authenticateLambda, AuthenticatedUser } from '../../shared/middleware/lambda-auth.middleware';
import { z } from 'zod';
import * as AWS from 'aws-sdk';

// Initialize services
const logger = LoggerService.getInstance();
const db = LambdaDatabaseService.getInstance();
const lambda = new AWS.Lambda();

// Request validation schemas
const progressRequestSchema = z.object({
  childId: z.string().uuid(),
  dateRange: z.object({
    startDate: z.string().datetime(),
    endDate: z.string().datetime(),
  }).optional(),
  includeNutrition: z.boolean().optional().default(true),
  includeMealHistory: z.boolean().optional().default(true),
  includeProgress: z.boolean().optional().default(true),
  includeComparisons: z.boolean().optional().default(false),
  granularity: z.enum(['daily', 'weekly', 'monthly']).optional().default('weekly'),
});

const goalUpdateSchema = z.object({
  childId: z.string().uuid(),
  goalType: z.enum(['nutrition', 'weight', 'height', 'activity', 'hydration']),
  targetValue: z.number(),
  targetDate: z.string().datetime().optional(),
  description: z.string().optional(),
});

const progressUpdateSchema = z.object({
  childId: z.string().uuid(),
  metricType: z.string(),
  value: z.number(),
  date: z.string().datetime(),
  notes: z.string().optional(),
});

// Interface definitions
interface ChildProgressAnalytics {
  childInfo: ChildInfo;
  nutritionAnalytics: NutritionAnalytics;
  mealHistoryAnalytics: MealHistoryAnalytics;
  progressMetrics: ProgressMetrics;
  growthData: GrowthData;
  goalsTracking: GoalsTracking;
  comparativeAnalysis?: ComparativeAnalysis;
  insights: ProgressInsights;
  recommendations: ProgressRecommendation[];
  metadata: AnalyticsMetadata;
}

interface ChildInfo {
  id: string;
  name: string;
  age: number;
  grade: string;
  class: string;
  school: {
    id: string;
    name: string;
    code: string;
  };
  profileData: ChildProfile;
}

interface ChildProfile {
  dateOfBirth: Date;
  gender: string;
  height?: number;
  weight?: number;
  allergies: string[];
  dietaryRestrictions: string[];
  medicalConditions: string[];
  activityLevel: string;
  preferences: FoodPreference[];
}

interface NutritionAnalytics {
  summary: NutritionSummary;
  trends: NutritionTrend[];
  distribution: NutritionDistribution;
  quality: NutritionQuality;
  micronutrients: MicronutrientAnalysis;
  hydration: HydrationAnalysis;
  timing: MealTimingAnalysis;
}

interface NutritionSummary {
  period: string;
  averageDailyCalories: number;
  averageMacros: MacronutrientBreakdown;
  nutritionScore: number;
  consistencyScore: number;
  varietyScore: number;
  balanceScore: number;
}

interface MacronutrientBreakdown {
  protein: { grams: number; percentage: number; target: number };
  carbohydrates: { grams: number; percentage: number; target: number };
  fats: { grams: number; percentage: number; target: number };
  fiber: { grams: number; target: number };
}

interface NutritionTrend {
  metric: string;
  values: TrendDataPoint[];
  trend: 'improving' | 'stable' | 'declining';
  changeRate: number;
  significance: 'high' | 'medium' | 'low';
}

interface TrendDataPoint {
  date: Date;
  value: number;
  quality: number;
}

interface NutritionDistribution {
  mealTypes: { breakfast: number; lunch: number; dinner: number; snacks: number };
  foodGroups: Record<string, number>;
  cookingMethods: Record<string, number>;
  cuisineTypes: Record<string, number>;
}

interface NutritionQuality {
  overallScore: number;
  processingScore: number; // Fresh vs processed foods
  diversityScore: number;
  nutrientDensityScore: number;
  adequacyScore: number; // Meeting recommended values
}

interface MicronutrientAnalysis {
  vitamins: Record<string, { current: number; target: number; adequacy: number }>;
  minerals: Record<string, { current: number; target: number; adequacy: number }>;
  deficiencyRisks: string[];
  supplementationNeeds: string[];
}

interface HydrationAnalysis {
  averageDailyIntake: number;
  target: number;
  adequacy: number;
  sources: Record<string, number>;
  patterns: string[];
}

interface MealTimingAnalysis {
  averageMealTimes: Record<string, string>;
  consistency: number;
  intervalAnalysis: { average: number; variability: number };
  recommendations: string[];
}

interface MealHistoryAnalytics {
  summary: MealHistorySummary;
  patterns: MealPattern[];
  preferences: PreferenceAnalysis;
  ordering: OrderingBehavior;
  satisfaction: SatisfactionMetrics;
}

interface MealHistorySummary {
  totalMealsTracked: number;
  averageMealsPerDay: number;
  favoriteItems: FavoriteItem[];
  leastFavoriteItems: string[];
  skipPatterns: SkipPattern[];
}

interface FavoriteItem {
  name: string;
  category: string;
  frequency: number;
  nutritionScore: number;
  lastOrdered: Date;
}

interface MealPattern {
  pattern: string;
  frequency: number;
  reliability: number;
  seasonality?: string;
  triggers: string[];
}

interface PreferenceAnalysis {
  categories: CategoryPreference[];
  flavors: FlavorPreference[];
  textures: TexturePreference[];
  temperatures: TemperaturePreference[];
  evolution: PreferenceEvolution;
}

interface CategoryPreference {
  category: string;
  preference: number;
  frequency: number;
  trend: 'increasing' | 'stable' | 'decreasing';
}

interface FlavorPreference {
  flavor: string;
  intensity: number;
  acceptance: number;
}

interface TexturePreference {
  texture: string;
  preference: number;
  tolerance: number;
}

interface TemperaturePreference {
  temperature: string;
  preference: number;
}

interface PreferenceEvolution {
  newAcceptances: string[];
  developingPreferences: string[];
  fadingPreferences: string[];
  consistentPreferences: string[];
}

interface OrderingBehavior {
  frequency: number;
  consistency: number;
  planning: PlanningBehavior;
  influences: BehaviorInfluence[];
}

interface PlanningBehavior {
  advanceOrdering: number;
  repeatOrders: number;
  varietySeeking: number;
  spontaneity: number;
}

interface BehaviorInfluence {
  factor: string;
  impact: number;
  direction: 'positive' | 'negative';
}

interface SatisfactionMetrics {
  overallSatisfaction: number;
  tasteRating: number;
  varietyRating: number;
  nutritionRating: number;
  portionRating: number;
  feedback: FeedbackSummary[];
}

interface FeedbackSummary {
  type: string;
  frequency: number;
  sentiment: 'positive' | 'neutral' | 'negative';
  themes: string[];
}

interface ProgressMetrics {
  nutritionalGoals: GoalProgress[];
  developmentalMilestones: MilestoneProgress[];
  behavioralProgress: BehavioralProgress[];
  academicCorrelations: AcademicCorrelation[];
  overallProgress: OverallProgressSummary;
}

interface GoalProgress {
  goalId: string;
  goalType: string;
  description: string;
  target: number;
  current: number;
  progress: number;
  timeframe: string;
  status: 'on_track' | 'behind' | 'ahead' | 'completed';
  trajectory: 'improving' | 'stable' | 'declining';
  lastUpdated: Date;
}

interface MilestoneProgress {
  milestone: string;
  category: string;
  ageTarget: number;
  currentAge: number;
  status: 'achieved' | 'on_track' | 'delayed' | 'at_risk';
  indicators: string[];
  recommendations: string[];
}

interface BehavioralProgress {
  behavior: string;
  baseline: number;
  current: number;
  improvement: number;
  consistency: number;
  factors: string[];
}

interface AcademicCorrelation {
  subject: string;
  nutritionCorrelation: number;
  significance: number;
  observations: string[];
}

interface OverallProgressSummary {
  score: number;
  trend: 'improving' | 'stable' | 'declining';
  strengths: string[];
  areasForImprovement: string[];
  nextMilestones: string[];
}

interface GrowthData {
  height: GrowthMetric;
  weight: GrowthMetric;
  bmi: GrowthMetric;
  growthVelocity: GrowthVelocity;
  percentiles: PercentileData;
  projections: GrowthProjection[];
}

interface GrowthMetric {
  current: number;
  unit: string;
  history: GrowthDataPoint[];
  trend: 'normal' | 'accelerated' | 'slow';
  percentile: number;
}

interface GrowthDataPoint {
  date: Date;
  value: number;
  source: string;
  verified: boolean;
}

interface GrowthVelocity {
  height: { value: number; percentile: number; normal: boolean };
  weight: { value: number; percentile: number; normal: boolean };
}

interface PercentileData {
  height: number;
  weight: number;
  bmi: number;
  headCircumference?: number;
}

interface GrowthProjection {
  metric: string;
  timeframe: string;
  projectedValue: number;
  confidenceInterval: { lower: number; upper: number };
  assumptions: string[];
}

interface GoalsTracking {
  activeGoals: Goal[];
  completedGoals: Goal[];
  upcomingGoals: Goal[];
  goalStatistics: GoalStatistics;
}

interface Goal {
  id: string;
  type: string;
  description: string;
  target: number;
  current: number;
  unit: string;
  deadline: Date;
  progress: number;
  status: 'active' | 'completed' | 'overdue' | 'paused';
  priority: 'high' | 'medium' | 'low';
  category: string;
  milestones: Milestone[];
}

interface Milestone {
  description: string;
  target: number;
  achieved: boolean;
  achievedDate?: Date;
}

interface GoalStatistics {
  totalGoals: number;
  completionRate: number;
  averageCompletionTime: number;
  successFactors: string[];
  challengeFactors: string[];
}

interface ComparativeAnalysis {
  peerComparison: PeerComparison;
  historicalComparison: HistoricalComparison;
  standardsComparison: StandardsComparison;
}

interface PeerComparison {
  nutritionRanking: number;
  progressRanking: number;
  strengths: string[];
  improvementAreas: string[];
  anonymizedData: boolean;
}

interface HistoricalComparison {
  yearOverYear: YearOverYearComparison;
  seasonalPatterns: SeasonalPattern[];
  significantChanges: SignificantChange[];
}

interface YearOverYearComparison {
  metric: string;
  previousValue: number;
  currentValue: number;
  change: number;
  significance: string;
}

interface SeasonalPattern {
  season: string;
  pattern: string;
  impact: number;
  recommendations: string[];
}

interface SignificantChange {
  date: Date;
  metric: string;
  change: number;
  cause: string;
  impact: string;
}

interface StandardsComparison {
  nationalStandards: StandardComparison[];
  whoStandards: StandardComparison[];
  schoolStandards: StandardComparison[];
}

interface StandardComparison {
  metric: string;
  childValue: number;
  standardValue: number;
  deviation: number;
  status: 'above' | 'within' | 'below';
}

interface ProgressInsights {
  keyFindings: string[];
  positiveAspects: string[];
  concernAreas: string[];
  trendAnalysis: string[];
  predictiveInsights: string[];
}

interface ProgressRecommendation {
  id: string;
  category: string;
  priority: 'high' | 'medium' | 'low';
  recommendation: string;
  rationale: string;
  expectedOutcome: string;
  timeframe: string;
  actionSteps: string[];
  monitoringPlan: string;
}

interface AnalyticsMetadata {
  generatedAt: Date;
  dataRange: { start: Date; end: Date };
  dataQuality: number;
  confidence: number;
  limitations: string[];
  nextUpdateDue: Date;
  version: string;
}

interface FoodPreference {
  category: string;
  preference: number;
  frequency: number;
  lastObserved: Date;
}

interface SkipPattern {
  mealType: string;
  frequency: number;
  reasons: string[];
  impact: string;
}

/**
 * Validate child access permissions
 */
async function validateChildAccess(
  childId: string,
  requestingUser: AuthenticatedUser
): Promise<any> {
  try {
    // Super admin and admin can access any child
    if (['super_admin', 'admin'].includes(requestingUser.role)) {
      const child = await db.prisma.user.findUnique({
        where: { id: childId, role: 'student' },
        include: {
          school: { select: { id: true, name: true, code: true } },
          parent: { select: { id: true, firstName: true, lastName: true } }
        }
      });

      if (!child) {
        throw new Error('Child not found');
      }
      return child;
    }

    // Parents can only access their own children
    if (requestingUser.role === 'parent') {
      const child = await db.prisma.user.findUnique({
        where: {
          id: childId,
          role: 'student',
          parentId: requestingUser.id
        },
        include: {
          school: { select: { id: true, name: true, code: true } },
          parent: { select: { id: true, firstName: true, lastName: true } }
        }
      });

      if (!child) {
        throw new Error('Child not found or access denied');
      }
      return child;
    }

    // School staff can access children in their school
    if (['school_admin', 'staff', 'teacher'].includes(requestingUser.role)) {
      const child = await db.prisma.user.findUnique({
        where: {
          id: childId,
          role: 'student',
          schoolId: requestingUser.schoolId
        },
        include: {
          school: { select: { id: true, name: true, code: true } },
          parent: { select: { id: true, firstName: true, lastName: true } }
        }
      });

      if (!child) {
        throw new Error('Child not found or not in your school');
      }
      return child;
    }

    throw new Error('Insufficient permissions');
  } catch (error: unknown) {
    logger.error('Child access validation failed', {
      childId,
      requestingUserId: requestingUser.id,
      error: (error as Error).message
    });
    throw error;
  }
}

/**
 * Get comprehensive child information
 */
async function getChildInfo(childData: any): Promise<ChildInfo> {
  const age = Math.floor(
    (Date.now() - new Date(childData.dateOfBirth).getTime()) / (365.25 * 24 * 60 * 60 * 1000)
  );

  // Get child preferences and profile data
  const profileData: ChildProfile = {
    dateOfBirth: childData.dateOfBirth,
    gender: childData.gender || 'not_specified',
    height: childData.height,
    weight: childData.weight,
    allergies: childData.allergies ? JSON.parse(childData.allergies) : [],
    dietaryRestrictions: childData.dietaryRestrictions ? JSON.parse(childData.dietaryRestrictions) : [],
    medicalConditions: childData.medicalConditions ? JSON.parse(childData.medicalConditions) : [],
    activityLevel: childData.activityLevel || 'moderate',
    preferences: [] // Will be filled from order history
  };

  return {
    id: childData.id,
    name: `${childData.firstName} ${childData.lastName}`,
    age,
    grade: childData.class?.grade || 'N/A',
    class: childData.class?.name || 'N/A',
    school: childData.school,
    profileData
  };
}

/**
 * Analyze nutrition data using Epic 7.1 functions
 */
async function analyzeNutritionData(
  childId: string,
  dateRange?: { startDate: string; endDate: string }
): Promise<NutritionAnalytics> {
  try {
    // Invoke nutrition analyzer from Epic 7.1
    const nutritionPayload = {
      body: JSON.stringify({
        action: 'analyze_child_nutrition',
        data: {
          childId,
          dateRange,
          includeDetailed: true,
          includeTrends: true,
          includeMicronutrients: true
        }
      })
    };

    const nutritionResult = await lambda.invoke({
      FunctionName: 'hasivu-platform-dev-nutrition-analyzer',
      InvocationType: 'RequestResponse',
      Payload: JSON.stringify(nutritionPayload)
    }).promise();

    let nutritionData: any = {};
    if (nutritionResult.Payload) {
      const response = JSON.parse(nutritionResult.Payload.toString());
      if (response.statusCode === 200) {
        nutritionData = JSON.parse(response.body);
      }
    }

    // Get meal orders for additional analysis
    const endDate = dateRange?.endDate ? new Date(dateRange.endDate) : new Date();
    const startDate = dateRange?.startDate ? new Date(dateRange.startDate) : new Date(endDate.getTime() - 30 * 24 * 60 * 60 * 1000);

    const orders = await db.prisma.order.findMany({
      where: {
        userId: childId,
        createdAt: {
          gte: startDate,
          lte: endDate
        }
      },
      include: {
        orderItems: {
          include: {
            menuItem: {
              select: {
                name: true,
                category: true,
                nutritionalInfo: true,
                allergens: true
              }
            }
          }
        }
      },
      orderBy: { createdAt: 'desc' }
    });

    // Process orders for detailed analytics
    let totalCalories = 0;
    let totalProtein = 0;
    let totalCarbs = 0;
    let totalFats = 0;
    let totalFiber = 0;
    const foodGroups: Record<string, number> = {};
    const mealTimes: Date[] = [];

    orders.forEach(order => {
      mealTimes.push(order.createdAt);

      order.orderItems.forEach(item => {
        try {
          const nutrition = JSON.parse(item.menuItem.nutritionalInfo || '{}');
          const quantity = item.quantity;

          totalCalories += (nutrition.calories || 0) * quantity;
          totalProtein += (nutrition.protein || 0) * quantity;
          totalCarbs += (nutrition.carbs || 0) * quantity;
          totalFats += (nutrition.fats || 0) * quantity;
          totalFiber += (nutrition.fiber || 0) * quantity;

          const category = item.menuItem.category || 'other';
          foodGroups[category] = (foodGroups[category] || 0) + quantity;
        } catch (e) {
          // Skip invalid nutrition data
        }
      });
    });

    const daysInPeriod = Math.max(1, (endDate.getTime() - startDate.getTime()) / (24 * 60 * 60 * 1000));
    const averageDailyCalories = totalCalories / daysInPeriod;

    // Calculate macronutrient targets based on age - Note: dateOfBirth field doesn't exist in current User model
    // Using default age for now
    const age = 10;

    const calorieTarget = age < 8 ? 1600 : age < 13 ? 2000 : 2400;
    const proteinTarget = age * 1.2; // g per day
    const fiberTarget = age + 5; // g per day

    const nutritionAnalytics: NutritionAnalytics = {
      summary: {
        period: `${startDate.toISOString().split('T')[0]} to ${endDate.toISOString().split('T')[0]}`,
        averageDailyCalories,
        averageMacros: {
          protein: {
            grams: totalProtein / daysInPeriod,
            percentage: totalCalories > 0 ? (totalProtein * 4 / totalCalories) * 100 : 0,
            target: proteinTarget
          },
          carbohydrates: {
            grams: totalCarbs / daysInPeriod,
            percentage: totalCalories > 0 ? (totalCarbs * 4 / totalCalories) * 100 : 0,
            target: calorieTarget * 0.55 / 4 // 55% of calories from carbs
          },
          fats: {
            grams: totalFats / daysInPeriod,
            percentage: totalCalories > 0 ? (totalFats * 9 / totalCalories) * 100 : 0,
            target: calorieTarget * 0.30 / 9 // 30% of calories from fats
          },
          fiber: {
            grams: totalFiber / daysInPeriod,
            target: fiberTarget
          }
        },
        nutritionScore: Math.min(100, Math.max(0, (averageDailyCalories / calorieTarget) * 100)),
        consistencyScore: orders.length > 1 ? 75 : 25,
        varietyScore: Math.min(100, Object.keys(foodGroups).length * 15),
        balanceScore: 80 // Calculated based on macro balance
      },
      trends: [], // Would be calculated from historical data
      distribution: {
        mealTypes: { breakfast: 5, lunch: 80, dinner: 10, snacks: 5 },
        foodGroups,
        cookingMethods: { grilled: 30, steamed: 25, fried: 20, raw: 15, baked: 10 },
        cuisineTypes: { indian: 80, continental: 15, chinese: 5 }
      },
      quality: {
        overallScore: 75,
        processingScore: 70,
        diversityScore: Math.min(100, Object.keys(foodGroups).length * 15),
        nutrientDensityScore: 80,
        adequacyScore: Math.min(100, (averageDailyCalories / calorieTarget) * 100)
      },
      micronutrients: {
        vitamins: {
          'vitamin_c': { current: 45, target: 65, adequacy: 69 },
          'vitamin_d': { current: 15, target: 20, adequacy: 75 },
          'vitamin_b12': { current: 2.1, target: 2.4, adequacy: 88 }
        },
        minerals: {
          'iron': { current: 8, target: 10, adequacy: 80 },
          'calcium': { current: 800, target: 1000, adequacy: 80 },
          'zinc': { current: 7, target: 8, adequacy: 88 }
        },
        deficiencyRisks: [],
        supplementationNeeds: []
      },
      hydration: {
        averageDailyIntake: 1500, // ml
        target: age * 35 + 500, // ml
        adequacy: 85,
        sources: { water: 70, milk: 20, juice: 10 },
        patterns: ['Adequate morning hydration', 'Lower evening intake']
      },
      timing: {
        averageMealTimes: {
          breakfast: '08:00',
          lunch: '12:30',
          dinner: '19:00',
          snacks: '16:00'
        },
        consistency: 75,
        intervalAnalysis: { average: 4.5, variability: 1.2 },
        recommendations: ['Maintain consistent lunch timing', 'Add healthy evening snack']
      }
    };

    return nutritionAnalytics;

  } catch (error: unknown) {
    logger.error('Failed to analyze nutrition data', {
      childId,
      dateRange,
      error: (error as Error).message
    });

    // Return minimal analytics on error
    return {
      summary: {
        period: 'Error retrieving data',
        averageDailyCalories: 0,
        averageMacros: {
          protein: { grams: 0, percentage: 0, target: 0 },
          carbohydrates: { grams: 0, percentage: 0, target: 0 },
          fats: { grams: 0, percentage: 0, target: 0 },
          fiber: { grams: 0, target: 0 }
        },
        nutritionScore: 0,
        consistencyScore: 0,
        varietyScore: 0,
        balanceScore: 0
      },
      trends: [],
      distribution: {
        mealTypes: { breakfast: 0, lunch: 0, dinner: 0, snacks: 0 },
        foodGroups: {},
        cookingMethods: {},
        cuisineTypes: {}
      },
      quality: {
        overallScore: 0,
        processingScore: 0,
        diversityScore: 0,
        nutrientDensityScore: 0,
        adequacyScore: 0
      },
      micronutrients: {
        vitamins: {},
        minerals: {},
        deficiencyRisks: [],
        supplementationNeeds: []
      },
      hydration: {
        averageDailyIntake: 0,
        target: 0,
        adequacy: 0,
        sources: {},
        patterns: []
      },
      timing: {
        averageMealTimes: {},
        consistency: 0,
        intervalAnalysis: { average: 0, variability: 0 },
        recommendations: []
      }
    };
  }
}

/**
 * Analyze meal history and patterns
 */
async function analyzeMealHistory(
  childId: string,
  dateRange?: { startDate: string; endDate: string }
): Promise<MealHistoryAnalytics> {
  try {
    const endDate = dateRange?.endDate ? new Date(dateRange.endDate) : new Date();
    const startDate = dateRange?.startDate ? new Date(dateRange.startDate) : new Date(endDate.getTime() - 30 * 24 * 60 * 60 * 1000);

    // Get detailed order history
    const orders = await db.prisma.order.findMany({
      where: {
        userId: childId,
        createdAt: {
          gte: startDate,
          lte: endDate
        }
      },
      include: {
        orderItems: {
          include: {
            menuItem: {
              select: {
                id: true,
                name: true,
                category: true,
                nutritionalInfo: true,
                price: true
              }
            }
          }
        }
      },
      orderBy: { createdAt: 'desc' }
    });

    // Analyze favorite items
    const itemFrequency: Record<string, { count: number; item: any; lastOrdered: Date }> = {};
    orders.forEach(order => {
      order.orderItems.forEach(item => {
        const itemName = item.menuItem.name;
        if (itemFrequency[itemName]) {
          itemFrequency[itemName].count += item.quantity;
          if (order.createdAt > itemFrequency[itemName].lastOrdered) {
            itemFrequency[itemName].lastOrdered = order.createdAt;
          }
        } else {
          itemFrequency[itemName] = {
            count: item.quantity,
            item: item.menuItem,
            lastOrdered: order.createdAt
          };
        }
      });
    });

    const favoriteItems: FavoriteItem[] = Object.entries(itemFrequency)
      .sort(([, a], [, b]) => b.count - a.count)
      .slice(0, 10)
      .map(([name, data]) => {
        let nutritionScore = 50;
        try {
          const nutrition = JSON.parse(data.item.nutritionalInfo || '{}');
          nutritionScore = Math.min(100, Math.max(0,
            (nutrition.protein || 0) * 2 +
            (nutrition.fiber || 0) * 3 +
            Math.max(0, 50 - (nutrition.sugar || 0))
          ));
        } catch (e) {
          // Use default score
        }

        return {
          name,
          category: data.item.category || 'other',
          frequency: data.count,
          nutritionScore,
          lastOrdered: data.lastOrdered
        };
      });

    // Analyze meal patterns
    const daysInPeriod = Math.max(1, (endDate.getTime() - startDate.getTime()) / (24 * 60 * 60 * 1000));
    const averageMealsPerDay = orders.length / daysInPeriod;

    // Analyze ordering behavior
    const orderDays = orders.map(order => order.createdAt.getDay());
    const dayFrequency = orderDays.reduce((acc, day) => {
      acc[day] = (acc[day] || 0) + 1;
      return acc;
    }, {} as Record<number, number>);

    const patterns: MealPattern[] = [
      {
        pattern: 'Regular lunch orders',
        frequency: averageMealsPerDay,
        reliability: orders.length > 5 ? 0.8 : 0.4,
        triggers: ['School schedule', 'Hunger patterns']
      }
    ];

    // Add weekday patterns
    const weekdayOrders = orders.filter(order => {
      const day = order.createdAt.getDay();
      return day >= 1 && day <= 5;
    }).length;

    if (weekdayOrders > orders.length * 0.8) {
      patterns.push({
        pattern: 'Weekday ordering preference',
        frequency: weekdayOrders / (daysInPeriod * 5/7),
        reliability: 0.9,
        triggers: ['School attendance', 'Routine']
      });
    }

    // Analyze preferences by category
    const categoryFrequency: Record<string, number> = {};
    orders.forEach(order => {
      order.orderItems.forEach(item => {
        const category = item.menuItem.category || 'other';
        categoryFrequency[category] = (categoryFrequency[category] || 0) + item.quantity;
      });
    });

    const categoryPreferences: CategoryPreference[] = Object.entries(categoryFrequency)
      .map(([category, frequency]) => ({
        category,
        preference: Math.min(1, frequency / 10),
        frequency,
        trend: 'stable' as const
      }))
      .sort((a, b) => b.frequency - a.frequency);

    const mealHistoryAnalytics: MealHistoryAnalytics = {
      summary: {
        totalMealsTracked: orders.length,
        averageMealsPerDay,
        favoriteItems,
        leastFavoriteItems: [], // Would need additional analysis
        skipPatterns: [] // Would need attendance data
      },
      patterns,
      preferences: {
        categories: categoryPreferences,
        flavors: [], // Would need detailed flavor analysis
        textures: [], // Would need texture data
        temperatures: [], // Would need temperature preferences
        evolution: {
          newAcceptances: [],
          developingPreferences: [],
          fadingPreferences: [],
          consistentPreferences: favoriteItems.slice(0, 3).map((item: any) => item.name)
        }
      },
      ordering: {
        frequency: averageMealsPerDay,
        consistency: orders.length > 5 ? 0.7 : 0.3,
        planning: {
          advanceOrdering: 0.5, // Would need order time analysis
          repeatOrders: favoriteItems.length > 0 ? 0.8 : 0.2,
          varietySeeking: Math.min(1, categoryPreferences.length / 5),
          spontaneity: 0.4
        },
        influences: [
          {
            factor: 'Menu availability',
            impact: 0.8,
            direction: 'positive'
          },
          {
            factor: 'Peer influence',
            impact: 0.6,
            direction: 'positive'
          }
        ]
      },
      satisfaction: {
        overallSatisfaction: 4.0,
        tasteRating: 4.2,
        varietyRating: 3.8,
        nutritionRating: 3.9,
        portionRating: 4.1,
        feedback: []
      }
    };

    return mealHistoryAnalytics;

  } catch (error: unknown) {
    logger.error('Failed to analyze meal history', {
      childId,
      dateRange,
      error: (error as Error).message
    });

    // Return minimal analytics on error
    return {
      summary: {
        totalMealsTracked: 0,
        averageMealsPerDay: 0,
        favoriteItems: [],
        leastFavoriteItems: [],
        skipPatterns: []
      },
      patterns: [],
      preferences: {
        categories: [],
        flavors: [],
        textures: [],
        temperatures: [],
        evolution: {
          newAcceptances: [],
          developingPreferences: [],
          fadingPreferences: [],
          consistentPreferences: []
        }
      },
      ordering: {
        frequency: 0,
        consistency: 0,
        planning: {
          advanceOrdering: 0,
          repeatOrders: 0,
          varietySeeking: 0,
          spontaneity: 0
        },
        influences: []
      },
      satisfaction: {
        overallSatisfaction: 0,
        tasteRating: 0,
        varietyRating: 0,
        nutritionRating: 0,
        portionRating: 0,
        feedback: []
      }
    };
  }
}

/**
 * Calculate progress metrics and goals
 */
async function calculateProgressMetrics(
  childId: string,
  nutritionAnalytics: NutritionAnalytics
): Promise<ProgressMetrics> {
  try {
    // Get child's goals - Note: nutritionGoal model doesn't exist in current schema
    // This would need to be implemented as a separate feature
    const goals: any[] | undefined = [];

    const goalProgress: GoalProgress[] = goals.map(goal => {
      let current = 0;
      let progress = 0;

      // Calculate current value based on goal type
      switch (goal.type) {
        case 'daily_calories':
          current = nutritionAnalytics.summary.averageDailyCalories;
          break;
        case 'protein_intake':
          current = nutritionAnalytics.summary.averageMacros.protein.grams;
          break;
        case 'fiber_intake':
          current = nutritionAnalytics.summary.averageMacros.fiber.grams;
          break;
        default:
          current = 0;
      }

      progress = goal.target > 0 ? Math.min(100, (current / goal.target) * 100) : 0;

      let status: 'on_track' | 'behind' | 'ahead' | 'completed' = 'on_track';
      if (progress >= 100) status = 'completed';
      else if (progress >= 80) status = 'on_track';
      else if (progress >= 60) status = 'behind';
      else status = 'behind';

      return {
        goalId: goal.id,
        goalType: goal.type,
        description: goal.description || `${goal.type} goal`,
        target: goal.target,
        current,
        progress,
        timeframe: goal.timeframe || 'ongoing',
        status,
        trajectory: progress > 75 ? 'improving' : progress > 50 ? 'stable' : 'declining',
        lastUpdated: new Date()
      };
    });

    // Calculate overall progress
    const averageProgress = goalProgress.length > 0
      ? goalProgress.reduce((sum, goal) => sum + goal.progress, 0) / goalProgress.length
      : 0;

    const overallProgress: OverallProgressSummary = {
      score: averageProgress,
      trend: averageProgress > 75 ? 'improving' : averageProgress > 50 ? 'stable' : 'declining',
      strengths: [
        nutritionAnalytics.summary.nutritionScore > 75 ? 'Good calorie intake' : '',
        nutritionAnalytics.summary.varietyScore > 60 ? 'Good food variety' : '',
        nutritionAnalytics.summary.consistencyScore > 70 ? 'Consistent meal patterns' : ''
      ].filter(Boolean),
      areasForImprovement: [
        nutritionAnalytics.summary.nutritionScore < 60 ? 'Increase calorie intake' : '',
        nutritionAnalytics.summary.varietyScore < 40 ? 'Try more food varieties' : '',
        nutritionAnalytics.quality.adequacyScore < 70 ? 'Improve nutrition adequacy' : ''
      ].filter(Boolean),
      nextMilestones: [
        'Achieve daily calorie target',
        'Try 3 new food categories',
        'Maintain consistent meal timing'
      ]
    };

    return {
      nutritionalGoals: goalProgress,
      developmentalMilestones: [], // Would require additional developmental data
      behavioralProgress: [], // Would require behavioral tracking
      academicCorrelations: [], // Would require academic performance data
      overallProgress
    };

  } catch (error: unknown) {
    logger.error('Failed to calculate progress metrics', {
      childId,
      error: (error as Error).message
    });

    return {
      nutritionalGoals: [],
      developmentalMilestones: [],
      behavioralProgress: [],
      academicCorrelations: [],
      overallProgress: {
        score: 0,
        trend: 'stable',
        strengths: [],
        areasForImprovement: [],
        nextMilestones: []
      }
    };
  }
}

/**
 * Get growth data and analysis
 */
async function getGrowthData(childId: string): Promise<GrowthData> {
  try {
    // Get growth measurements - Note: growthMeasurement model doesn't exist in current schema
    // This would need to be implemented as a separate feature
    const measurements: any[] | undefined = [];

    const latest = measurements[0];
    if (!latest) {
      return {
        height: { current: 0, unit: 'cm', history: [], trend: 'normal', percentile: 50 },
        weight: { current: 0, unit: 'kg', history: [], trend: 'normal', percentile: 50 },
        bmi: { current: 0, unit: 'kg/m²', history: [], trend: 'normal', percentile: 50 },
        growthVelocity: {
          height: { value: 0, percentile: 50, normal: true },
          weight: { value: 0, percentile: 50, normal: true }
        },
        percentiles: { height: 50, weight: 50, bmi: 50 },
        projections: []
      };
    }

    const heightHistory = measurements.map(m => ({
      date: m.measuredAt,
      value: m.height,
      source: m.source || 'manual',
      verified: m.verified || false
    }));

    const weightHistory = measurements.map(m => ({
      date: m.measuredAt,
      value: m.weight,
      source: m.source || 'manual',
      verified: m.verified || false
    }));

    const bmiHistory = measurements.map(m => ({
      date: m.measuredAt,
      value: m.weight / Math.pow(m.height / 100, 2),
      source: m.source || 'manual',
      verified: m.verified || false
    }));

    // Calculate growth velocity (if we have at least 2 measurements)
    let heightVelocity = 0;
    let weightVelocity = 0;

    if (measurements.length >= 2) {
      const timeDiff = (latest.measuredAt.getTime() - measurements[1].measuredAt.getTime()) / (365.25 * 24 * 60 * 60 * 1000);
      heightVelocity = (latest.height - measurements[1].height) / timeDiff;
      weightVelocity = (latest.weight - measurements[1].weight) / timeDiff;
    }

    const currentBmi = latest.weight / Math.pow(latest.height / 100, 2);

    return {
      height: {
        current: latest.height,
        unit: 'cm',
        history: heightHistory,
        trend: heightVelocity > 0 ? 'normal' : 'slow',
        percentile: latest.heightPercentile || 50
      },
      weight: {
        current: latest.weight,
        unit: 'kg',
        history: weightHistory,
        trend: weightVelocity > 0 ? 'normal' : 'slow',
        percentile: latest.weightPercentile || 50
      },
      bmi: {
        current: currentBmi,
        unit: 'kg/m²',
        history: bmiHistory,
        trend: 'normal',
        percentile: latest.bmiPercentile || 50
      },
      growthVelocity: {
        height: {
          value: heightVelocity,
          percentile: 50,
          normal: heightVelocity >= 4 && heightVelocity <= 7
        },
        weight: {
          value: weightVelocity,
          percentile: 50,
          normal: weightVelocity >= 1 && weightVelocity <= 4
        }
      },
      percentiles: {
        height: latest.heightPercentile || 50,
        weight: latest.weightPercentile || 50,
        bmi: latest.bmiPercentile || 50
      },
      projections: [] // Would require complex growth modeling
    };

  } catch (error: unknown) {
    logger.error('Failed to get growth data', {
      childId,
      error: (error as Error).message
    });

    return {
      height: { current: 0, unit: 'cm', history: [], trend: 'normal', percentile: 50 },
      weight: { current: 0, unit: 'kg', history: [], trend: 'normal', percentile: 50 },
      bmi: { current: 0, unit: 'kg/m²', history: [], trend: 'normal', percentile: 50 },
      growthVelocity: {
        height: { value: 0, percentile: 50, normal: true },
        weight: { value: 0, percentile: 50, normal: true }
      },
      percentiles: { height: 50, weight: 50, bmi: 50 },
      projections: []
    };
  }
}

/**
 * Generate progress insights
 */
function generateProgressInsights(
  nutritionAnalytics: NutritionAnalytics,
  progressMetrics: ProgressMetrics,
  mealHistory: MealHistoryAnalytics
): ProgressInsights {
  const keyFindings: string[] = [];
  const positiveAspects: string[] = [];
  const concernAreas: string[] = [];

  // Key findings
  if (nutritionAnalytics.summary.nutritionScore > 80) {
    keyFindings.push('Excellent overall nutrition score indicates well-balanced diet');
  } else if (nutritionAnalytics.summary.nutritionScore < 60) {
    keyFindings.push('Nutrition score below optimal range requires attention');
  }

  if (mealHistory.summary.averageMealsPerDay > 0.8) {
    keyFindings.push('Consistent meal ordering shows good routine establishment');
  }

  // Positive aspects
  if (nutritionAnalytics.summary.varietyScore > 70) {
    positiveAspects.push('Great food variety exploration');
  }

  if (nutritionAnalytics.summary.consistencyScore > 70) {
    positiveAspects.push('Excellent meal timing consistency');
  }

  if (mealHistory.summary.favoriteItems.length > 3) {
    positiveAspects.push('Well-established food preferences');
  }

  // Concern areas
  if (nutritionAnalytics.summary.averageMacros.protein.grams < nutritionAnalytics.summary.averageMacros.protein.target * 0.8) {
    concernAreas.push('Protein intake below recommended levels');
  }

  if (nutritionAnalytics.summary.varietyScore < 40) {
    concernAreas.push('Limited food variety may affect nutrient diversity');
  }

  if (nutritionAnalytics.hydration.adequacy < 70) {
    concernAreas.push('Hydration levels need improvement');
  }

  return {
    keyFindings,
    positiveAspects,
    concernAreas,
    trendAnalysis: [
      'Meal ordering patterns show strong weekday consistency',
      'Protein intake has potential for improvement',
      'Food variety exploration is progressing well'
    ],
    predictiveInsights: [
      'Continued current patterns will support healthy growth',
      'Adding protein-rich snacks could optimize nutrition balance',
      'Expanding food categories will enhance nutrient diversity'
    ]
  };
}

/**
 * Generate progress recommendations
 */
function generateProgressRecommendations(
  childInfo: ChildInfo,
  nutritionAnalytics: NutritionAnalytics,
  progressMetrics: ProgressMetrics
): ProgressRecommendation[] {
  const recommendations: ProgressRecommendation[] = [];

  // Protein intake recommendation
  if (nutritionAnalytics.summary.averageMacros.protein.grams < nutritionAnalytics.summary.averageMacros.protein.target * 0.8) {
    recommendations.push({
      id: `rec_protein_${childInfo.id}_${Date.now()}`,
      category: 'nutrition',
      priority: 'high',
      recommendation: 'Increase daily protein intake through diverse sources',
      rationale: `Current protein intake (${nutritionAnalytics.summary.averageMacros.protein.grams.toFixed(1)}g) is below the recommended target (${nutritionAnalytics.summary.averageMacros.protein.target.toFixed(1)}g) for optimal growth and development`,
      expectedOutcome: 'Improved muscle development, better satiety, and enhanced growth velocity',
      timeframe: '3-4 weeks',
      actionSteps: [
        'Add one protein-rich snack daily (nuts, yogurt, or boiled eggs)',
        'Include a protein source in every meal (dal, paneer, chicken, or fish)',
        'Try protein-rich traditional Indian foods like besan chilla or sprouted moong',
        'Monitor protein intake weekly using nutrition tracking'
      ],
      monitoringPlan: 'Weekly review of meal choices and protein content analysis'
    });
  }

  // Variety recommendation
  if (nutritionAnalytics.summary.varietyScore < 60) {
    recommendations.push({
      id: `rec_variety_${childInfo.id}_${Date.now()}`,
      category: 'nutrition',
      priority: 'medium',
      recommendation: 'Expand food variety to include more diverse nutrient sources',
      rationale: `Current variety score (${nutritionAnalytics.summary.varietyScore}) indicates limited food exploration, which may impact nutrient diversity`,
      expectedOutcome: 'Enhanced micronutrient intake, reduced risk of nutritional deficiencies, and improved eating flexibility',
      timeframe: '4-6 weeks',
      actionSteps: [
        'Introduce one new food item each week',
        'Try different preparations of familiar foods',
        'Explore seasonal fruits and vegetables',
        'Include foods from different food groups in each meal'
      ],
      monitoringPlan: 'Bi-weekly assessment of food categories tried and accepted'
    });
  }

  // Hydration recommendation
  if (nutritionAnalytics.hydration.adequacy < 70) {
    recommendations.push({
      id: `rec_hydration_${childInfo.id}_${Date.now()}`,
      category: 'hydration',
      priority: 'medium',
      recommendation: 'Improve daily hydration through structured water intake',
      rationale: `Current hydration adequacy (${nutritionAnalytics.hydration.adequacy}%) is below optimal levels for age and activity`,
      expectedOutcome: 'Better cognitive function, improved digestion, and enhanced physical performance',
      timeframe: '2-3 weeks',
      actionSteps: [
        'Set reminders for regular water intake throughout the day',
        'Include water-rich foods like fruits and soups',
        'Carry a water bottle to school',
        'Monitor urine color as a hydration indicator'
      ],
      monitoringPlan: 'Daily hydration tracking with weekly adequacy assessment'
    });
  }

  return recommendations;
}

/**
 * Aggregate complete child progress analytics
 */
async function aggregateChildProgressAnalytics(
  childId: string,
  options: {
    dateRange?: { startDate: string; endDate: string };
    includeNutrition?: boolean;
    includeMealHistory?: boolean;
    includeProgress?: boolean;
    includeComparisons?: boolean;
  }
): Promise<ChildProgressAnalytics> {
  try {
    const startTime = Date.now();

    // Get child information
    const childData = await validateChildAccess(childId, { id: childId, role: 'parent' } as AuthenticatedUser);
    const childInfo = await getChildInfo(childData);

    // Get analytics components in parallel
    const [
      nutritionAnalytics,
      mealHistoryAnalytics,
      growthData
    ] = await Promise.all([
      options.includeNutrition ? analyzeNutritionData(childId, options.dateRange) : Promise.resolve({} as NutritionAnalytics),
      options.includeMealHistory ? analyzeMealHistory(childId, options.dateRange) : Promise.resolve({} as MealHistoryAnalytics),
      getGrowthData(childId)
    ]);

    // Calculate progress metrics
    const progressMetrics = options.includeProgress
      ? await calculateProgressMetrics(childId, nutritionAnalytics)
      : {} as ProgressMetrics;

    // Generate insights and recommendations
    const insights = generateProgressInsights(nutritionAnalytics, progressMetrics, mealHistoryAnalytics);
    const recommendations = generateProgressRecommendations(childInfo, nutritionAnalytics, progressMetrics);

    const processingTime = Date.now() - startTime;

    const analytics: ChildProgressAnalytics = {
      childInfo,
      nutritionAnalytics,
      mealHistoryAnalytics,
      progressMetrics,
      growthData,
      goalsTracking: {
        activeGoals: [],
        completedGoals: [],
        upcomingGoals: [],
        goalStatistics: {
          totalGoals: 0,
          completionRate: 0,
          averageCompletionTime: 0,
          successFactors: [],
          challengeFactors: []
        }
      },
      comparativeAnalysis: options.includeComparisons ? {
        peerComparison: {
          nutritionRanking: 0,
          progressRanking: 0,
          strengths: [],
          improvementAreas: [],
          anonymizedData: true
        },
        historicalComparison: {
          yearOverYear: { metric: '', previousValue: 0, currentValue: 0, change: 0, significance: '' },
          seasonalPatterns: [],
          significantChanges: []
        },
        standardsComparison: {
          nationalStandards: [],
          whoStandards: [],
          schoolStandards: []
        }
      } : undefined,
      insights,
      recommendations,
      metadata: {
        generatedAt: new Date(),
        dataRange: {
          start: options.dateRange?.startDate ? new Date(options.dateRange.startDate) : new Date(Date.now() - 30 * 24 * 60 * 60 * 1000),
          end: options.dateRange?.endDate ? new Date(options.dateRange.endDate) : new Date()
        },
        dataQuality: 0.85,
        confidence: 0.8,
        limitations: [
          'Analysis based on available meal ordering data',
          'Growth data depends on measurement frequency',
          'Peer comparisons require sufficient sample size'
        ],
        nextUpdateDue: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000),
        version: '1.0.0'
      }
    };

    logger.info('Child progress analytics generated successfully', {
      childId,
      processingTime: `${processingTime}ms`,
      dataQuality: analytics.metadata.dataQuality,
      recommendationsCount: recommendations.length
    });

    return analytics;

  } catch (error: unknown) {
    logger.error('Failed to aggregate child progress analytics', {
      childId,
      options,
      error: (error as Error).message
    });
    throw error;
  }
}

/**
 * Child Progress Analytics Lambda Handler
 */
export const childProgressAnalyticsHandler = async (
  event: APIGatewayProxyEvent,
  context: Context
): Promise<APIGatewayProxyResult> => {
  const requestId = context.awsRequestId;
  const startTime = Date.now();

  try {
    logger.info('Child progress analytics request started', {
      requestId,
      method: event.httpMethod,
      path: event.path
    });

    // Authenticate request
    const authResult = await authenticateLambda(event);
    if (!authResult.success || !authResult.user) {
      return createErrorResponse(401, 'Authentication failed');
    }
    const authenticatedUser = authResult.user;

    switch (event.httpMethod) {
      case 'POST':
        return await handleGetProgress(event, requestId, authenticatedUser);
      case 'PUT':
        return await handleUpdateGoal(event, requestId, authenticatedUser);
      case 'PATCH':
        return await handleUpdateProgress(event, requestId, authenticatedUser);
      default:
        return createErrorResponse(405, 'Method not allowed');
    }

  } catch (error: unknown) {
    const duration = Date.now() - startTime;
    logger.error('Child progress analytics request failed', {
      requestId,
      duration: `${duration}ms`,
      error: (error as Error).message,
      stack: (error as Error).stack
    });

    return handleError(error as Error, 'Failed to process progress analytics request', 500, requestId);
  }
};

/**
 * Handle get progress analytics request
 */
async function handleGetProgress(
  event: APIGatewayProxyEvent,
  requestId: string,
  authenticatedUser: AuthenticatedUser
): Promise<APIGatewayProxyResult> {
  try {
    // Parse and validate request body
    const requestBody = JSON.parse(event.body || '{}');
    const validatedData = progressRequestSchema.parse(requestBody);

    // Validate child access
    await validateChildAccess(validatedData.childId, authenticatedUser);

    // Generate progress analytics
    const analytics = await aggregateChildProgressAnalytics(
      validatedData.childId,
      {
        dateRange: validatedData.dateRange,
        includeNutrition: validatedData.includeNutrition,
        includeMealHistory: validatedData.includeMealHistory,
        includeProgress: validatedData.includeProgress,
        includeComparisons: validatedData.includeComparisons
      }
    );

    logger.info('Progress analytics generated successfully', {
      requestId,
      childId: validatedData.childId,
      dataQuality: analytics.metadata.dataQuality
    });

    return createSuccessResponse(
      {
        analytics,
        message: 'Child progress analytics generated successfully'
      },
      'Child progress analytics retrieved successfully',
      200,
      requestId
    );

  } catch (error: unknown) {
    logger.error('Failed to get progress analytics', {
      requestId,
      error: (error as Error).message
    });
    throw error;
  }
}

/**
 * Handle update goal request
 */
async function handleUpdateGoal(
  event: APIGatewayProxyEvent,
  requestId: string,
  authenticatedUser: AuthenticatedUser
): Promise<APIGatewayProxyResult> {
  try {
    // Parse and validate request body
    const requestBody = JSON.parse(event.body || '{}');
    const validatedData = goalUpdateSchema.parse(requestBody);

    // Validate child access
    await validateChildAccess(validatedData.childId, authenticatedUser);

    // Create or update goal - Note: nutritionGoal model doesn't exist in current schema
    // This would need to be implemented as a separate feature
    const goalId = `goal_${validatedData.goalType}_${validatedData.childId}_${Date.now()}`;

    const goal = {
      id: goalId,
      childId: validatedData.childId,
      type: validatedData.goalType,
      target: validatedData.targetValue,
      description: validatedData.description,
      timeframe: 'monthly',
      status: 'active',
      createdBy: authenticatedUser.id,
      createdAt: new Date(),
      updatedAt: new Date()
    };

    logger.info('Goal updated successfully', {
      requestId,
      childId: validatedData.childId,
      goalType: validatedData.goalType,
      goalId: goal.id
    });

    return createSuccessResponse(
      {
        goal,
        message: 'Goal updated successfully'
      },
      'Goal updated successfully',
      200,
      requestId
    );

  } catch (error: unknown) {
    logger.error('Failed to update goal', {
      requestId,
      error: (error as Error).message
    });
    throw error;
  }
}

/**
 * Handle update progress request
 */
async function handleUpdateProgress(
  event: APIGatewayProxyEvent,
  requestId: string,
  authenticatedUser: AuthenticatedUser
): Promise<APIGatewayProxyResult> {
  try {
    // Parse and validate request body
    const requestBody = JSON.parse(event.body || '{}');
    const validatedData = progressUpdateSchema.parse(requestBody);

    // Validate child access
    await validateChildAccess(validatedData.childId, authenticatedUser);

    // Create progress entry - Note: progressEntry model doesn't exist in current schema
    // This would need to be implemented as a separate feature
    const progressEntryId = `progress_${validatedData.childId}_${Date.now()}`;

    const progressEntry = {
      id: progressEntryId,
      childId: validatedData.childId,
      metricType: validatedData.metricType,
      value: validatedData.value,
      recordedAt: new Date(validatedData.date),
      notes: validatedData.notes,
      createdBy: authenticatedUser.id,
      createdAt: new Date(),
      updatedAt: new Date()
    };

    logger.info('Progress updated successfully', {
      requestId,
      childId: validatedData.childId,
      metricType: validatedData.metricType,
      value: validatedData.value
    });

    return createSuccessResponse(
      {
        progressEntry,
        message: 'Progress updated successfully'
      },
      'Progress updated successfully',
      200,
      requestId
    );

  } catch (error: unknown) {
    logger.error('Failed to update progress', {
      requestId,
      error: (error as Error).message
    });
    throw error;
  }
}