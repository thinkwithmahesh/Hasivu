/**
 * HASIVU Platform - Get Menu Item By ID Lambda Function
 * Handles: GET /menu/items/{id}
 * Implements Story 2.1: Product Catalog Foundation - Individual Menu Item Retrieval
 * Production-ready with comprehensive validation and error handling
 */

import { APIGatewayProxyEvent, APIGatewayProxyResult, Context } from 'aws-lambda';
import { LoggerService } from '../shared/logger.service';
import { ValidationService } from '../shared/validation.service';
import { createSuccessResponse, createErrorResponse, handleError } from '../../shared/response.utils';
import { DatabaseService } from '../../services/database.service';

/**
 * Menu item interface with all fields
 */
interface MenuItemDetails {
  id: string;
  name: string;
  description: string;
  category: string;
  price: number;
  schoolId: string;
  nutritionalInfo: Record<string, any>;
  allergens: string[];
  isVegetarian: boolean;
  isVegan: boolean;
  isGlutenFree: boolean;
  isDairyFree: boolean;
  ingredients: string[];
  servingSize: string;
  preparationTime: number; // minutes
  availableDays: string[];
  customizations: Record<string, any>;
  images: string[];
  isActive: boolean;
  createdAt: Date;
  updatedAt: Date;
  school?: {
    id: string;
    name: string;
    code: string;
  };
}

/**
 * Get menu item with detailed information including school data
 */
async function getMenuItemWithDetails(menuItemId: string): Promise<MenuItemDetails | null> {
  const database = DatabaseService.getInstance();
  
  const query = `
    SELECT 
      mi.id, mi.name, mi.description, mi.category, mi.price, mi.schoolId,
      mi.nutritionalInfo, mi.allergens, mi.isVegetarian, mi.isVegan,
      mi.isGlutenFree, mi.isDairyFree, mi.ingredients, mi.servingSize,
      mi.preparationTime, mi.availableDays, mi.customizations,
      mi.images, mi.isActive, mi.createdAt, mi.updatedAt,
      s.id as school_id, s.name as school_name, s.code as school_code
    FROM menu_items mi
    LEFT JOIN schools s ON mi.schoolId = s.id
    WHERE mi.id = $1 AND mi.isActive = true
  `;
  
  const result = await database.query(query, [menuItemId]);
  
  if (result.rows.length === 0) {
    return null;
  }
  
  const row = result.rows[0];
  
  return {
    id: row.id,
    name: row.name,
    description: row.description,
    category: row.category,
    price: row.price,
    schoolId: row.schoolId,
    nutritionalInfo: row.nutritionalInfo,
    allergens: row.allergens,
    isVegetarian: row.isVegetarian,
    isVegan: row.isVegan,
    isGlutenFree: row.isGlutenFree,
    isDairyFree: row.isDairyFree,
    ingredients: row.ingredients,
    servingSize: row.servingSize,
    preparationTime: row.preparationTime,
    availableDays: row.availableDays,
    customizations: row.customizations,
    images: row.images,
    isActive: row.isActive,
    createdAt: row.createdAt,
    updatedAt: row.updatedAt,
    school: row.school_id ? {
      id: row.school_id,
      name: row.school_name,
      code: row.school_code
    } : undefined
  };
}

/**
 * Get availability status for a menu item
 */
async function getMenuItemAvailability(menuItemId: string): Promise<{
  isAvailableToday: boolean;
  nextAvailableDate: string | null;
  preparationTime: number;
}> {
  const database = DatabaseService.getInstance();
  
  // Get current day of week (0 = Sunday, 1 = Monday, etc.)
  const today = new Date();
  const dayNames = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];
  const todayName = dayNames[today.getDay()];
  
  const query = `
    SELECT availableDays, preparationTime
    FROM menu_items
    WHERE id = $1 AND isActive = true
  `;
  
  const result = await database.query(query, [menuItemId]);
  
  if (result.rows.length === 0) {
    return {
      isAvailableToday: false,
      nextAvailableDate: null,
      preparationTime: 0
    };
  }
  
  const { availableDays, preparationTime } = result.rows[0];
  const isAvailableToday = availableDays.includes(todayName);
  
  // Find next available date if not available today
  let nextAvailableDate = null;
  if (!isAvailableToday && availableDays.length > 0) {
    for (let i = 1; i <= 7; i++) {
      const futureDate = new Date(today);
      futureDate.setDate(today.getDate() + i);
      const futureDayName = dayNames[futureDate.getDay()];
      
      if (availableDays.includes(futureDayName)) {
        nextAvailableDate = futureDate.toISOString().split('T')[0]; // YYYY-MM-DD format
        break;
      }
    }
  }
  
  return {
    isAvailableToday,
    nextAvailableDate,
    preparationTime
  };
}

/**
 * Get Menu Item By ID Lambda Function Handler
 * Retrieves a single menu item by its ID with detailed information
 */
export const getMenuItemByIdHandler = async (
  event: APIGatewayProxyEvent,
  context: Context
): Promise<APIGatewayProxyResult> => {
  const logger = LoggerService.getInstance();
  const requestId = context.awsRequestId;
  const startTime = Date.now();
  
  try {
    logger.info('Get menu item by ID request started', { requestId });
    
    // Only allow GET method
    if (event.httpMethod !== 'GET') {
      return createErrorResponse('Method not allowed', 405, 'METHOD_NOT_ALLOWED');
    }
    
    // Extract and validate menu item ID from path parameters
    const menuItemId = event.pathParameters?.id;
    if (!menuItemId) {
      logger.warn('Missing menu item ID in path parameters', { requestId });
      return createErrorResponse('Menu item ID is required', 400, 'MISSING_MENU_ITEM_ID');
    }
    
    // Validate UUID format
    const validationService = ValidationService.getInstance();
    try {
      validationService.validateUUID(menuItemId, 'Menu item ID');
    } catch (error: any) {
      logger.warn('Invalid menu item ID format', { requestId, menuItemId, error: error instanceof Error ? error.message : String(error) });
      return createErrorResponse('Invalid menu item ID format', 400, 'INVALID_MENU_ITEM_ID');
    }
    
    logger.info('Processing get menu item by ID request', { requestId, menuItemId });
    
    // Get menu item with detailed information
    const menuItem = await getMenuItemWithDetails(menuItemId);
    
    if (!menuItem) {
      logger.warn('Menu item not found', { requestId, menuItemId });
      return createErrorResponse('Menu item not found', 404, 'MENU_ITEM_NOT_FOUND');
    }
    
    // Get availability information
    const availability = await getMenuItemAvailability(menuItemId);
    
    const duration = Date.now() - startTime;
    logger.info('Menu item retrieved successfully', {
      requestId,
      menuItemId,
      menuItemName: menuItem.name,
      schoolId: menuItem.schoolId,
      duration: `${duration}ms`
    });
    
    return createSuccessResponse({
      data: {
        menuItem: {
          // Basic information
          id: menuItem.id,
          name: menuItem.name,
          description: menuItem.description,
          category: menuItem.category,
          price: menuItem.price,
          
          // Dietary information
          nutritionalInfo: menuItem.nutritionalInfo,
          allergens: menuItem.allergens,
          isVegetarian: menuItem.isVegetarian,
          isVegan: menuItem.isVegan,
          isGlutenFree: menuItem.isGlutenFree,
          isDairyFree: menuItem.isDairyFree,
          
          // Preparation information
          ingredients: menuItem.ingredients,
          servingSize: menuItem.servingSize,
          preparationTime: menuItem.preparationTime,
          customizations: menuItem.customizations,
          
          // Availability information
          availableDays: menuItem.availableDays,
          isAvailableToday: availability.isAvailableToday,
          nextAvailableDate: availability.nextAvailableDate,
          
          // Media and metadata
          images: menuItem.images,
          isActive: menuItem.isActive,
          createdAt: menuItem.createdAt,
          updatedAt: menuItem.updatedAt,
          
          // School information
          school: menuItem.school
        },
        
        // Additional context
        availability: {
          isAvailableToday: availability.isAvailableToday,
          nextAvailableDate: availability.nextAvailableDate,
          estimatedPreparationTime: `${availability.preparationTime} minutes`
        }
      },
      message: 'Menu item retrieved successfully'
    });
    
  } catch (error: any) {
    const duration = Date.now() - startTime;
    logger.error('Get menu item by ID request failed', {
      requestId,
      menuItemId: event.pathParameters?.id,
      error: error instanceof Error ? error.message : String(error),
      duration: `${duration}ms`
    });
    
    return handleError(error, 'Failed to retrieve menu item');
  }
};

/**
 * Get Menu Item Variants Handler (for items with multiple variants)
 * GET /menu/items/{id}/variants
 */
export const getMenuItemVariantsHandler = async (
  event: APIGatewayProxyEvent,
  context: Context
): Promise<APIGatewayProxyResult> => {
  const logger = LoggerService.getInstance();
  const requestId = context.awsRequestId;
  const startTime = Date.now();
  
  try {
    logger.info('Get menu item variants request started', { requestId });
    
    // Only allow GET method
    if (event.httpMethod !== 'GET') {
      return createErrorResponse('Method not allowed', 405, 'METHOD_NOT_ALLOWED');
    }
    
    const menuItemId = event.pathParameters?.id;
    if (!menuItemId) {
      return createErrorResponse('Menu item ID is required', 400, 'MISSING_MENU_ITEM_ID');
    }
    
    // Validate UUID format
    const validationService = ValidationService.getInstance();
    validationService.validateUUID(menuItemId, 'Menu item ID');
    
    // Check if main menu item exists
    const mainMenuItem = await getMenuItemWithDetails(menuItemId);
    if (!mainMenuItem) {
      return createErrorResponse('Menu item not found', 404, 'MENU_ITEM_NOT_FOUND');
    }
    
    // Get variants (items with same base name but different attributes)
    const database = DatabaseService.getInstance();
    const variantsQuery = `
      SELECT 
        id, name, description, price, preparationTime,
        allergens, isVegetarian, isVegan, isGlutenFree, isDairyFree,
        customizations, images, availableDays
      FROM menu_items
      WHERE schoolId = $1 
        AND category = $2 
        AND isActive = true
        AND (name ILIKE $3 OR description ILIKE $3)
        AND id != $4
      ORDER BY name, price
    `;
    
    const searchPattern = `%${mainMenuItem.name.split(' ')[0]}%`; // First word of the name
    const variantsResult = await database.query(variantsQuery, [
      mainMenuItem.schoolId,
      mainMenuItem.category,
      searchPattern,
      menuItemId
    ]);
    
    const variants = variantsResult.rows.map((row: any) => ({
      id: row.id,
      name: row.name,
      description: row.description,
      price: row.price,
      preparationTime: row.preparationTime,
      allergens: row.allergens,
      dietaryFlags: {
        isVegetarian: row.isVegetarian,
        isVegan: row.isVegan,
        isGlutenFree: row.isGlutenFree,
        isDairyFree: row.isDairyFree
      },
      customizations: row.customizations,
      images: row.images,
      availableDays: row.availableDays
    }));
    
    const duration = Date.now() - startTime;
    logger.info('Menu item variants retrieved successfully', {
      requestId,
      menuItemId,
      variantCount: variants.length,
      duration: `${duration}ms`
    });
    
    return createSuccessResponse({
      data: {
        mainItem: {
          id: mainMenuItem.id,
          name: mainMenuItem.name,
          price: mainMenuItem.price
        },
        variants,
        total: variants.length
      },
      message: 'Menu item variants retrieved successfully'
    });
    
  } catch (error: any) {
    const duration = Date.now() - startTime;
    logger.error('Get menu item variants request failed', {
      requestId,
      menuItemId: event.pathParameters?.id,
      error: error instanceof Error ? error.message : String(error),
      duration: `${duration}ms`
    });
    
    return handleError(error, 'Failed to retrieve menu item variants');
  }
};