/**
 * HASIVU Platform - Update Menu Item Lambda Function
 * Handles: PUT /menu/items/{id}
 * Implements Story 2.1: Product Catalog Foundation - Menu Item Updates
 * Production-ready with comprehensive validation and audit logging
 */

import { APIGatewayProxyEvent, APIGatewayProxyResult, Context } from 'aws-lambda';
import { LoggerService } from '../shared/logger.service';
import { ValidationService } from '../shared/validation.service';
import { createSuccessResponse, createErrorResponse, handleError } from '../../shared/response.utils';
import { DatabaseService } from '../../services/database.service';
import { RedisService } from '../../services/redis.service';

/**
 * Menu item update data interface
 */
interface MenuItemUpdateData {
  name?: string;
  description?: string;
  category?: string;
  price?: number;
  nutritionalInfo?: Record<string, any>;
  allergens?: string[];
  isVegetarian?: boolean;
  isVegan?: boolean;
  isGlutenFree?: boolean;
  isDairyFree?: boolean;
  ingredients?: string[];
  servingSize?: string;
  preparationTime?: number;
  availableDays?: string[];
  customizations?: Record<string, any>;
  images?: string[];
  isActive?: boolean;
}

/**
 * Complete menu item interface
 */
interface MenuItem {
  id: string;
  name: string;
  description: string;
  category: string;
  price: number;
  schoolId: string;
  nutritionalInfo: Record<string, any>;
  allergens: string[];
  isVegetarian: boolean;
  isVegan: boolean;
  isGlutenFree: boolean;
  isDairyFree: boolean;
  ingredients: string[];
  servingSize: string;
  preparationTime: number;
  availableDays: string[];
  customizations: Record<string, any>;
  images: string[];
  isActive: boolean;
  createdAt: Date;
  updatedAt: Date;
}

/**
 * Validate menu item update data
 */
function validateUpdateData(data: any): MenuItemUpdateData {
  const validationService = ValidationService.getInstance();
  const validated: MenuItemUpdateData = {};
  
  // Validate name if provided
  if (data.name !== undefined) {
    if (typeof data.name !== 'string' || data.name.trim().length === 0) {
      throw new Error('Name must be a non-empty string');
    }
    if (data.name.length > 200) {
      throw new Error('Name must be less than 200 characters');
    }
    validated.name = data.name.trim();
  }
  
  // Validate description if provided
  if (data.description !== undefined) {
    if (typeof data.description !== 'string') {
      throw new Error('Description must be a string');
    }
    if (data.description.length > 1000) {
      throw new Error('Description must be less than 1000 characters');
    }
    validated.description = data.description.trim();
  }
  
  // Validate category if provided
  if (data.category !== undefined) {
    const validCategories = ['breakfast', 'lunch', 'dinner', 'snack', 'beverage', 'dessert'];
    if (!validCategories.includes(data.category)) {
      throw new Error(`Category must be one of: ${validCategories.join(', ')}`);
    }
    validated.category = data.category;
  }
  
  // Validate price if provided
  if (data.price !== undefined) {
    const price = parseFloat(data.price);
    if (isNaN(price) || price < 0) {
      throw new Error('Price must be a non-negative number');
    }
    if (price > 10000) {
      throw new Error('Price must be less than $10,000');
    }
    validated.price = price;
  }
  
  // Validate nutritional info if provided
  if (data.nutritionalInfo !== undefined) {
    if (typeof data.nutritionalInfo !== 'object' || data.nutritionalInfo === null) {
      throw new Error('Nutritional info must be an object');
    }
    validated.nutritionalInfo = data.nutritionalInfo;
  }
  
  // Validate allergens if provided
  if (data.allergens !== undefined) {
    if (!Array.isArray(data.allergens)) {
      throw new Error('Allergens must be an array');
    }
    const validAllergens = ['nuts', 'dairy', 'eggs', 'soy', 'wheat', 'fish', 'shellfish', 'sesame'];
    for (const allergen of data.allergens) {
      if (!validAllergens.includes(allergen)) {
        throw new Error(`Invalid allergen: ${allergen}. Must be one of: ${validAllergens.join(', ')}`);
      }
    }
    validated.allergens = data.allergens;
  }
  
  // Validate dietary flags if provided
  if (data.isVegetarian !== undefined) {
    validated.isVegetarian = Boolean(data.isVegetarian);
  }
  
  if (data.isVegan !== undefined) {
    validated.isVegan = Boolean(data.isVegan);
  }
  
  if (data.isGlutenFree !== undefined) {
    validated.isGlutenFree = Boolean(data.isGlutenFree);
  }
  
  if (data.isDairyFree !== undefined) {
    validated.isDairyFree = Boolean(data.isDairyFree);
  }
  
  // Validate ingredients if provided
  if (data.ingredients !== undefined) {
    if (!Array.isArray(data.ingredients)) {
      throw new Error('Ingredients must be an array');
    }
    for (const ingredient of data.ingredients) {
      if (typeof ingredient !== 'string' || ingredient.trim().length === 0) {
        throw new Error('Each ingredient must be a non-empty string');
      }
    }
    validated.ingredients = data.ingredients.map((i: string) => i.trim());
  }
  
  // Validate serving size if provided
  if (data.servingSize !== undefined) {
    if (typeof data.servingSize !== 'string' || data.servingSize.trim().length === 0) {
      throw new Error('Serving size must be a non-empty string');
    }
    validated.servingSize = data.servingSize.trim();
  }
  
  // Validate preparation time if provided
  if (data.preparationTime !== undefined) {
    const prepTime = parseInt(data.preparationTime);
    if (isNaN(prepTime) || prepTime < 0) {
      throw new Error('Preparation time must be a non-negative number');
    }
    if (prepTime > 480) { // 8 hours max
      throw new Error('Preparation time must be less than 480 minutes');
    }
    validated.preparationTime = prepTime;
  }
  
  // Validate available days if provided
  if (data.availableDays !== undefined) {
    if (!Array.isArray(data.availableDays)) {
      throw new Error('Available days must be an array');
    }
    const validDays = ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday'];
    for (const day of data.availableDays) {
      if (!validDays.includes(day.toLowerCase())) {
        throw new Error(`Invalid day: ${day}. Must be one of: ${validDays.join(', ')}`);
      }
    }
    validated.availableDays = data.availableDays.map((d: string) => d.toLowerCase());
  }
  
  // Validate customizations if provided
  if (data.customizations !== undefined) {
    if (typeof data.customizations !== 'object' || data.customizations === null) {
      throw new Error('Customizations must be an object');
    }
    validated.customizations = data.customizations;
  }
  
  // Validate images if provided
  if (data.images !== undefined) {
    if (!Array.isArray(data.images)) {
      throw new Error('Images must be an array');
    }
    for (const image of data.images) {
      if (typeof image !== 'string' || !image.startsWith('http')) {
        throw new Error('Each image must be a valid URL');
      }
    }
    validated.images = data.images;
  }
  
  // Validate active status if provided
  if (data.isActive !== undefined) {
    validated.isActive = Boolean(data.isActive);
  }
  
  return validated;
}

/**
 * Check if menu item exists and return current data
 */
async function getExistingMenuItem(menuItemId: string, schoolId?: string): Promise<MenuItem | null> {
  const database = DatabaseService.getInstance();
  
  const query = `
    SELECT 
      id, name, description, category, price, schoolId,
      nutritionalInfo, allergens, isVegetarian, isVegan,
      isGlutenFree, isDairyFree, ingredients, servingSize,
      preparationTime, availableDays, customizations,
      images, isActive, createdAt, updatedAt
    FROM menu_items
    WHERE id = $1 AND isActive = true
    ${schoolId ? 'AND schoolId = $2' : ''}
  `;
  
  const values = schoolId ? [menuItemId, schoolId] : [menuItemId];
  const result = await database.query(query, values);
  
  if (result.rows.length === 0) {
    return null;
  }
  
  return result.rows[0];
}

/**
 * Update menu item in database
 */
async function updateMenuItem(menuItemId: string, updateData: MenuItemUpdateData): Promise<MenuItem> {
  const database = DatabaseService.getInstance();
  
  // Build dynamic update query
  const updateFields: string[] = [];
  const queryValues: any[] = [];
  let paramCounter = 1;
  
  Object.entries(updateData).forEach(([key, value]) => {
    updateFields.push(`${key} = $${paramCounter}`);
    queryValues.push(value);
    paramCounter++;
  });
  
  // Always update the updatedAt timestamp
  updateFields.push(`updatedAt = CURRENT_TIMESTAMP`);
  
  const updateQuery = `
    UPDATE menu_items
    SET ${updateFields.join(', ')}
    WHERE id = $${paramCounter} AND isActive = true
    RETURNING 
      id, name, description, category, price, schoolId,
      nutritionalInfo, allergens, isVegetarian, isVegan,
      isGlutenFree, isDairyFree, ingredients, servingSize,
      preparationTime, availableDays, customizations,
      images, isActive, createdAt, updatedAt
  `;
  
  queryValues.push(menuItemId);
  const result = await database.query(updateQuery, queryValues);
  
  if (result.rows.length === 0) {
    throw new Error('Menu item not found or update failed');
  }
  
  return result.rows[0];
}

/**
 * Log menu item update for audit trail
 */
async function logMenuItemUpdate(
  menuItemId: string,
  originalData: MenuItem,
  updatedData: MenuItem,
  userId: string
): Promise<void> {
  const database = DatabaseService.getInstance();
  
  // Find what fields actually changed
  const changes: Record<string, { from: any; to: any }> = {};
  
  Object.keys(updatedData).forEach(key => {
    if (key !== 'updatedAt' && originalData[key as keyof MenuItem] !== updatedData[key as keyof MenuItem]) {
      changes[key] = {
        from: originalData[key as keyof MenuItem],
        to: updatedData[key as keyof MenuItem]
      };
    }
  });
  
  // Log the audit entry
  const auditQuery = `
    INSERT INTO menu_item_audit_log (
      menuItemId, action, changes, userId, timestamp
    ) VALUES ($1, $2, $3, $4, CURRENT_TIMESTAMP)
  `;
  
  await database.query(auditQuery, [
    menuItemId,
    'update',
    JSON.stringify(changes),
    userId
  ]);
}

/**
 * Update Menu Item Lambda Function Handler
 * Updates an existing menu item with comprehensive validation and audit logging
 */
export const updateMenuItemHandler = async (
  event: APIGatewayProxyEvent,
  context: Context
): Promise<APIGatewayProxyResult> => {
  const logger = LoggerService.getInstance();
  const requestId = context.awsRequestId;
  const startTime = Date.now();
  
  try {
    logger.info('Update menu item request started', { requestId });
    
    // Only allow PUT method
    if (event.httpMethod !== 'PUT') {
      return createErrorResponse('Method not allowed', 405, 'METHOD_NOT_ALLOWED');
    }
    
    // Extract and validate menu item ID from path parameters
    const menuItemId = event.pathParameters?.id;
    if (!menuItemId) {
      logger.warn('Missing menu item ID in path parameters', { requestId });
      return createErrorResponse('Menu item ID is required', 400, 'MISSING_MENU_ITEM_ID');
    }
    
    // Validate UUID format
    const validationService = ValidationService.getInstance();
    try {
      validationService.validateUUID(menuItemId, 'Menu item ID');
    } catch (error: any) {
      logger.warn('Invalid menu item ID format', { requestId, menuItemId, error: error instanceof Error ? error.message : String(error) });
      return createErrorResponse('Invalid menu item ID format', 400, 'INVALID_MENU_ITEM_ID');
    }
    
    // Parse and validate request body
    if (!event.body) {
      logger.warn('Missing request body', { requestId });
      return createErrorResponse('Request body is required', 400, 'MISSING_REQUEST_BODY');
    }
    
    let requestData: any;
    try {
      requestData = JSON.parse(event.body);
    } catch (error: any) {
      logger.warn('Invalid JSON in request body', { requestId, error: error instanceof Error ? error.message : String(error) });
      return createErrorResponse('Invalid JSON in request body', 400, 'INVALID_JSON');
    }
    
    logger.info('Processing update menu item request', { 
      requestId, 
      menuItemId,
      updateFields: Object.keys(requestData)
    });
    
    // Validate input data (partial update)
    let validatedData: MenuItemUpdateData;
    try {
      validatedData = validateUpdateData(requestData);
    } catch (error: any) {
      logger.warn('Validation failed for update data', { 
        requestId, 
        menuItemId, 
        error: error instanceof Error ? error.message : String(error) 
      });
      return createErrorResponse(error.message, 400, 'VALIDATION_FAILED');
    }
    
    // Check if there are any updates to apply
    if (Object.keys(validatedData).length === 0) {
      logger.warn('No valid updates provided', { requestId, menuItemId });
      return createErrorResponse('No valid updates provided', 400, 'NO_UPDATES');
    }
    
    // Check if the menu item exists
    const existingMenuItem = await getExistingMenuItem(menuItemId);
    if (!existingMenuItem) {
      logger.warn('Menu item not found', { requestId, menuItemId });
      return createErrorResponse('Menu item not found', 404, 'MENU_ITEM_NOT_FOUND');
    }
    
    // TODO: Add proper authorization check
    // For now, we'll use a placeholder user ID
    const userId = 'system'; // This should come from JWT token validation
    
    // Update menu item using database service
    const updatedMenuItem = await updateMenuItem(menuItemId, validatedData);
    
    // Log the update for audit trail
    await logMenuItemUpdate(menuItemId, existingMenuItem, updatedMenuItem, userId);
    
    // Invalidate related cache entries
    try {
      const redis = RedisService;
      // Clear search cache patterns that might include this item
      await redis.del(`search:*`);
      await redis.del(`menu_item:${menuItemId}`);
      await redis.del(`menu_items:school:${updatedMenuItem.schoolId}`);
    } catch (cacheError: any) {
      logger.warn('Failed to clear cache after menu item update', { 
        requestId, 
        menuItemId, 
        error: cacheError.message 
      });
    }
    
    const duration = Date.now() - startTime;
    logger.info('Menu item updated successfully', {
      requestId,
      menuItemId,
      menuItemName: updatedMenuItem.name,
      schoolId: updatedMenuItem.schoolId,
      updatedFields: Object.keys(validatedData),
      duration: `${duration}ms`
    });
    
    return createSuccessResponse({
      data: {
        menuItem: {
          id: updatedMenuItem.id,
          name: updatedMenuItem.name,
          description: updatedMenuItem.description,
          category: updatedMenuItem.category,
          price: updatedMenuItem.price,
          schoolId: updatedMenuItem.schoolId,
          nutritionalInfo: updatedMenuItem.nutritionalInfo,
          allergens: updatedMenuItem.allergens,
          isVegetarian: updatedMenuItem.isVegetarian,
          isVegan: updatedMenuItem.isVegan,
          isGlutenFree: updatedMenuItem.isGlutenFree,
          isDairyFree: updatedMenuItem.isDairyFree,
          ingredients: updatedMenuItem.ingredients,
          servingSize: updatedMenuItem.servingSize,
          preparationTime: updatedMenuItem.preparationTime,
          availableDays: updatedMenuItem.availableDays,
          customizations: updatedMenuItem.customizations,
          images: updatedMenuItem.images,
          isActive: updatedMenuItem.isActive,
          createdAt: updatedMenuItem.createdAt,
          updatedAt: updatedMenuItem.updatedAt
        },
        changes: {
          fieldsUpdated: Object.keys(validatedData),
          updateCount: Object.keys(validatedData).length
        }
      },
      message: 'Menu item updated successfully'
    });
    
  } catch (error: any) {
    const duration = Date.now() - startTime;
    logger.error('Update menu item request failed', {
      requestId,
      menuItemId: event.pathParameters?.id,
      error: error instanceof Error ? error.message : String(error),
      duration: `${duration}ms`
    });
    
    return handleError(error, 'Failed to update menu item');
  }
};