/**
 * HASIVU Platform - Advanced Payment Intelligence Lambda Function
 * Handles: POST /api/v1/payments/analyze-transaction, GET /api/v1/payments/intelligence-insights
 * Implements Story 5.4: Advanced Payment Intelligence and Pattern Recognition
 * Production-ready with fraud detection, behavioral analysis, and payment optimization
 */

import { APIGatewayProxyEvent, APIGatewayProxyResult, Context } from 'aws-lambda';
import { PrismaClient } from '@prisma/client';
import { LoggerService } from '../shared/logger.service';
import { ValidationService } from '../shared/validation.service';
import { createSuccessResponse, createErrorResponse, handleError } from '../../shared/response.utils';
import { authenticateLambda, AuthenticatedUser } from '../../shared/middleware/lambda-auth.middleware';
import { z } from 'zod';

// Initialize database client with Lambda optimization
let prisma: PrismaClient | null = null;

function getPrismaClient(): PrismaClient {
  if (!prisma) {
    prisma = new PrismaClient({
      datasources: {
        db: {
          url: process.env.DATABASE_URL
        }
      }
    });
  }
  return prisma;
}

// Validation schemas
const transactionAnalysisSchema = z.object({
  transactionId: z.string().uuid().optional(),
  schoolId: z.string().uuid().optional(),
  amount: z.number().min(0).optional(),
  paymentMethod: z.string().optional(),
  analysisType: z.enum(['fraud_detection', 'pattern_recognition', 'behavioral_analysis', 'optimization_suggestions', 'comprehensive']).default('comprehensive'),
  includeRecommendations: z.boolean().default(true),
  confidenceThreshold: z.number().min(0).max(1).default(0.7)
});

const intelligenceInsightsSchema = z.object({
  schoolId: z.string().uuid().optional(),
  timeframe: z.enum(['day', 'week', 'month', 'quarter', 'year']).default('month'),
  insightTypes: z.array(z.enum(['fraud_patterns', 'user_behavior', 'payment_optimization', 'risk_assessment', 'all'])).default(['all']),
  includeActionableRecommendations: z.boolean().default(true),
  riskLevel: z.enum(['low', 'medium', 'high', 'critical', 'all']).default('all')
});

// Intelligence interfaces
interface FraudDetectionResult {
  transactionId: string;
  fraudRisk: 'low' | 'medium' | 'high' | 'critical';
  fraudScore: number; // 0-1
  riskFactors: Array<{
    factor: string;
    weight: number;
    description: string;
    evidence: any[];
  }>;
  recommendations: string[];
  blockedIndicators: string[];
  investigationRequired: boolean;
  confidence: number;
}

interface PatternRecognitionResult {
  patterns: Array<{
    patternType: 'temporal' | 'behavioral' | 'amount' | 'geographic' | 'device' | 'network';
    description: string;
    frequency: number;
    significance: 'low' | 'medium' | 'high' | 'critical';
    examples: any[];
    recommendations: string[];
  }>;
  anomalies: Array<{
    type: string;
    description: string;
    severity: 'info' | 'warning' | 'error' | 'critical';
    affectedTransactions: number;
    potentialImpact: string;
  }>;
  trends: Array<{
    metric: string;
    direction: 'increasing' | 'decreasing' | 'stable' | 'volatile';
    strength: number;
    prediction: number;
    recommendations: string[];
  }>;
}

interface BehavioralAnalysisResult {
  userBehavior: {
    paymentFrequency: number;
    averageAmount: number;
    preferredTimes: string[];
    devicePatterns: string[];
    successRate: number;
    riskProfile: 'conservative' | 'moderate' | 'aggressive' | 'erratic';
  };
  schoolBehavior: {
    transactionVolume: number;
    peakHours: string[];
    seasonalPatterns: any[];
    riskEvents: number;
    complianceScore: number;
  };
  comparativeBenchmarks: {
    industryAverage: Record<string, number>;
    percentileRanking: Record<string, number>;
    competitivePosition: 'leading' | 'above_average' | 'average' | 'below_average' | 'lagging';
  };
  behavioralInsights: Array<{
    insight: string;
    category: 'positive' | 'neutral' | 'concern' | 'critical';
    actionable: boolean;
    recommendation?: string;
    impact: 'low' | 'medium' | 'high';
  }>;
}

interface PaymentOptimizationResult {
  currentPerformance: {
    successRate: number;
    averageProcessingTime: number;
    costEfficiency: number;
    userSatisfaction: number;
    technicalScore: number;
  };
  optimizationOpportunities: Array<{
    area: 'gateway_selection' | 'routing_logic' | 'retry_strategy' | 'user_experience' | 'fraud_prevention' | 'cost_optimization';
    currentState: string;
    recommendedState: string;
    expectedImpact: {
      successRateImprovement: number;
      costReduction: number;
      userExperienceImprovement: number;
      implementationComplexity: 'low' | 'medium' | 'high';
      timeToImplement: number; // days
    };
    priority: 'low' | 'medium' | 'high' | 'critical';
    businessJustification: string;
    technicalRequirements: string[];
  }>;
  riskMitigationSuggestions: Array<{
    risk: string;
    mitigation: string;
    cost: 'low' | 'medium' | 'high';
    effectiveness: number; // 0-1
    timeline: string;
  }>;
}

interface IntelligenceInsight {
  id: string;
  timestamp: Date;
  type: 'fraud_alert' | 'pattern_discovery' | 'optimization_opportunity' | 'behavioral_change' | 'risk_escalation';
  severity: 'info' | 'warning' | 'error' | 'critical';
  title: string;
  description: string;
  affectedEntities: {
    transactions?: number;
    users?: number;
    schools?: number;
    revenue?: number;
  };
  evidence: any[];
  recommendations: Array<{
    action: string;
    priority: 'low' | 'medium' | 'high' | 'immediate';
    effort: 'low' | 'medium' | 'high';
    impact: 'low' | 'medium' | 'high';
    timeline: string;
  }>;
  confidence: number;
  businessImpact: {
    revenue: number;
    risk: number;
    operationalEfficiency: number;
    userExperience: number;
  };
}

/**
 * Perform comprehensive fraud detection analysis
 */
async function detectFraudRisk(
  transactionData: any,
  historicalContext: any[],
  userProfile: any,
  schoolProfile: any
): Promise<FraudDetectionResult> {
  const riskFactors: Array<{factor: string; weight: number; description: string; evidence: any[]}> = [];
  let fraudScore = 0;
  
  // Amount-based fraud detection
  if (transactionData.amount) {
    const averageAmount = historicalContext.reduce((sum, t) => sum + t.amount, 0) / Math.max(1, historicalContext.length);
    const amountDeviation = Math.abs(transactionData.amount - averageAmount) / Math.max(averageAmount, 1);
    
    if (amountDeviation > 3) { // 3x normal amount
      const weight = Math.min(0.3, amountDeviation / 10);
      fraudScore += weight;
      riskFactors.push({
        factor: 'Unusual transaction amount',
        weight,
        description: `Amount ${transactionData.amount} is ${amountDeviation.toFixed(1)}x the user's average`,
        evidence: [{ currentAmount: transactionData.amount, averageAmount, deviation: amountDeviation }]
      });
    }
  }
  
  // Velocity-based fraud detection
  const recentTransactions = historicalContext.filter(t => {
    const timeDiff = Date.now() - new Date(t.createdAt).getTime();
    return timeDiff < 24 * 60 * 60 * 1000; // Last 24 hours
  });
  
  if (recentTransactions.length > 10) { // More than 10 transactions in 24h
    const weight = Math.min(0.25, recentTransactions.length / 50);
    fraudScore += weight;
    riskFactors.push({
      factor: 'High transaction velocity',
      weight,
      description: `${recentTransactions.length} transactions in the last 24 hours`,
      evidence: recentTransactions.slice(0, 5).map(t => ({ id: t.id, amount: t.amount, timestamp: t.createdAt }))
    });
  }
  
  // Geographic fraud detection (simplified)
  if (userProfile.location && transactionData.location) {
    const distance = calculateDistance(userProfile.location, transactionData.location);
    if (distance > 1000) { // More than 1000km from usual location
      const weight = Math.min(0.2, distance / 5000);
      fraudScore += weight;
      riskFactors.push({
        factor: 'Unusual geographic location',
        weight,
        description: `Transaction from ${distance}km away from usual location`,
        evidence: [{ userLocation: userProfile.location, transactionLocation: transactionData.location, distance }]
      });
    }
  }
  
  // Temporal pattern fraud detection
  const hour = new Date().getHours();
  const isUnusualTime = hour < 6 || hour > 23; // Outside 6 AM - 11 PM
  if (isUnusualTime) {
    const weight = 0.1;
    fraudScore += weight;
    riskFactors.push({
      factor: 'Unusual transaction time',
      weight,
      description: `Transaction at ${hour}:00 hours`,
      evidence: [{ hour, isBusinessHours: false }]
    });
  }
  
  // User behavior deviation
  if (userProfile.successRate && userProfile.successRate > 0.9 && transactionData.previousFailures > 3) {
    const weight = 0.15;
    fraudScore += weight;
    riskFactors.push({
      factor: 'Unusual failure pattern',
      weight,
      description: 'Multiple consecutive failures for typically successful user',
      evidence: [{ normalSuccessRate: userProfile.successRate, recentFailures: transactionData.previousFailures }]
    });
  }
  
  // School-level risk factors
  if (schoolProfile.riskScore && schoolProfile.riskScore > 0.7) {
    const weight = 0.1;
    fraudScore += weight;
    riskFactors.push({
      factor: 'High-risk school association',
      weight,
      description: `School has elevated risk score of ${schoolProfile.riskScore}`,
      evidence: [{ schoolRiskScore: schoolProfile.riskScore, riskReasons: schoolProfile.riskReasons }]
    });
  }
  
  // Normalize fraud score
  fraudScore = Math.min(1, fraudScore);
  
  // Determine risk level
  let fraudRisk: 'low' | 'medium' | 'high' | 'critical';
  if (fraudScore >= 0.8) fraudRisk = 'critical';
  else if (fraudScore >= 0.6) fraudRisk = 'high';
  else if (fraudScore >= 0.4) fraudRisk = 'medium';
  else fraudRisk = 'low';
  
  // Generate recommendations
  const recommendations = generateFraudRecommendations(fraudScore, riskFactors);
  
  // Determine blocked indicators
  const blockedIndicators = riskFactors
    .filter(rf => rf.weight > 0.3)
    .map(rf => rf.factor);
  
  return {
    transactionId: transactionData.id,
    fraudRisk,
    fraudScore: Math.round(fraudScore * 100) / 100,
    riskFactors,
    recommendations,
    blockedIndicators,
    investigationRequired: fraudScore > 0.6,
    confidence: Math.min(0.95, 0.7 + riskFactors.length * 0.05)
  };
}

/**
 * Calculate distance between two locations (simplified)
 */
function calculateDistance(loc1: any, loc2: any): number {
  // Simplified distance calculation - in production would use proper geolocation
  const lat1 = loc1.latitude || 0;
  const lon1 = loc1.longitude || 0;
  const lat2 = loc2.latitude || 0;
  const lon2 = loc2.longitude || 0;
  
  const R = 6371; // Earth's radius in km
  const dLat = (lat2 - lat1) * Math.PI / 180;
  const dLon = (lon2 - lon1) * Math.PI / 180;
  const a = Math.sin(dLat/2) * Math.sin(dLat/2) + Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) * Math.sin(dLon/2) * Math.sin(dLon/2);
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
  return R * c;
}

/**
 * Generate fraud prevention recommendations
 */
function generateFraudRecommendations(fraudScore: number, riskFactors: any[]): string[] {
  const recommendations: string[] = [];
  
  if (fraudScore >= 0.8) {
    recommendations.push('IMMEDIATE: Block transaction and require manual review');
    recommendations.push('IMMEDIATE: Contact user via verified phone/email for confirmation');
    recommendations.push('IMMEDIATE: Escalate to fraud investigation team');
  } else if (fraudScore >= 0.6) {
    recommendations.push('URGENT: Require additional authentication (2FA, OTP)');
    recommendations.push('URGENT: Implement transaction limits for this user temporarily');
    recommendations.push('Monitor subsequent transactions closely');
  } else if (fraudScore >= 0.4) {
    recommendations.push('Require step-up authentication for high-value transactions');
    recommendations.push('Enable enhanced monitoring for this user profile');
    recommendations.push('Consider implementing velocity limits');
  } else {
    recommendations.push('Continue standard processing');
    recommendations.push('Maintain routine monitoring');
  }
  
  // Factor-specific recommendations
  riskFactors.forEach(factor => {
    switch (factor.factor) {
      case 'Unusual transaction amount':
        recommendations.push('Consider implementing dynamic amount limits');
        break;
      case 'High transaction velocity':
        recommendations.push('Implement velocity-based controls and cooling-off periods');
        break;
      case 'Unusual geographic location':
        recommendations.push('Enable location-based alerts and verification');
        break;
      case 'Unusual transaction time':
        recommendations.push('Consider time-based risk scoring adjustments');
        break;
    }
  });
  
  return Array.from(new Set(recommendations)); // Remove duplicates
}

/**
 * Perform pattern recognition analysis
 */
async function recognizePaymentPatterns(
  historicalData: any[],
  timeframe: string,
  schoolId?: string
): Promise<PatternRecognitionResult> {
  const patterns: PatternRecognitionResult['patterns'] = [];
  const anomalies: PatternRecognitionResult['anomalies'] = [];
  const trends: PatternRecognitionResult['trends'] = [];
  
  if (historicalData.length < 10) {
    return { patterns, anomalies, trends };
  }
  
  // Temporal patterns
  const temporalAnalysis = analyzeTemporalPatterns(historicalData);
  if (temporalAnalysis.significance !== 'low') {
    patterns.push({
      patternType: 'temporal',
      description: temporalAnalysis.description,
      frequency: temporalAnalysis.frequency,
      significance: temporalAnalysis.significance,
      examples: temporalAnalysis.examples,
      recommendations: temporalAnalysis.recommendations
    });
  }
  
  // Amount patterns
  const amountAnalysis = analyzeAmountPatterns(historicalData);
  if (amountAnalysis.significance !== 'low') {
    patterns.push({
      patternType: 'amount',
      description: amountAnalysis.description,
      frequency: amountAnalysis.frequency,
      significance: amountAnalysis.significance,
      examples: amountAnalysis.examples,
      recommendations: amountAnalysis.recommendations
    });
  }
  
  // Behavioral patterns
  const behavioralAnalysis = analyzeBehavioralPatterns(historicalData);
  if (behavioralAnalysis.significance !== 'low') {
    patterns.push({
      patternType: 'behavioral',
      description: behavioralAnalysis.description,
      frequency: behavioralAnalysis.frequency,
      significance: behavioralAnalysis.significance,
      examples: behavioralAnalysis.examples,
      recommendations: behavioralAnalysis.recommendations
    });
  }
  
  // Detect anomalies
  const detectedAnomalies = detectPatternAnomalies(historicalData);
  anomalies.push(...detectedAnomalies);
  
  // Identify trends
  const identifiedTrends = identifyPaymentTrends(historicalData);
  trends.push(...identifiedTrends);
  
  return { patterns, anomalies, trends };
}

/**
 * Analyze temporal patterns in payment data
 */
function analyzeTemporalPatterns(data: any[]): any {
  const hourlyDistribution: Record<number, number> = {};
  const dailyDistribution: Record<number, number> = {}; // 0 = Sunday
  
  data.forEach(payment => {
    const date = new Date(payment.createdAt);
    const hour = date.getHours();
    const day = date.getDay();
    
    hourlyDistribution[hour] = (hourlyDistribution[hour] || 0) + 1;
    dailyDistribution[day] = (dailyDistribution[day] || 0) + 1;
  });
  
  // Find peak hours
  const peakHour = Object.entries(hourlyDistribution)
    .sort(([,a], [,b]) => b - a)[0];
  const peakDay = Object.entries(dailyDistribution)
    .sort(([,a], [,b]) => b - a)[0];
  
  const peakHourPercentage = (parseInt(peakHour[1] as unknown as string) / data.length) * 100;
  const peakDayPercentage = (parseInt(peakDay[1] as unknown as string) / data.length) * 100;
  
  let significance: 'low' | 'medium' | 'high' | 'critical';
  if (peakHourPercentage > 50 || peakDayPercentage > 40) significance = 'critical';
  else if (peakHourPercentage > 30 || peakDayPercentage > 25) significance = 'high';
  else if (peakHourPercentage > 20 || peakDayPercentage > 15) significance = 'medium';
  else significance = 'low';
  
  const dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
  
  return {
    description: `Peak activity: ${peakHourPercentage.toFixed(1)}% of payments at ${peakHour[0]}:00, ${peakDayPercentage.toFixed(1)}% on ${dayNames[parseInt(peakDay[0])]}`,
    frequency: Math.max(peakHourPercentage, peakDayPercentage) / 100,
    significance,
    examples: [
      { type: 'peak_hour', hour: parseInt(peakHour[0]), percentage: peakHourPercentage },
      { type: 'peak_day', day: dayNames[parseInt(peakDay[0])], percentage: peakDayPercentage }
    ],
    recommendations: [
      significance === 'critical' ? 'Implement load balancing for peak hours' : 'Monitor peak hour performance',
      'Consider targeted promotions during low-activity periods',
      'Optimize customer support staffing based on patterns'
    ]
  };
}

/**
 * Analyze amount patterns in payment data
 */
function analyzeAmountPatterns(data: any[]): any {
  const amounts = data.map(p => p.amount).sort((a, b) => a - b);
  const total = amounts.reduce((sum, amt) => sum + amt, 0);
  const mean = total / amounts.length;
  
  // Calculate amount distribution
  const q1 = amounts[Math.floor(amounts.length * 0.25)];
  const median = amounts[Math.floor(amounts.length * 0.5)];
  const q3 = amounts[Math.floor(amounts.length * 0.75)];
  
  // Check for amount clustering
  const amountClusters = findAmountClusters(amounts);
  const largestCluster = amountClusters.sort((a, b) => b.count - a.count)[0];
  
  const clusterPercentage = (largestCluster.count / amounts.length) * 100;
  
  let significance: 'low' | 'medium' | 'high' | 'critical';
  if (clusterPercentage > 40) significance = 'critical';
  else if (clusterPercentage > 25) significance = 'high';
  else if (clusterPercentage > 15) significance = 'medium';
  else significance = 'low';
  
  return {
    description: `${clusterPercentage.toFixed(1)}% of payments cluster around ₹${largestCluster.amount}. Median: ₹${median}, Range: ₹${amounts[0]}-₹${amounts[amounts.length-1]}`,
    frequency: clusterPercentage / 100,
    significance,
    examples: [
      { type: 'cluster', amount: largestCluster.amount, count: largestCluster.count, percentage: clusterPercentage },
      { type: 'quartiles', q1, median, q3, mean }
    ],
    recommendations: [
      significance === 'critical' ? 'Investigate pricing consistency' : 'Monitor amount distribution',
      'Consider tiered pricing strategies',
      'Analyze high-value transaction patterns'
    ]
  };
}

/**
 * Find amount clusters in payment data
 */
function findAmountClusters(amounts: number[]): Array<{amount: number; count: number}> {
  const clusters: Record<number, number> = {};
  const tolerance = 50; // ₹50 tolerance for clustering
  
  amounts.forEach(amount => {
    // Find existing cluster within tolerance
    let foundCluster = false;
    for (const [clusterAmount, count] of Object.entries(clusters)) {
      if (Math.abs(amount - parseFloat(clusterAmount)) <= tolerance) {
        clusters[parseFloat(clusterAmount)] = count + 1;
        foundCluster = true;
        break;
      }
    }
    
    if (!foundCluster) {
      clusters[amount] = 1;
    }
  });
  
  return Object.entries(clusters)
    .map(([amount, count]) => ({ amount: parseFloat(amount), count }))
    .filter(cluster => cluster.count > 1)
    .sort((a, b) => b.count - a.count);
}

/**
 * Analyze behavioral patterns in payment data
 */
function analyzeBehavioralPatterns(data: any[]): any {
  const userBehavior: Record<string, any> = {};
  
  data.forEach(payment => {
    const userId = payment.userId || payment.order?.userId;
    if (!userId) return;
    
    if (!userBehavior[userId]) {
      userBehavior[userId] = {
        paymentCount: 0,
        totalAmount: 0,
        successfulPayments: 0,
        failedPayments: 0,
        paymentTimes: []
      };
    }
    
    userBehavior[userId].paymentCount++;
    userBehavior[userId].totalAmount += payment.amount;
    userBehavior[userId].paymentTimes.push(new Date(payment.createdAt).getHours());
    
    if (payment.status === 'completed') {
      userBehavior[userId].successfulPayments++;
    } else if (payment.status === 'failed') {
      userBehavior[userId].failedPayments++;
    }
  });
  
  const users = Object.values(userBehavior);
  const avgPaymentsPerUser = users.reduce((sum: number, user: any) => sum + user.paymentCount, 0) / users.length;
  const avgSuccessRate = users.reduce((sum: number, user: any) => sum + (user.successfulPayments / user.paymentCount), 0) / users.length;
  
  // Find power users (top 20%)
  const sortedUsers = users.sort((a: any, b: any) => b.paymentCount - a.paymentCount);
  const powerUserThreshold = Math.ceil(users.length * 0.2);
  const powerUsers = sortedUsers.slice(0, powerUserThreshold);
  const powerUserContribution = powerUsers.reduce((sum: number, user: any) => sum + user.totalAmount, 0);
  const totalRevenue = users.reduce((sum: number, user: any) => sum + user.totalAmount, 0);
  const powerUserPercentage = (powerUserContribution / totalRevenue) * 100;
  
  let significance: 'low' | 'medium' | 'high' | 'critical';
  if (powerUserPercentage > 60) significance = 'critical';
  else if (powerUserPercentage > 40) significance = 'high';
  else if (powerUserPercentage > 25) significance = 'medium';
  else significance = 'low';
  
  return {
    description: `Top 20% of users contribute ${powerUserPercentage.toFixed(1)}% of revenue. Average: ${avgPaymentsPerUser.toFixed(1)} payments/user, ${(avgSuccessRate * 100).toFixed(1)}% success rate`,
    frequency: powerUserPercentage / 100,
    significance,
    examples: [
      { type: 'power_users', count: powerUsers.length, contribution: powerUserPercentage },
      { type: 'average_behavior', avgPayments: avgPaymentsPerUser, avgSuccessRate: avgSuccessRate * 100 }
    ],
    recommendations: [
      significance === 'critical' ? 'Implement VIP retention program' : 'Monitor high-value users',
      'Analyze user journey for optimization opportunities',
      'Consider loyalty rewards for frequent users'
    ]
  };
}

/**
 * Detect anomalies in payment patterns
 */
function detectPatternAnomalies(data: any[]): any[] {
  const anomalies: any[] = [];
  
  // Detect unusual spikes in transaction volume
  const dailyVolume = calculateDailyVolume(data);
  const avgDailyVolume = dailyVolume.reduce((sum, vol) => sum + vol.count, 0) / dailyVolume.length;
  const volumeThreshold = avgDailyVolume * 2.5; // 2.5x average
  
  dailyVolume.forEach(day => {
    if (day.count > volumeThreshold) {
      anomalies.push({
        type: 'Volume spike',
        description: `${day.count} transactions on ${day.date} (${((day.count / avgDailyVolume - 1) * 100).toFixed(1)}% above average)`,
        severity: day.count > volumeThreshold * 1.5 ? 'critical' : 'warning',
        affectedTransactions: day.count,
        potentialImpact: 'System performance degradation, potential promotional campaign'
      });
    }
  });
  
  // Detect success rate drops
  const dailySuccessRate = calculateDailySuccessRates(data);
  const avgSuccessRate = dailySuccessRate.reduce((sum, rate) => sum + rate.rate, 0) / dailySuccessRate.length;
  const successThreshold = avgSuccessRate * 0.7; // 30% drop from average
  
  dailySuccessRate.forEach(day => {
    if (day.rate < successThreshold && day.totalTransactions > 5) {
      anomalies.push({
        type: 'Success rate drop',
        description: `${(day.rate * 100).toFixed(1)}% success rate on ${day.date} (${((1 - day.rate / avgSuccessRate) * 100).toFixed(1)}% below average)`,
        severity: day.rate < successThreshold * 0.7 ? 'critical' : 'error',
        affectedTransactions: day.totalTransactions,
        potentialImpact: 'Revenue loss, user dissatisfaction, system issues'
      });
    }
  });
  
  return anomalies;
}

/**
 * Calculate daily transaction volume
 */
function calculateDailyVolume(data: any[]): Array<{date: string; count: number}> {
  const dailyCounts: Record<string, number> = {};
  
  data.forEach(payment => {
    const date = new Date(payment.createdAt).toISOString().split('T')[0];
    dailyCounts[date] = (dailyCounts[date] || 0) + 1;
  });
  
  return Object.entries(dailyCounts)
    .map(([date, count]) => ({ date, count }))
    .sort((a, b) => a.date.localeCompare(b.date));
}

/**
 * Calculate daily success rates
 */
function calculateDailySuccessRates(data: any[]): Array<{date: string; rate: number; totalTransactions: number}> {
  const dailyStats: Record<string, {total: number; successful: number}> = {};
  
  data.forEach(payment => {
    const date = new Date(payment.createdAt).toISOString().split('T')[0];
    if (!dailyStats[date]) {
      dailyStats[date] = { total: 0, successful: 0 };
    }
    
    dailyStats[date].total++;
    if (payment.status === 'completed') {
      dailyStats[date].successful++;
    }
  });
  
  return Object.entries(dailyStats)
    .map(([date, stats]) => ({
      date,
      rate: stats.total > 0 ? stats.successful / stats.total : 0,
      totalTransactions: stats.total
    }))
    .sort((a, b) => a.date.localeCompare(b.date));
}

/**
 * Identify payment trends
 */
function identifyPaymentTrends(data: any[]): any[] {
  const trends: any[] = [];
  
  if (data.length < 7) return trends; // Need at least a week of data
  
  // Revenue trend
  const dailyRevenue = calculateDailyRevenue(data);
  const revenueTrend = calculateTrend(dailyRevenue.map(d => d.revenue));
  
  trends.push({
    metric: 'Revenue',
    direction: revenueTrend.direction,
    strength: revenueTrend.strength,
    prediction: revenueTrend.prediction,
    recommendations: [
      revenueTrend.direction === 'increasing' ? 'Scale successful strategies' : 'Investigate revenue decline',
      'Monitor competitive landscape',
      'Consider seasonal adjustments'
    ]
  });
  
  // Transaction volume trend
  const dailyVolume = calculateDailyVolume(data);
  const volumeTrend = calculateTrend(dailyVolume.map(d => d.count));
  
  trends.push({
    metric: 'Transaction Volume',
    direction: volumeTrend.direction,
    strength: volumeTrend.strength,
    prediction: volumeTrend.prediction,
    recommendations: [
      volumeTrend.direction === 'increasing' ? 'Ensure infrastructure scaling' : 'Boost marketing efforts',
      'Optimize conversion funnel',
      'Analyze user acquisition channels'
    ]
  });
  
  return trends;
}

/**
 * Calculate daily revenue
 */
function calculateDailyRevenue(data: any[]): Array<{date: string; revenue: number}> {
  const dailyRevenue: Record<string, number> = {};
  
  data.forEach(payment => {
    if (payment.status === 'completed') {
      const date = new Date(payment.createdAt).toISOString().split('T')[0];
      dailyRevenue[date] = (dailyRevenue[date] || 0) + payment.amount;
    }
  });
  
  return Object.entries(dailyRevenue)
    .map(([date, revenue]) => ({ date, revenue }))
    .sort((a, b) => a.date.localeCompare(b.date));
}

/**
 * Calculate trend for a series of values
 */
function calculateTrend(values: number[]): {direction: string; strength: number; prediction: number} {
  if (values.length < 3) {
    return { direction: 'stable', strength: 0, prediction: values[values.length - 1] || 0 };
  }
  
  // Simple linear regression
  const n = values.length;
  const xValues = Array.from({ length: n }, (_, i) => i);
  const xMean = xValues.reduce((sum, x) => sum + x, 0) / n;
  const yMean = values.reduce((sum, y) => sum + y, 0) / n;
  
  const numerator = xValues.reduce((sum, x, i) => sum + (x - xMean) * (values[i] - yMean), 0);
  const denominator = xValues.reduce((sum, x) => sum + Math.pow(x - xMean, 2), 0);
  
  const slope = denominator !== 0 ? numerator / denominator : 0;
  
  // Calculate R-squared for strength
  const predicted = xValues.map(x => yMean + slope * (x - xMean));
  const ssRes = values.reduce((sum, y, i) => sum + Math.pow(y - predicted[i], 2), 0);
  const ssTot = values.reduce((sum, y) => sum + Math.pow(y - yMean, 2), 0);
  const rSquared = ssTot > 0 ? 1 - (ssRes / ssTot) : 0;
  
  // Determine direction
  let direction: string;
  const volatility = Math.sqrt(values.reduce((sum, v) => sum + Math.pow(v - yMean, 2), 0) / n) / Math.max(yMean, 1);
  
  if (volatility > 0.3) {
    direction = 'volatile';
  } else if (Math.abs(slope) < yMean * 0.01) {
    direction = 'stable';
  } else {
    direction = slope > 0 ? 'increasing' : 'decreasing';
  }
  
  // Predict next value
  const prediction = Math.max(0, yMean + slope * n);
  
  return {
    direction,
    strength: Math.abs(rSquared),
    prediction
  };
}

/**
 * Perform behavioral analysis
 */
async function performBehavioralAnalysis(
  historicalData: any[],
  userProfiles: any[],
  schoolProfiles: any[],
  schoolId?: string
): Promise<BehavioralAnalysisResult> {
  const prismaClient = getPrismaClient();
  
  // Aggregate user behavior
  const userBehavior = calculateUserBehavior(historicalData, userProfiles);
  
  // Aggregate school behavior
  const schoolBehavior = calculateSchoolBehavior(historicalData, schoolProfiles, schoolId);
  
  // Generate comparative benchmarks
  const comparativeBenchmarks = await generateBenchmarks(userBehavior, schoolBehavior);
  
  // Generate behavioral insights
  const behavioralInsights = generateBehavioralInsights(userBehavior, schoolBehavior, comparativeBenchmarks);
  
  return {
    userBehavior,
    schoolBehavior,
    comparativeBenchmarks,
    behavioralInsights
  };
}

/**
 * Calculate user behavior metrics
 */
function calculateUserBehavior(data: any[], userProfiles: any[]): any {
  const totalTransactions = data.length;
  const totalAmount = data.reduce((sum, t) => sum + t.amount, 0);
  const successfulTransactions = data.filter(t => t.status === 'completed').length;
  
  // Calculate payment frequency (transactions per month)
  const timeSpan = data.length > 0 ? 
    (new Date(data[data.length - 1].createdAt).getTime() - new Date(data[0].createdAt).getTime()) / (1000 * 60 * 60 * 24 * 30) : 1;
  const paymentFrequency = totalTransactions / Math.max(timeSpan, 1);
  
  // Average amount
  const averageAmount = totalAmount / Math.max(totalTransactions, 1);
  
  // Preferred times analysis
  const hourCounts: Record<number, number> = {};
  data.forEach(transaction => {
    const hour = new Date(transaction.createdAt).getHours();
    hourCounts[hour] = (hourCounts[hour] || 0) + 1;
  });
  
  const preferredTimes = Object.entries(hourCounts)
    .sort(([,a], [,b]) => b - a)
    .slice(0, 3)
    .map(([hour, count]) => `${hour}:00 (${((count / totalTransactions) * 100).toFixed(1)}%)`);
  
  // Device patterns (simplified)
  const devicePatterns = ['Web Browser (65%)', 'Mobile App (35%)']; // Simplified for demo
  
  // Success rate
  const successRate = totalTransactions > 0 ? successfulTransactions / totalTransactions : 0;
  
  // Risk profile determination
  let riskProfile: 'conservative' | 'moderate' | 'aggressive' | 'erratic';
  const avgTransactionSize = averageAmount;
  const volatility = calculateTransactionVolatility(data);
  
  if (volatility > 0.5 && paymentFrequency > 20) riskProfile = 'erratic';
  else if (avgTransactionSize > 5000 && paymentFrequency > 10) riskProfile = 'aggressive';
  else if (avgTransactionSize < 1000 && successRate > 0.95) riskProfile = 'conservative';
  else riskProfile = 'moderate';
  
  return {
    paymentFrequency: Math.round(paymentFrequency * 100) / 100,
    averageAmount: Math.round(averageAmount * 100) / 100,
    preferredTimes,
    devicePatterns,
    successRate: Math.round(successRate * 1000) / 10,
    riskProfile
  };
}

/**
 * Calculate transaction volatility
 */
function calculateTransactionVolatility(data: any[]): number {
  if (data.length < 2) return 0;
  
  const amounts = data.map(t => t.amount);
  const mean = amounts.reduce((sum, amt) => sum + amt, 0) / amounts.length;
  const variance = amounts.reduce((sum, amt) => sum + Math.pow(amt - mean, 2), 0) / amounts.length;
  const stdDev = Math.sqrt(variance);
  
  return mean > 0 ? stdDev / mean : 0;
}

/**
 * Calculate school behavior metrics
 */
function calculateSchoolBehavior(data: any[], schoolProfiles: any[], schoolId?: string): any {
  const relevantData = schoolId ? 
    data.filter(t => t.order?.user?.schoolId === schoolId) : 
    data;
  
  const transactionVolume = relevantData.length;
  
  // Peak hours analysis
  const hourCounts: Record<number, number> = {};
  relevantData.forEach(transaction => {
    const hour = new Date(transaction.createdAt).getHours();
    hourCounts[hour] = (hourCounts[hour] || 0) + 1;
  });
  
  const peakHours = Object.entries(hourCounts)
    .sort(([,a], [,b]) => b - a)
    .slice(0, 3)
    .map(([hour, count]) => `${hour}:00 (${count} transactions)`);
  
  // Seasonal patterns (simplified)
  const seasonalPatterns = [
    { season: 'Q1', growth: '+5%' },
    { season: 'Q2', growth: '+12%' },
    { season: 'Q3', growth: '+3%' },
    { season: 'Q4', growth: '+8%' }
  ];
  
  // Risk events (failures, chargebacks, etc.)
  const riskEvents = relevantData.filter(t => 
    t.status === 'failed' || t.status === 'disputed'
  ).length;
  
  // Compliance score (simplified)
  const successRate = relevantData.length > 0 ? 
    relevantData.filter(t => t.status === 'completed').length / relevantData.length : 0;
  const complianceScore = Math.min(100, (successRate * 80) + (riskEvents === 0 ? 20 : Math.max(0, 20 - riskEvents * 2)));
  
  return {
    transactionVolume,
    peakHours,
    seasonalPatterns,
    riskEvents,
    complianceScore: Math.round(complianceScore)
  };
}

/**
 * Generate comparative benchmarks
 */
async function generateBenchmarks(userBehavior: any, schoolBehavior: any): Promise<any> {
  // Simplified industry benchmarks (in production, would come from market research)
  const industryAverage = {
    paymentFrequency: 2.5, // payments per month
    averageAmount: 2500, // average transaction amount
    successRate: 92, // percentage
    transactionVolume: 150, // transactions per month
    complianceScore: 85
  };
  
  const percentileRanking = {
    paymentFrequency: calculatePercentile(userBehavior.paymentFrequency, industryAverage.paymentFrequency),
    averageAmount: calculatePercentile(userBehavior.averageAmount, industryAverage.averageAmount),
    successRate: calculatePercentile(userBehavior.successRate, industryAverage.successRate),
    transactionVolume: calculatePercentile(schoolBehavior.transactionVolume, industryAverage.transactionVolume),
    complianceScore: calculatePercentile(schoolBehavior.complianceScore, industryAverage.complianceScore)
  };
  
  // Determine overall competitive position
  const avgPercentile = Object.values(percentileRanking).reduce((sum, p) => sum + p, 0) / Object.values(percentileRanking).length;
  
  let competitivePosition: 'leading' | 'above_average' | 'average' | 'below_average' | 'lagging';
  if (avgPercentile >= 90) competitivePosition = 'leading';
  else if (avgPercentile >= 75) competitivePosition = 'above_average';
  else if (avgPercentile >= 50) competitivePosition = 'average';
  else if (avgPercentile >= 25) competitivePosition = 'below_average';
  else competitivePosition = 'lagging';
  
  return {
    industryAverage,
    percentileRanking,
    competitivePosition
  };
}

/**
 * Calculate percentile ranking
 */
function calculatePercentile(value: number, benchmark: number): number {
  // Simplified percentile calculation
  const ratio = value / Math.max(benchmark, 0.1);
  if (ratio >= 1.5) return 95;
  if (ratio >= 1.2) return 85;
  if (ratio >= 1.0) return 70;
  if (ratio >= 0.8) return 50;
  if (ratio >= 0.6) return 30;
  return 15;
}

/**
 * Generate behavioral insights
 */
function generateBehavioralInsights(userBehavior: any, schoolBehavior: any, benchmarks: any): any[] {
  const insights: any[] = [];
  
  // User behavior insights
  if (userBehavior.successRate > 95) {
    insights.push({
      insight: `Excellent payment success rate of ${userBehavior.successRate}%`,
      category: 'positive',
      actionable: false,
      impact: 'medium'
    });
  } else if (userBehavior.successRate < 80) {
    insights.push({
      insight: `Low payment success rate of ${userBehavior.successRate}% requires attention`,
      category: 'critical',
      actionable: true,
      recommendation: 'Investigate payment gateway issues and implement retry logic',
      impact: 'high'
    });
  }
  
  // Payment frequency insights
  if (userBehavior.paymentFrequency > benchmarks.industryAverage.paymentFrequency * 1.5) {
    insights.push({
      insight: 'High payment frequency indicates strong user engagement',
      category: 'positive',
      actionable: true,
      recommendation: 'Consider loyalty programs to maintain engagement',
      impact: 'medium'
    });
  }
  
  // Risk profile insights
  if (userBehavior.riskProfile === 'erratic') {
    insights.push({
      insight: 'Erratic payment patterns detected - requires monitoring',
      category: 'concern',
      actionable: true,
      recommendation: 'Implement enhanced fraud monitoring and user verification',
      impact: 'high'
    });
  }
  
  // School behavior insights
  if (schoolBehavior.complianceScore < 70) {
    insights.push({
      insight: `Low compliance score of ${schoolBehavior.complianceScore}% indicates operational risks`,
      category: 'critical',
      actionable: true,
      recommendation: 'Review payment processes and implement quality controls',
      impact: 'high'
    });
  }
  
  // Competitive position insights
  if (benchmarks.competitivePosition === 'leading') {
    insights.push({
      insight: 'Leading market position in payment performance',
      category: 'positive',
      actionable: true,
      recommendation: 'Leverage strong position for market expansion',
      impact: 'high'
    });
  } else if (benchmarks.competitivePosition === 'lagging') {
    insights.push({
      insight: 'Below-market payment performance requires strategic improvement',
      category: 'critical',
      actionable: true,
      recommendation: 'Implement comprehensive payment optimization strategy',
      impact: 'high'
    });
  }
  
  return insights;
}

/**
 * Generate payment optimization recommendations
 */
async function generateOptimizationRecommendations(
  currentMetrics: any,
  historicalData: any[],
  benchmarks: any
): Promise<PaymentOptimizationResult> {
  // Calculate current performance
  const currentPerformance = {
    successRate: currentMetrics.successRate || 0,
    averageProcessingTime: 2500, // ms - simplified
    costEfficiency: 0.85, // 85% efficiency
    userSatisfaction: 0.78, // 78% satisfaction
    technicalScore: 0.82 // 82% technical performance
  };
  
  // Generate optimization opportunities
  const optimizationOpportunities = [
    {
      area: 'gateway_selection' as const,
      currentState: 'Single gateway provider',
      recommendedState: 'Multi-gateway routing with intelligent selection',
      expectedImpact: {
        successRateImprovement: 5,
        costReduction: 12,
        userExperienceImprovement: 15,
        implementationComplexity: 'medium' as const,
        timeToImplement: 45
      },
      priority: 'high' as const,
      businessJustification: 'Reduce single points of failure and optimize costs through competitive routing',
      technicalRequirements: ['Gateway abstraction layer', 'Routing logic implementation', 'Failover mechanisms']
    },
    {
      area: 'retry_strategy' as const,
      currentState: 'Basic retry on failure',
      recommendedState: 'Intelligent retry with exponential backoff and alternative methods',
      expectedImpact: {
        successRateImprovement: 8,
        costReduction: 3,
        userExperienceImprovement: 20,
        implementationComplexity: 'low' as const,
        timeToImplement: 15
      },
      priority: 'high' as const,
      businessJustification: 'Recover failed transactions and improve user experience',
      technicalRequirements: ['Retry orchestration service', 'Alternative payment method integration']
    },
    {
      area: 'user_experience' as const,
      currentState: 'Standard checkout flow',
      recommendedState: 'Optimized checkout with smart defaults and saved preferences',
      expectedImpact: {
        successRateImprovement: 12,
        costReduction: 0,
        userExperienceImprovement: 35,
        implementationComplexity: 'medium' as const,
        timeToImplement: 30
      },
      priority: 'medium' as const,
      businessJustification: 'Reduce friction and abandonment in payment flow',
      technicalRequirements: ['UX/UI improvements', 'Preference management system', 'Smart form filling']
    },
    {
      area: 'fraud_prevention' as const,
      currentState: 'Basic fraud detection',
      recommendedState: 'ML-powered real-time fraud prevention with risk scoring',
      expectedImpact: {
        successRateImprovement: 3,
        costReduction: 25,
        userExperienceImprovement: 10,
        implementationComplexity: 'high' as const,
        timeToImplement: 90
      },
      priority: 'medium' as const,
      businessJustification: 'Reduce fraud losses while minimizing false positives',
      technicalRequirements: ['ML fraud detection model', 'Real-time scoring engine', 'Risk management dashboard']
    }
  ];
  
  // Risk mitigation suggestions
  const riskMitigationSuggestions = [
    {
      risk: 'Single gateway dependency',
      mitigation: 'Implement backup gateway with automatic failover',
      cost: 'medium' as const,
      effectiveness: 0.85,
      timeline: '6-8 weeks'
    },
    {
      risk: 'Payment fraud exposure',
      mitigation: 'Deploy real-time fraud scoring with adaptive thresholds',
      cost: 'high' as const,
      effectiveness: 0.92,
      timeline: '12-16 weeks'
    },
    {
      risk: 'Regulatory compliance gaps',
      mitigation: 'Implement comprehensive compliance monitoring and reporting',
      cost: 'medium' as const,
      effectiveness: 0.88,
      timeline: '8-10 weeks'
    }
  ];
  
  return {
    currentPerformance,
    optimizationOpportunities,
    riskMitigationSuggestions
  };
}

/**
 * Generate comprehensive intelligence insights
 */
async function generateIntelligenceInsights(
  timeframe: string,
  schoolId?: string,
  insightTypes: string[] = ['all'],
  riskLevel: string = 'all'
): Promise<IntelligenceInsight[]> {
  const prismaClient = getPrismaClient();
  const insights: IntelligenceInsight[] = [];
  
  // Calculate date range based on timeframe
  const endDate = new Date();
  const startDate = new Date();
  
  switch (timeframe) {
    case 'day':
      startDate.setDate(startDate.getDate() - 1);
      break;
    case 'week':
      startDate.setDate(startDate.getDate() - 7);
      break;
    case 'month':
      startDate.setMonth(startDate.getMonth() - 1);
      break;
    case 'quarter':
      startDate.setMonth(startDate.getMonth() - 3);
      break;
    case 'year':
      startDate.setFullYear(startDate.getFullYear() - 1);
      break;
  }
  
  const whereClause: any = {
    createdAt: {
      gte: startDate,
      lte: endDate
    }
  };
  
  if (schoolId) {
    whereClause.order = {
      user: {
        schoolId
      }
    };
  }
  
  // Get payment data for analysis
  const payments = await prismaClient.payment.findMany({
    where: whereClause,
    include: {
      order: {
        include: {
          user: {
            include: {
              school: true
            }
          }
        }
      }
    }
  });
  
  if (payments.length === 0) {
    return insights;
  }
  
  // Generate fraud alerts
  if (insightTypes.includes('all') || insightTypes.includes('fraud_patterns')) {
    const fraudAlerts = await generateFraudAlerts(payments, riskLevel);
    insights.push(...fraudAlerts);
  }
  
  // Generate pattern discoveries
  if (insightTypes.includes('all') || insightTypes.includes('user_behavior')) {
    const patternInsights = await generatePatternInsights(payments, riskLevel);
    insights.push(...patternInsights);
  }
  
  // Generate optimization opportunities
  if (insightTypes.includes('all') || insightTypes.includes('payment_optimization')) {
    const optimizationInsights = await generateOptimizationInsights(payments, riskLevel);
    insights.push(...optimizationInsights);
  }
  
  // Generate risk assessments
  if (insightTypes.includes('all') || insightTypes.includes('risk_assessment')) {
    const riskInsights = await generateRiskInsights(payments, riskLevel);
    insights.push(...riskInsights);
  }
  
  return insights.sort((a, b) => {
    // Sort by severity and confidence
    const severityWeight = { critical: 4, error: 3, warning: 2, info: 1 };
    const aSeverity = severityWeight[a.severity] || 0;
    const bSeverity = severityWeight[b.severity] || 0;
    
    if (aSeverity !== bSeverity) {
      return bSeverity - aSeverity; // Higher severity first
    }
    
    return b.confidence - a.confidence; // Higher confidence first
  }).slice(0, 20); // Top 20 insights
}

/**
 * Generate fraud alerts
 */
async function generateFraudAlerts(payments: any[], riskLevel: string): Promise<IntelligenceInsight[]> {
  const alerts: IntelligenceInsight[] = [];
  
  // Detect unusual amount patterns
  const amounts = payments.map(p => p.amount).sort((a, b) => a - b);
  const median = amounts[Math.floor(amounts.length / 2)];
  const suspiciousPayments = payments.filter(p => p.amount > median * 10); // 10x median
  
  if (suspiciousPayments.length > 0 && (riskLevel === 'all' || riskLevel === 'high' || riskLevel === 'critical')) {
    alerts.push({
      id: `fraud_amount_${Date.now()}`,
      timestamp: new Date(),
      type: 'fraud_alert',
      severity: 'warning',
      title: 'Unusual High-Value Transactions Detected',
      description: `${suspiciousPayments.length} transactions with amounts significantly above normal (>10x median)`,
      affectedEntities: {
        transactions: suspiciousPayments.length,
        revenue: suspiciousPayments.reduce((sum, p) => sum + p.amount, 0)
      },
      evidence: suspiciousPayments.slice(0, 5).map(p => ({
        transactionId: p.id,
        amount: p.amount,
        timestamp: p.createdAt,
        userId: p.order?.user?.id
      })),
      recommendations: [
        {
          action: 'Review high-value transactions manually',
          priority: 'high',
          effort: 'low',
          impact: 'high',
          timeline: 'Immediate'
        },
        {
          action: 'Implement dynamic transaction limits',
          priority: 'medium',
          effort: 'medium',
          impact: 'medium',
          timeline: '2-4 weeks'
        }
      ],
      confidence: 0.75,
      businessImpact: {
        revenue: suspiciousPayments.reduce((sum, p) => sum + p.amount, 0) * 0.1, // 10% potential impact
        risk: 0.6,
        operationalEfficiency: -0.2,
        userExperience: -0.1
      }
    });
  }
  
  return alerts;
}

/**
 * Generate pattern insights
 */
async function generatePatternInsights(payments: any[], riskLevel: string): Promise<IntelligenceInsight[]> {
  const insights: IntelligenceInsight[] = [];
  
  // Analyze user concentration
  const userCounts: Record<string, number> = {};
  payments.forEach(p => {
    const userId = p.order?.user?.id;
    if (userId) {
      userCounts[userId] = (userCounts[userId] || 0) + 1;
    }
  });
  
  const totalUsers = Object.keys(userCounts).length;
  const powerUsers = Object.entries(userCounts)
    .filter(([, count]) => count > 10) // More than 10 transactions
    .sort(([, a], [, b]) => b - a);
  
  if (powerUsers.length > 0 && powerUsers.length / totalUsers > 0.1) {
    insights.push({
      id: `pattern_power_users_${Date.now()}`,
      timestamp: new Date(),
      type: 'pattern_discovery',
      severity: 'info',
      title: 'High-Value User Concentration Identified',
      description: `${powerUsers.length} users (${((powerUsers.length / totalUsers) * 100).toFixed(1)}%) account for disproportionate transaction volume`,
      affectedEntities: {
        users: powerUsers.length,
        transactions: powerUsers.reduce((sum, [, count]) => sum + count, 0)
      },
      evidence: powerUsers.slice(0, 5).map(([userId, count]) => ({
        userId,
        transactionCount: count,
        percentage: (count / payments.length) * 100
      })),
      recommendations: [
        {
          action: 'Implement VIP user retention program',
          priority: 'medium',
          effort: 'medium',
          impact: 'high',
          timeline: '4-6 weeks'
        },
        {
          action: 'Analyze power user behavior for insights',
          priority: 'low',
          effort: 'low',
          impact: 'medium',
          timeline: '1-2 weeks'
        }
      ],
      confidence: 0.85,
      businessImpact: {
        revenue: 0,
        risk: 0.3, // Risk if power users churn
        operationalEfficiency: 0.1,
        userExperience: 0.2
      }
    });
  }
  
  return insights;
}

/**
 * Generate optimization insights
 */
async function generateOptimizationInsights(payments: any[], riskLevel: string): Promise<IntelligenceInsight[]> {
  const insights: IntelligenceInsight[] = [];
  
  // Analyze failure patterns
  const failedPayments = payments.filter(p => p.status === 'failed');
  const failureRate = failedPayments.length / payments.length;
  
  if (failureRate > 0.1 && (riskLevel === 'all' || riskLevel === 'high' || riskLevel === 'critical')) { // >10% failure rate
    insights.push({
      id: `optimization_failure_rate_${Date.now()}`,
      timestamp: new Date(),
      type: 'optimization_opportunity',
      severity: failureRate > 0.2 ? 'error' : 'warning',
      title: 'High Payment Failure Rate Optimization Opportunity',
      description: `Payment failure rate of ${(failureRate * 100).toFixed(1)}% indicates optimization opportunities`,
      affectedEntities: {
        transactions: failedPayments.length,
        revenue: failedPayments.reduce((sum, p) => sum + p.amount, 0)
      },
      evidence: [
        {
          failureRate: failureRate * 100,
          totalFailures: failedPayments.length,
          potentialRevenueLoss: failedPayments.reduce((sum, p) => sum + p.amount, 0)
        }
      ],
      recommendations: [
        {
          action: 'Implement intelligent payment retry logic',
          priority: 'high',
          effort: 'medium',
          impact: 'high',
          timeline: '3-4 weeks'
        },
        {
          action: 'Analyze and optimize payment gateway configuration',
          priority: 'high',
          effort: 'low',
          impact: 'medium',
          timeline: '1 week'
        },
        {
          action: 'Consider alternative payment methods for failed transactions',
          priority: 'medium',
          effort: 'high',
          impact: 'high',
          timeline: '6-8 weeks'
        }
      ],
      confidence: 0.9,
      businessImpact: {
        revenue: failedPayments.reduce((sum, p) => sum + p.amount, 0) * 0.5, // 50% potential recovery
        risk: -0.3, // Reduces risk
        operationalEfficiency: 0.4,
        userExperience: 0.5
      }
    });
  }
  
  return insights;
}

/**
 * Generate risk insights
 */
async function generateRiskInsights(payments: any[], riskLevel: string): Promise<IntelligenceInsight[]> {
  const insights: IntelligenceInsight[] = [];
  
  // Analyze transaction velocity for potential risks
  const now = Date.now();
  const last24Hours = payments.filter(p => 
    now - new Date(p.createdAt).getTime() < 24 * 60 * 60 * 1000
  );
  
  if (last24Hours.length > 100 && (riskLevel === 'all' || riskLevel === 'medium' || riskLevel === 'high')) { // High velocity
    insights.push({
      id: `risk_high_velocity_${Date.now()}`,
      timestamp: new Date(),
      type: 'risk_escalation',
      severity: 'warning',
      title: 'High Transaction Velocity Detected',
      description: `${last24Hours.length} transactions in the last 24 hours may indicate system stress or unusual activity`,
      affectedEntities: {
        transactions: last24Hours.length
      },
      evidence: [
        {
          transactionsLast24h: last24Hours.length,
          averageHourlyRate: last24Hours.length / 24,
          peakHour: findPeakHour(last24Hours)
        }
      ],
      recommendations: [
        {
          action: 'Monitor system performance and scaling',
          priority: 'high',
          effort: 'low',
          impact: 'high',
          timeline: 'Immediate'
        },
        {
          action: 'Review transaction patterns for anomalies',
          priority: 'medium',
          effort: 'low',
          impact: 'medium',
          timeline: '1-2 days'
        }
      ],
      confidence: 0.8,
      businessImpact: {
        revenue: 0,
        risk: 0.4, // Potential system risk
        operationalEfficiency: -0.2,
        userExperience: -0.1
      }
    });
  }
  
  return insights;
}

/**
 * Find peak hour in transaction data
 */
function findPeakHour(payments: any[]): { hour: number; count: number } {
  const hourCounts: Record<number, number> = {};
  
  payments.forEach(p => {
    const hour = new Date(p.createdAt).getHours();
    hourCounts[hour] = (hourCounts[hour] || 0) + 1;
  });
  
  const peakEntry = Object.entries(hourCounts)
    .sort(([, a], [, b]) => b - a)[0];
  
  return {
    hour: parseInt(peakEntry[0]),
    count: peakEntry[1]
  };
}

/**
 * Lambda handler for advanced payment intelligence
 * Supports: transaction analysis, fraud detection, pattern recognition, behavioral analysis, optimization
 */
export const advancedPaymentIntelligenceHandler = async (
  event: APIGatewayProxyEvent,
  context: Context
): Promise<APIGatewayProxyResult> => {
  const logger = LoggerService.getInstance();
  const requestId = context.awsRequestId;
  
  try {
    logger.info('Advanced Payment Intelligence request started', { requestId, method: event.httpMethod });
    
    // Authenticate request
    const authResult = await authenticateLambda(event);
    
    // Return authentication error if authentication failed
    if ('statusCode' in authResult) {
      logger.warn('Authentication failed for payment intelligence access', {
        requestId,
        ip: event.requestContext.identity.sourceIp
      });
      return authResult as unknown as APIGatewayProxyResult;
    }

    const { user: authenticatedUser } = authResult;
    
    // Check permissions - only admin, school_admin, and super_admin can access intelligence features
    if (!['school_admin', 'admin', 'super_admin'].includes(authenticatedUser.role)) {
      logger.warn('Unauthorized intelligence access attempt', {
        requestId,
        userId: authenticatedUser.id,
        role: authenticatedUser.role
      });
      return createErrorResponse(
        'Insufficient permissions for payment intelligence access',
        403,
        'INSUFFICIENT_PERMISSIONS'
      );
    }
    
    const method = event.httpMethod;
    const pathParameters = event.pathParameters || {};
    const queryStringParameters = event.queryStringParameters || {};
    
    switch (method) {
      case 'GET':
        // Handle intelligence insights query
        if (event.path?.includes('/intelligence-insights')) {
          return await handleIntelligenceInsights(queryStringParameters, authenticatedUser, requestId);
        }
        break;
        
      case 'POST':
        // Handle transaction analysis
        if (event.path?.includes('/analyze-transaction')) {
          return await handleTransactionAnalysis(event, authenticatedUser, requestId);
        }
        break;
        
      default:
        return createErrorResponse(`Method ${method} not allowed`, 405, 'METHOD_NOT_ALLOWED');
    }
    
    return createErrorResponse('Invalid request path', 400, 'INVALID_PATH');
    
  } catch (error: any) {
    logger.error('Advanced Payment Intelligence request failed', {
      requestId,
      error: error instanceof Error ? error.message : String(error),
      stack: error.stack
    });
    
    return handleError(error, 'Advanced Payment Intelligence operation failed');
  } finally {
    if (prisma) {
      await prisma.$disconnect();
      prisma = null;
    }
  }
};

/**
 * Handle intelligence insights requests
 */
async function handleIntelligenceInsights(
  queryParams: Record<string, string>,
  authenticatedUser: AuthenticatedUser,
  requestId: string
): Promise<APIGatewayProxyResult> {
  const logger = LoggerService.getInstance();
  
  const insightsQuery = intelligenceInsightsSchema.parse(queryParams);
  
  // School-level users can only see their own school's data
  const schoolId = authenticatedUser.role === 'school_admin' ? 
    authenticatedUser.schoolId : insightsQuery.schoolId;
  
  logger.info('Intelligence insights query processing', {
    requestId,
    userId: authenticatedUser.id,
    timeframe: insightsQuery.timeframe,
    insightTypes: insightsQuery.insightTypes,
    schoolId,
    riskLevel: insightsQuery.riskLevel
  });
  
  try {
    const insights = await generateIntelligenceInsights(
      insightsQuery.timeframe,
      schoolId,
      insightsQuery.insightTypes,
      insightsQuery.riskLevel
    );
    
    logger.info('Intelligence insights generated successfully', {
      requestId,
      timeframe: insightsQuery.timeframe,
      insightsCount: insights.length,
      criticalInsights: insights.filter(i => i.severity === 'critical').length
    });
    
    return createSuccessResponse({
      message: 'Intelligence insights generated successfully',
      data: {
        query: {
          timeframe: insightsQuery.timeframe,
          insightTypes: insightsQuery.insightTypes,
          riskLevel: insightsQuery.riskLevel,
          schoolId: schoolId || 'all'
        },
        insights,
        summary: {
          totalInsights: insights.length,
          criticalInsights: insights.filter(i => i.severity === 'critical').length,
          highPriorityRecommendations: insights.reduce((sum, i) => 
            sum + i.recommendations.filter(r => r.priority === 'high' || r.priority === 'immediate').length, 0
          )
        },
        generatedAt: new Date().toISOString()
      }
    });
    
  } catch (error: any) {
    logger.error('Intelligence insights generation failed', {
      requestId,
      error: error instanceof Error ? error.message : String(error),
      insightsQuery
    });
    throw error;
  }
}

/**
 * Handle transaction analysis requests
 */
async function handleTransactionAnalysis(
  event: APIGatewayProxyEvent,
  authenticatedUser: AuthenticatedUser,
  requestId: string
): Promise<APIGatewayProxyResult> {
  const logger = LoggerService.getInstance();
  
  const requestBody = JSON.parse(event.body || '{}');
  const analysisData = transactionAnalysisSchema.parse(requestBody);
  
  // School-level users can only analyze their own school's transactions
  const schoolId = authenticatedUser.role === 'school_admin' ? 
    authenticatedUser.schoolId : analysisData.schoolId;
  
  logger.info('Transaction analysis started', {
    requestId,
    userId: authenticatedUser.id,
    analysisType: analysisData.analysisType,
    transactionId: analysisData.transactionId,
    schoolId
  });
  
  try {
    const prismaClient = getPrismaClient();
    
    // Get transaction data for analysis
    let targetTransaction: any = null;
    if (analysisData.transactionId) {
      targetTransaction = await prismaClient.payment.findUnique({
        where: { id: analysisData.transactionId },
        include: {
          order: {
            include: {
              user: {
                include: {
                  school: true
                }
              }
            }
          }
        }
      });
      
      if (!targetTransaction) {
        return createErrorResponse('Transaction not found', 404, 'NOT_FOUND');
      }
      
      // Check if user has access to this transaction
      if (authenticatedUser.role === 'school_admin' && 
          targetTransaction.order?.user?.schoolId !== authenticatedUser.schoolId) {
        return createErrorResponse('Access denied to this transaction', 403, 'ACCESS_DENIED');
      }
    }
    
    // Get historical context
    const historicalData = await prismaClient.payment.findMany({
      where: {
        ...(schoolId && {
          order: {
            user: {
              schoolId
            }
          }
        }),
        createdAt: {
          gte: new Date(Date.now() - 90 * 24 * 60 * 60 * 1000) // Last 90 days
        }
      },
      include: {
        order: {
          include: {
            user: {
              include: {
                school: true
              }
            }
          }
        }
      },
      take: 1000 // Limit for performance
    });
    
    const analysisResult: any = {
      transactionId: analysisData.transactionId,
      analysisType: analysisData.analysisType,
      analysisTimestamp: new Date().toISOString()
    };
    
    // Perform analysis based on type
    if (analysisData.analysisType === 'comprehensive' || analysisData.analysisType === 'fraud_detection') {
      if (targetTransaction) {
        const userProfile = { /* simplified user profile */ };
        const schoolProfile = { /* simplified school profile */ };
        const fraudAnalysis = await detectFraudRisk(targetTransaction, historicalData, userProfile, schoolProfile);
        analysisResult.fraudDetection = fraudAnalysis;
      }
    }
    
    if (analysisData.analysisType === 'comprehensive' || analysisData.analysisType === 'pattern_recognition') {
      const patternAnalysis = await recognizePaymentPatterns(historicalData, 'month', schoolId);
      analysisResult.patternRecognition = patternAnalysis;
    }
    
    if (analysisData.analysisType === 'comprehensive' || analysisData.analysisType === 'behavioral_analysis') {
      const behavioralAnalysis = await performBehavioralAnalysis(historicalData, [], [], schoolId);
      analysisResult.behavioralAnalysis = behavioralAnalysis;
    }
    
    if (analysisData.analysisType === 'comprehensive' || analysisData.analysisType === 'optimization_suggestions') {
      const currentMetrics = { successRate: 0.85 /* calculate from data */ };
      const benchmarks = { /* industry benchmarks */ };
      const optimization = await generateOptimizationRecommendations(currentMetrics, historicalData, benchmarks);
      analysisResult.optimizationRecommendations = optimization;
    }
    
    logger.info('Transaction analysis completed successfully', {
      requestId,
      analysisType: analysisData.analysisType,
      transactionId: analysisData.transactionId,
      dataPoints: historicalData.length
    });
    
    return createSuccessResponse({
      message: 'Transaction analysis completed successfully',
      data: {
        analysisRequest: {
          transactionId: analysisData.transactionId,
          analysisType: analysisData.analysisType,
          schoolId: schoolId || 'all',
          confidenceThreshold: analysisData.confidenceThreshold
        },
        analysisResult,
        metadata: {
          dataPoints: historicalData.length,
          analysisDateTime: new Date().toISOString(),
          processingTime: Date.now() // Simplified
        }
      }
    });
    
  } catch (error: any) {
    logger.error('Transaction analysis failed', {
      requestId,
      error: error instanceof Error ? error.message : String(error),
      analysisData
    });
    throw error;
  }
}

// Export handler as main function
export const handler = advancedPaymentIntelligenceHandler;