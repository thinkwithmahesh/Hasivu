/**
 * HASIVU Platform - Payment Retry System Lambda Function
 * Handles: POST /api/v1/payments/retry, GET /api/v1/payments/{id}/retry, DELETE /api/v1/payments/retry/{id}
 * Implements Story 5.2: Payment Retry System with Intelligent Scheduling
 * Production-ready with retry logic, analytics, and failure handling
 */

import { APIGatewayProxyEvent, APIGatewayProxyResult, Context } from 'aws-lambda';
import { PrismaClient } from '@prisma/client';
const Razorpay = require('razorpay');
import { LoggerService } from '../shared/logger.service';
import { ValidationService } from '../shared/validation.service';
import { createSuccessResponse, createErrorResponse, handleError } from '../../shared/response.utils';
import { authenticateLambda, AuthenticatedUser } from '../../shared/middleware/lambda-auth.middleware';
import { z } from 'zod';

// Initialize database client
const prisma = new PrismaClient();

// Initialize Razorpay client
const razorpay = new Razorpay({
  key_id: process.env.RAZORPAY_KEY_ID || '',
  key_secret: process.env.RAZORPAY_KEY_SECRET || ''
});

// Validation schemas
const retryPaymentSchema = z.object({
  paymentId: z.string().uuid(),
  retryReason: z.string().min(1).max(500),
  delayMinutes: z.number().int().min(1).max(1440).optional(), // Max 24 hours
  maxRetries: z.number().int().min(1).max(5).default(3),
  notifyUser: z.boolean().default(true),
  metadata: z.record(z.string(), z.any()).optional()
});

const scheduleRetrySchema = z.object({
  paymentId: z.string().uuid(),
  scheduleType: z.enum(['immediate', 'delayed', 'smart']).default('smart'),
  delayMinutes: z.number().int().min(5).max(1440).optional(),
  maxAttempts: z.number().int().min(1).max(5).default(3),
  notificationSettings: z.object({
    notifyOnFailure: z.boolean().default(true),
    notifyOnSuccess: z.boolean().default(true),
    notifyOnMaxRetries: z.boolean().default(true)
  }).optional()
});

// Retry analytics interface
interface RetryAnalytics {
  totalRetries: number;
  successfulRetries: number;
  failedRetries: number;
  averageRetryTime: number;
  commonFailureReasons: Array<{
    reason: string;
    count: number;
    percentage: number;
  }>;
  retrySuccessRate: number;
}

/**
 * Calculate smart retry delay based on failure history
 */
function calculateSmartDelay(attemptCount: number, previousFailures: any[]): number {
  // Base delay starts at 5 minutes and increases exponentially
  const baseDelay = 5; // minutes
  const exponentialFactor = Math.pow(2, attemptCount - 1);
  
  // Add jitter to prevent thundering herd
  const jitter = Math.random() * 0.3; // 30% jitter
  
  // Consider failure patterns
  let patternMultiplier = 1;
  if (previousFailures.length > 0) {
    const recentFailures = previousFailures.slice(-3);
    const hasNetworkIssues = recentFailures.some(f => 
      f.reason?.includes('network') || f.reason?.includes('timeout')
    );
    
    if (hasNetworkIssues) {
      patternMultiplier = 1.5; // Longer delay for network issues
    }
  }
  
  const calculatedDelay = Math.min(
    baseDelay * exponentialFactor * patternMultiplier * (1 + jitter),
    120 // Maximum 2 hours
  );
  
  return Math.round(calculatedDelay);
}

/**
 * Check if payment can be retried
 */
async function canRetryPayment(paymentId: string, userId: string): Promise<{
  canRetry: boolean;
  reason?: string;
  maxRetries?: number;
  currentAttempts?: number;
}> {
  const payment = await prisma.payment.findUnique({
    where: { id: paymentId },
    include: {
      paymentRetries: {
        orderBy: { createdAt: 'desc' }
      }
    }
  });
  
  if (!payment) {
    return { canRetry: false, reason: 'Payment not found' };
  }
  
  if (payment.status === 'completed') {
    return { canRetry: false, reason: 'Payment already completed' };
  }
  
  if (payment.status === 'cancelled') {
    return { canRetry: false, reason: 'Payment was cancelled' };
  }
  
  const maxRetries = 5; // System-wide maximum
  const currentAttempts = payment.paymentRetries.length;
  
  if (currentAttempts >= maxRetries) {
    return { 
      canRetry: false, 
      reason: `Maximum retry attempts (${maxRetries}) exceeded for this payment`,
      maxRetries,
      currentAttempts
    };
  }
  
  // Check if there's already a pending retry
  const pendingRetry = await prisma.paymentRetry.findFirst({
    where: {
      paymentId,
      status: 'scheduled'
    }
  });
  
  if (pendingRetry) {
    return { canRetry: false, reason: 'Payment retry already scheduled' };
  }
  
  return { 
    canRetry: true, 
    maxRetries,
    currentAttempts
  };
}

/**
 * Create payment retry attempt record
 */
async function createRetryAttempt(
  paymentId: string,
  userId: string,
  retryReason: string,
  retryType: 'manual' | 'automatic',
  scheduledFor?: Date
): Promise<string> {
  // Get current retry count to set attempt number
  const existingRetries = await prisma.paymentRetry.count({
    where: { paymentId }
  });

  const retryAttempt = await prisma.paymentRetry.create({
    data: {
      paymentId,
      attemptNumber: existingRetries + 1,
      retryAt: scheduledFor || new Date(),
      retryReason,
      retryMethod: retryType,
      status: 'scheduled'
    }
  });
  
  return retryAttempt.id;
}

/**
 * Execute payment retry
 */
async function executePaymentRetry(retryId: string, authenticatedUser: AuthenticatedUser): Promise<any> {
  const logger = LoggerService.getInstance();
  
  const retryAttempt = await prisma.paymentRetry.findUnique({
    where: { id: retryId },
    include: {
      payment: {
        include: {
          order: true,
          paymentRetries: true
        }
      }
    }
  });
  
  if (!retryAttempt) {
    throw new Error('Retry attempt not found');
  }
  
  if (retryAttempt.status !== 'scheduled') {
    throw new Error('Retry attempt is not in scheduled status');
  }
  
  // Update retry status to processing
  await prisma.paymentRetry.update({
    where: { id: retryId },
    data: { 
      status: 'processing'
    }
  });
  
  try {
    // Create new payment order with Razorpay
    const orderOptions = {
      amount: retryAttempt.payment.amount * 100, // Convert to paise
      currency: retryAttempt.payment.currency,
      receipt: `retry_${retryAttempt.payment.id}_${Date.now()}`,
      notes: {
        original_payment_id: retryAttempt.payment.id,
        retry_attempt_id: retryId,
        retry_count: retryAttempt.payment.paymentRetries?.length || 0
      }
    };
    
    const razorpayOrder = await razorpay.orders.create(orderOptions);
    
    // Update payment with new gateway order ID
    await prisma.payment.update({
      where: { id: retryAttempt.paymentId },
      data: {
        razorpayOrderId: razorpayOrder.id,
        status: 'pending',
        updatedAt: new Date()
      }
    });
    
    // Update retry attempt as successful
    await prisma.paymentRetry.update({
      where: { id: retryId },
      data: {
        status: 'completed'
      }
    });
    
    logger.info('Payment retry executed successfully', {
      retryId,
      paymentId: retryAttempt.paymentId,
      razorpayOrderId: razorpayOrder.id,
      executedBy: authenticatedUser.email
    });
    
    return {
      retryId,
      paymentId: retryAttempt.paymentId,
      gatewayOrderId: razorpayOrder.id,
      status: 'completed',
      amount: retryAttempt.payment.amount,
      currency: retryAttempt.payment.currency
    };
    
  } catch (error: any) {
    logger.error('Payment retry execution failed', {
      retryId,
      paymentId: retryAttempt.paymentId,
      error: error instanceof Error ? error.message : String(error)
    });
    
    // Update retry attempt as failed
    await prisma.paymentRetry.update({
      where: { id: retryId },
      data: {
        status: 'failed',
        failureReason: error.message
      }
    });
    
    throw error;
  }
}

/**
 * Get retry analytics for a payment or overall system
 */
async function getRetryAnalytics(paymentId?: string): Promise<RetryAnalytics> {
  const whereClause = paymentId ? { paymentId } : {};
  
  const retryAttempts = await prisma.paymentRetry.findMany({
    where: whereClause,
    include: {
      payment: true
    }
  });
  
  const totalRetries = retryAttempts.length;
  const successfulRetries = retryAttempts.filter(r => r.status === 'completed').length;
  const failedRetriesArray = retryAttempts.filter(r => r.status === 'failed');
  const failedRetries = failedRetriesArray.length;
  
  // Average retry time not available without completedAt field
  const averageRetryTime = 0; // Would need completedAt field in PaymentRetry schema
  
  // Analyze common failure reasons
  const failureReasons = failedRetriesArray.reduce((acc: Record<string, number>, retry) => {
    const reason = retry.retryReason || 'Unknown';
    acc[reason] = (acc[reason] || 0) + 1;
    return acc;
  }, {});
  
  const commonFailureReasons = Object.entries(failureReasons)
    .map(([reason, count]) => ({
      reason,
      count,
      percentage: Math.round((count / failedRetriesArray.length) * 100)
    }))
    .sort((a, b) => b.count - a.count)
    .slice(0, 5); // Top 5 reasons
  
  const retrySuccessRate = totalRetries > 0 ? 
    Math.round((successfulRetries / totalRetries) * 100) : 0;
  
  return {
    totalRetries,
    successfulRetries,
    failedRetries,
    averageRetryTime,
    commonFailureReasons,
    retrySuccessRate
  };
}

/**
 * Lambda handler for payment retry system
 * Supports: manual retry, automatic retry scheduling, retry analytics
 */
export const paymentRetryHandler = async (
  event: APIGatewayProxyEvent,
  context: Context
): Promise<APIGatewayProxyResult> => {
  const logger = LoggerService.getInstance();
  const requestId = context.awsRequestId;
  
  try {
    logger.info('Payment retry request started', { requestId, method: event.httpMethod });
    
    // Authenticate request
    const authResult = await authenticateLambda(event);
    
    if (!authResult.success || !authResult.user) {
      return {
        statusCode: 401,
        body: JSON.stringify({ 
          error: 'Authentication failed', 
          code: 'AUTHENTICATION_FAILED' 
        })
      };
    }
    
    const authenticatedUser = authResult.user;
    const method = event.httpMethod;
    const pathParameters = event.pathParameters || {};
    
    switch (method) {
      case 'POST':
        // Handle manual retry or schedule retry
        if (event.path.includes('/schedule')) {
          return await handleScheduleRetry(event, authenticatedUser, requestId);
        } else {
          return await handleManualRetry(event, authenticatedUser, requestId);
        }
        
      case 'GET':
        // Handle get retry analytics or retry status
        if (pathParameters.paymentId) {
          return await handleGetRetryStatus(pathParameters.paymentId, authenticatedUser, requestId);
        } else {
          return await handleGetRetryAnalytics(event.queryStringParameters, authenticatedUser, requestId);
        }
        
      case 'DELETE':
        // Handle cancel scheduled retry
        if (pathParameters.retryId) {
          return await handleCancelRetry(pathParameters.retryId, authenticatedUser, requestId);
        }
        break;
        
      default:
        return createErrorResponse(`Method ${method} not allowed`, 405, 'METHOD_NOT_ALLOWED');
    }
    
    return createErrorResponse('Invalid request path', 400, 'INVALID_PATH');
    
  } catch (error: any) {
    logger.error('Payment retry request failed', {
      requestId,
      error: error instanceof Error ? error.message : String(error),
      stack: error.stack
    });
    
    return handleError(error, 'Payment retry operation failed');
  } finally {
    await prisma.$disconnect();
  }
};

/**
 * Handle manual payment retry
 */
async function handleManualRetry(
  event: APIGatewayProxyEvent,
  authenticatedUser: AuthenticatedUser,
  requestId: string
): Promise<APIGatewayProxyResult> {
  const logger = LoggerService.getInstance();
  
  const requestBody = JSON.parse(event.body || '{}');
  const retryData = retryPaymentSchema.parse(requestBody);
  
  // Check if payment can be retried
  const retryCheck = await canRetryPayment(retryData.paymentId, authenticatedUser.id);
  if (!retryCheck.canRetry) {
    logger.warn('Payment retry not allowed', { 
      requestId, 
      paymentId: retryData.paymentId,
      reason: retryCheck.reason 
    });
    return createErrorResponse(retryCheck.reason || 'Payment cannot be retried', 400, 'RETRY_NOT_ALLOWED');
  }
  
  // Create retry attempt
  const retryId = await createRetryAttempt(
    retryData.paymentId,
    authenticatedUser.id,
    retryData.retryReason,
    'manual',
    retryData.delayMinutes ? new Date(Date.now() + retryData.delayMinutes * 60 * 1000) : new Date()
  );
  
  // Execute retry immediately if no delay specified
  if (!retryData.delayMinutes) {
    const result = await executePaymentRetry(retryId, authenticatedUser);
    
    logger.info('Manual payment retry completed', {
      requestId,
      paymentId: retryData.paymentId,
      retryId,
      executedBy: authenticatedUser.email
    });
    
    return createSuccessResponse({
      message: 'Payment retry executed successfully',
      data: result
    });
  } else {
    logger.info('Payment retry scheduled', {
      requestId,
      paymentId: retryData.paymentId,
      retryId,
      delayMinutes: retryData.delayMinutes,
      scheduledBy: authenticatedUser.email
    });
    
    return createSuccessResponse({
      message: 'Payment retry scheduled successfully',
      data: {
        retryId,
        paymentId: retryData.paymentId,
        scheduledFor: new Date(Date.now() + retryData.delayMinutes * 60 * 1000).toISOString(),
        delayMinutes: retryData.delayMinutes
      }
    });
  }
}

/**
 * Handle schedule retry
 */
async function handleScheduleRetry(
  event: APIGatewayProxyEvent,
  authenticatedUser: AuthenticatedUser,
  requestId: string
): Promise<APIGatewayProxyResult> {
  const logger = LoggerService.getInstance();
  
  const requestBody = JSON.parse(event.body || '{}');
  const scheduleData = scheduleRetrySchema.parse(requestBody);
  
  // Check if payment can be retried
  const retryCheck = await canRetryPayment(scheduleData.paymentId, authenticatedUser.id);
  if (!retryCheck.canRetry) {
    return createErrorResponse(retryCheck.reason || 'Payment cannot be retried', 400, 'RETRY_NOT_ALLOWED');
  }
  
  // Calculate delay based on schedule type
  let delayMinutes = 5; // Default
  
  if (scheduleData.scheduleType === 'immediate') {
    delayMinutes = 0;
  } else if (scheduleData.scheduleType === 'delayed' && scheduleData.delayMinutes) {
    delayMinutes = scheduleData.delayMinutes;
  } else if (scheduleData.scheduleType === 'smart') {
    // Get previous failures for smart calculation
    const previousFailures = await prisma.paymentRetry.findMany({
      where: { paymentId: scheduleData.paymentId, status: 'failed' },
      orderBy: { createdAt: 'desc' }
    });
    
    delayMinutes = calculateSmartDelay(
      (retryCheck.currentAttempts || 0) + 1,
      previousFailures
    );
  }
  
  const scheduledFor = delayMinutes > 0 ? 
    new Date(Date.now() + delayMinutes * 60 * 1000) : 
    new Date();
  
  const retryId = await createRetryAttempt(
    scheduleData.paymentId,
    authenticatedUser.id,
    `Smart retry scheduled - ${scheduleData.scheduleType}`,
    'automatic',
    scheduledFor
  );
  
  logger.info('Payment retry scheduled', {
    requestId,
    paymentId: scheduleData.paymentId,
    retryId,
    scheduleType: scheduleData.scheduleType,
    delayMinutes,
    scheduledBy: authenticatedUser.email
  });
  
  return createSuccessResponse({
    message: 'Payment retry scheduled successfully',
    data: {
      retryId,
      paymentId: scheduleData.paymentId,
      scheduleType: scheduleData.scheduleType,
      scheduledFor: scheduledFor.toISOString(),
      delayMinutes
    }
  });
}

/**
 * Handle get retry status
 */
async function handleGetRetryStatus(
  paymentId: string,
  authenticatedUser: AuthenticatedUser,
  requestId: string
): Promise<APIGatewayProxyResult> {
  const validationService = ValidationService.getInstance();
  validationService.validateUUID(paymentId, 'Payment ID');
  
  const retryAttempts = await prisma.paymentRetry.findMany({
    where: { paymentId },
    orderBy: { createdAt: 'desc' },
    include: {
      payment: {
        select: { id: true, amount: true, currency: true, status: true }
      }
    }
  });
  
  const analytics = await getRetryAnalytics(paymentId);
  
  return createSuccessResponse({
    message: 'Retry status retrieved successfully',
    data: {
      paymentId,
      retryAttempts,
      analytics
    }
  });
}

/**
 * Handle get retry analytics
 */
async function handleGetRetryAnalytics(
  queryParams: Record<string, string> | null,
  authenticatedUser: AuthenticatedUser,
  requestId: string
): Promise<APIGatewayProxyResult> {
  const paymentId = queryParams?.paymentId;
  
  if (paymentId) {
    const validationService = ValidationService.getInstance();
    validationService.validateUUID(paymentId, 'Payment ID');
  }
  
  const analytics = await getRetryAnalytics(paymentId);
  
  return createSuccessResponse({
    message: 'Retry analytics retrieved successfully',
    data: {
      paymentId: paymentId || 'system-wide',
      analytics
    }
  });
}

/**
 * Handle cancel retry
 */
async function handleCancelRetry(
  retryId: string,
  authenticatedUser: AuthenticatedUser,
  requestId: string
): Promise<APIGatewayProxyResult> {
  const logger = LoggerService.getInstance();
  const validationService = ValidationService.getInstance();
  
  validationService.validateUUID(retryId, 'Retry ID');
  
  const retryAttempt = await prisma.paymentRetry.findUnique({
    where: { id: retryId }
  });
  
  if (!retryAttempt) {
    return createErrorResponse('Retry attempt not found', 404, 'RETRY_NOT_FOUND');
  }
  
  if (retryAttempt.status !== 'scheduled') {
    return createErrorResponse('Can only cancel scheduled retries', 400, 'INVALID_RETRY_STATUS');
  }
  
  await prisma.paymentRetry.update({
    where: { id: retryId },
    data: {
      status: 'cancelled',
      failureReason: 'User cancelled retry attempt'
    }
  });
  
  logger.info('Payment retry cancelled', {
    requestId,
    retryId,
    paymentId: retryAttempt.paymentId,
    cancelledBy: authenticatedUser.email
  });
  
  return createSuccessResponse({
    message: 'Payment retry cancelled successfully',
    data: {
      retryId,
      paymentId: retryAttempt.paymentId,
      status: 'cancelled'
    }
  });
}