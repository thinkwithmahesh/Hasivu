/**
 * HASIVU Platform - Comprehensive System Health Check
 * Verifies all critical system components and services
 * Implements: GET /health/system
 * Production-ready with parallel health checks and detailed metrics
 */

import { APIGatewayProxyEvent, APIGatewayProxyResult, Context } from 'aws-lambda';
import { DatabaseService } from '../../services/database.service';
import { RedisService } from '../../services/redis.service';
import { LoggerService } from '../../services/logger.service';
import { createSuccessResponse, createErrorResponse, handleError } from '../../shared/response.utils';
import { config } from '../../config/environment';

// Health check interfaces
interface ServiceHealth {
  name: string;
  status: 'healthy' | 'degraded' | 'unhealthy';
  responseTime: number;
  details: Record<string, any>;
  lastChecked: string;
}

interface SystemHealth {
  overallStatus: 'healthy' | 'degraded' | 'unhealthy';
  timestamp: string;
  uptime: number;
  services: ServiceHealth[];
  systemMetrics: {
    memory: {
      used: number;
      free: number;
      total: number;
      percentage: number;
    };
    nodeVersion: string;
    environment: string;
  };
  responseTime: number;
}

/**
 * Check database health and connectivity
 */
async function checkDatabaseHealth(): Promise<ServiceHealth> {
  const startTime = Date.now();
  const logger = LoggerService.getInstance();
  
  try {
    // Test database connectivity with a simple query
    const database = DatabaseService.getInstance();
    
    const queryStartTime = Date.now();
    await database.query('SELECT 1 as health_check');
    const queryTime = Date.now() - queryStartTime;
    
    // Test connection pool status
    const poolStatus = await database.getConnectionPoolStatus();
    
    const responseTime = Date.now() - startTime;
    
    return {
      name: 'database',
      status: queryTime < 1000 ? 'healthy' : queryTime < 3000 ? 'degraded' : 'unhealthy',
      responseTime,
      details: {
        queryResponseTime: `${queryTime}ms`,
        connectionPool: poolStatus,
        type: 'PostgreSQL',
        ssl: database.isSSLEnabled()
      },
      lastChecked: new Date().toISOString()
    };
    
  } catch (error: any) {
    logger.error('Database health check failed', { error: error instanceof Error ? error.message : String(error) });
    
    return {
      name: 'database',
      status: 'unhealthy',
      responseTime: Date.now() - startTime,
      details: {
        error: error instanceof Error ? error.message : String(error),
        type: 'PostgreSQL'
      },
      lastChecked: new Date().toISOString()
    };
  }
}

/**
 * Check Redis cache health and connectivity
 */
async function checkRedisHealth(): Promise<ServiceHealth> {
  const startTime = Date.now();
  const logger = LoggerService.getInstance();
  
  try {
    const redis = RedisService;
    
    // Test Redis connectivity with ping
    const pingStartTime = Date.now();
    const pingResult = await redis.ping();
    const pingTime = Date.now() - pingStartTime;
    
    // Test set/get operations
    const testKey = `health_check:${Date.now()}`;
    const testValue = 'health_check_value';
    
    const setStartTime = Date.now();
    await redis.set(testKey, testValue, 60); // 60 second TTL
    const setDuration = Date.now() - setStartTime;
    
    const getStartTime = Date.now();
    const getValue = await redis.get(testKey);
    const getDuration = Date.now() - getStartTime;
    
    // Cleanup test key
    await redis.del(testKey);
    
    const responseTime = Date.now() - startTime;
    const totalDuration = pingTime + setDuration + getDuration;
    
    return {
      name: 'redis',
      status: totalDuration < 500 ? 'healthy' : totalDuration < 1500 ? 'degraded' : 'unhealthy',
      responseTime,
      details: {
        pingResult,
        pingResponseTime: `${pingTime}ms`,
        setResponseTime: `${setDuration}ms`,
        getResponseTime: `${getDuration}ms`,
        totalResponseTime: `${totalDuration}ms`,
        testDataIntegrity: getValue === testValue
      },
      lastChecked: new Date().toISOString()
    };
    
  } catch (error: any) {
    logger.error('Redis health check failed', { error: error instanceof Error ? error.message : String(error) });
    
    return {
      name: 'redis',
      status: 'unhealthy',
      responseTime: Date.now() - startTime,
      details: {
        error: error instanceof Error ? error.message : String(error),
        type: 'Redis'
      },
      lastChecked: new Date().toISOString()
    };
  }
}

/**
 * Check external services health (WhatsApp, payment gateways)
 */
async function checkExternalServicesHealth(): Promise<ServiceHealth[]> {
  const logger = LoggerService.getInstance();
  const externalServices: ServiceHealth[] = [];
  
  // WhatsApp Business API health check
  try {
    const whatsappStartTime = Date.now();
    
    // Basic configuration check
    const hasRequiredConfig = !!(
      config.whatsapp?.accessToken && 
      config.whatsapp?.phoneNumberId &&
      config.whatsapp?.webhookVerifyToken
    );
    
    const whatsappResponseTime = Date.now() - whatsappStartTime;
    
    externalServices.push({
      name: 'whatsapp_business_api',
      status: hasRequiredConfig ? 'healthy' : 'degraded',
      responseTime: whatsappResponseTime,
      details: {
        configurationComplete: hasRequiredConfig,
        phoneNumberId: config.whatsapp?.phoneNumberId ? `${config.whatsapp.phoneNumberId.substring(0, 10)}...` : 'not_configured',
        hasAccessToken: !!config.whatsapp?.accessToken,
        hasVerifyToken: !!config.whatsapp?.webhookVerifyToken
      },
      lastChecked: new Date().toISOString()
    });
    
  } catch (error: any) {
    logger.error('WhatsApp health check failed', { error: error instanceof Error ? error.message : String(error) });
    
    externalServices.push({
      name: 'whatsapp_business_api',
      status: 'unhealthy',
      responseTime: 0,
      details: {
        error: error instanceof Error ? error.message : String(error)
      },
      lastChecked: new Date().toISOString()
    });
  }
  
  // Payment gateway health check
  try {
    const paymentStartTime = Date.now();
    
    const hasRazorpayConfig = !!(
      config.razorpay?.keyId && 
      config.razorpay?.keySecret
    );
    
    const paymentResponseTime = Date.now() - paymentStartTime;
    
    externalServices.push({
      name: 'payment_gateways',
      status: hasRazorpayConfig ? 'healthy' : 'degraded',
      responseTime: paymentResponseTime,
      details: {
        razorpay: {
          configured: hasRazorpayConfig,
          hasKeyId: !!config.razorpay?.keyId,
          hasKeySecret: !!config.razorpay?.keySecret
        }
      },
      lastChecked: new Date().toISOString()
    });
    
  } catch (error: any) {
    logger.error('Payment gateway health check failed', { error: error instanceof Error ? error.message : String(error) });
    
    externalServices.push({
      name: 'payment_gateways',
      status: 'unhealthy',
      responseTime: 0,
      details: {
        error: error instanceof Error ? error.message : String(error)
      },
      lastChecked: new Date().toISOString()
    });
  }
  
  return externalServices;
}

/**
 * Determine overall system health based on individual service statuses
 */
function determineOverallHealth(services: ServiceHealth[]): 'healthy' | 'degraded' | 'unhealthy' {
  const healthyCount = services.filter(s => s.status === 'healthy').length;
  const degradedCount = services.filter(s => s.status === 'degraded').length;
  const unhealthyCount = services.filter(s => s.status === 'unhealthy').length;
  
  // If any core service (database, redis) is unhealthy, system is unhealthy
  const coreServices = services.filter(s => ['database', 'redis'].includes(s.name));
  const unhealthyCoreServices = coreServices.filter(s => s.status === 'unhealthy');
  
  if (unhealthyCoreServices.length > 0) {
    return 'unhealthy';
  }
  
  // If more than half of services are unhealthy
  if (unhealthyCount > services.length / 2) {
    return 'unhealthy';
  }
  
  // If any services are degraded or unhealthy
  if (degradedCount > 0 || unhealthyCount > 0) {
    return 'degraded';
  }
  
  return 'healthy';
}

/**
 * Get system-level metrics
 */
function getSystemMetrics() {
  const memoryUsage = process.memoryUsage();
  
  return {
    memory: {
      used: Math.round((memoryUsage.heapUsed / 1024 / 1024) * 100) / 100, // MB
      free: Math.round(((memoryUsage.heapTotal - memoryUsage.heapUsed) / 1024 / 1024) * 100) / 100, // MB
      total: Math.round((memoryUsage.heapTotal / 1024 / 1024) * 100) / 100, // MB
      percentage: Math.round((memoryUsage.heapUsed / memoryUsage.heapTotal) * 100)
    },
    nodeVersion: process.version,
    environment: process.env.NODE_ENV || 'development'
  };
}

/**
 * Perform comprehensive system health check
 * GET /health/system
 */
export const systemHealthCheckHandler = async (
  event: APIGatewayProxyEvent,
  context: Context
): Promise<APIGatewayProxyResult> => {
  const logger = LoggerService.getInstance();
  const requestId = context.awsRequestId;
  const startTime = Date.now();
  
  try {
    logger.info('System health check started', { requestId });
    
    // Only allow GET method
    if (event.httpMethod !== 'GET') {
      return createErrorResponse('Method not allowed', 405, 'METHOD_NOT_ALLOWED');
    }
    
    // Perform parallel health checks for all services
    const [databaseHealth, redisHealth, externalServicesHealth] = await Promise.all([
      checkDatabaseHealth(),
      checkRedisHealth(),
      checkExternalServicesHealth()
    ]);
    
    // Combine all service health checks
    const allServices = [
      databaseHealth,
      redisHealth,
      ...externalServicesHealth
    ];
    
    // Determine overall system health
    const overallHealth = determineOverallHealth(allServices);
    
    // Get system metrics
    const systemMetrics = getSystemMetrics();
    
    const healthResult: SystemHealth = {
      overallStatus: overallHealth,
      timestamp: new Date().toISOString(),
      uptime: process.uptime(),
      services: allServices,
      systemMetrics,
      responseTime: Date.now() - startTime
    };
    
    const duration = Date.now() - startTime;
    logger.info('System health check completed', {
      requestId,
      overallStatus: overallHealth,
      duration,
      servicesChecked: allServices.length
    });
    
    // Return appropriate status code based on health
    const statusCode = overallHealth === 'healthy' ? 200 : 
                      overallHealth === 'degraded' ? 200 : 503;
    
    return createSuccessResponse({
      ...healthResult,
      message: `System health check completed - ${overallHealth.toUpperCase()}`
    }, statusCode);
    
  } catch (error: any) {
    const duration = Date.now() - startTime;
    logger.error('System health check failed', {
      requestId,
      error: error instanceof Error ? error.message : String(error),
      duration: `${duration}ms`
    });
    
    return handleError(error, 'System health check failed');
  }
};