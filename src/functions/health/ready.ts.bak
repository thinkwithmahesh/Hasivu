/**
 * HASIVU Platform - Readiness Health Check Lambda Function
 * Implements: GET /api/v1/health/ready
 * Migration from Express route to AWS Lambda - checks if service is ready to serve traffic
 */
import { APIGatewayProxyEvent, APIGatewayProxyResult, Context } from 'aws-lambda';
import { PrismaClient } from '@prisma/client';
import { LoggerService } from '../shared/logger.service';
import { createSuccessResponse, createErrorResponse, handleError } from '../shared/response.utils';

// Initialize database client
const prisma = new PrismaClient();

// Common Lambda response helper
const createResponse = (statusCode: number, body: any, headers: Record<string, string> = {}): APIGatewayProxyResult => ({
  statusCode,
  headers: {
    'Content-Type': 'application/json',
    'Cache-Control': 'no-cache',
    ...headers
  },
  body: JSON.stringify(body)
});

/**
 * Check if all required dependencies are available and ready
 */
const checkReadiness = async (): Promise<{
  ready: boolean;
  checks: Record<string, any>;
  issues: string[];
}> => {
  const checks: any = {};
  const issues: string[] = [];
  
  try {
    // Check database connectivity
    const dbStartTime = Date.now();
    await prisma.$queryRaw`SELECT 1`;
    const dbDuration = Date.now() - dbStartTime;
    
    checks.database = {
      status: 'ready',
      responseTime: `${dbDuration}ms`,
      message: 'Database connection successful'
    };
  } catch (dbError) {
    checks.database = {
      status: 'not_ready',
      error: (dbError as Error).message,
      message: 'Database connection failed'
    };
    issues.push('Database connectivity check failed');
  }
  
  // Check required environment variables
  const requiredEnvVars = [
    'DATABASE_URL',
    'JWT_SECRET',
    'NODE_ENV'
  ];
  
  const missingEnvVars = requiredEnvVars.filter(varName => !process.env[varName]);
  
  checks.environment = {
    status: missingEnvVars.length === 0 ? 'ready' : 'not_ready',
    requiredVariables: requiredEnvVars.length,
    foundVariables: requiredEnvVars.length - missingEnvVars.length,
    message: missingEnvVars.length === 0 
      ? 'All required environment variables are present'
      : `Missing required environment variables: ${missingEnvVars.join(', ')}`
  };
  
  if (missingEnvVars.length > 0) {
    issues.push(`Missing required environment variables: ${missingEnvVars.join(', ')}`);
  }
  
  // Check memory usage
  const memUsage = process.memoryUsage();
  const memUsageMB = Math.round(memUsage.heapUsed / 1024 / 1024);
  const memLimitMB = 512; // Typical Lambda memory limit
  
  checks.memory = {
    status: memUsageMB < memLimitMB * 0.8 ? 'ready' : 'warning',
    usage: `${memUsageMB}MB`,
    limit: `${memLimitMB}MB`,
    percentage: Math.round((memUsageMB / memLimitMB) * 100),
    message: memUsageMB < memLimitMB * 0.8 
      ? 'Memory usage is within acceptable limits'
      : 'Memory usage is approaching limits'
  };
  
  if (memUsageMB >= memLimitMB * 0.8) {
    issues.push('High memory usage detected');
  }
  
  const ready = issues.length === 0;
  
  return { ready, checks, issues };
};

/**
 * Readiness Health Check Handler
 * GET /api/v1/health/ready
 */
export const readinessCheckHandler = async (
  event: APIGatewayProxyEvent,
  context: Context
): Promise<APIGatewayProxyResult> => {
  const logger = LoggerService.getInstance();
  const requestId = context.awsRequestId;
  const startTime = Date.now();
  
  try {
    logger.info('Readiness check started', { requestId });
    
    const readinessResult = await checkReadiness();
    const duration = Date.now() - startTime;
    
    const response = {
      ready: readinessResult.ready,
      timestamp: new Date().toISOString(),
      checks: readinessResult.checks,
      issues: readinessResult.issues,
      duration: `${duration}ms`
    };
    
    logger.info('Readiness check completed', {
      requestId,
      ready: readinessResult.ready,
      issueCount: readinessResult.issues.length,
      duration: `${duration}ms`
    });
    
    // Return 200 if ready, 503 if not ready
    const statusCode = readinessResult.ready ? 200 : 503;
    
    return createResponse(statusCode, {
      success: readinessResult.ready,
      data: response,
      message: readinessResult.ready 
        ? 'Service is ready to serve traffic'
        : `Service is not ready: ${readinessResult.issues.join(', ')}`
    });
    
  } catch (error: any) {
    logger.error('Readiness check failed', {
      requestId,
      error: error instanceof Error ? error.message : String(error),
      stack: error.stack
    });
    
    return handleError(error, 'Readiness check failed');
  } finally {
    await prisma.$disconnect();
  }
};