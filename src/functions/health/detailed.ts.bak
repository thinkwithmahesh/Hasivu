/**
 * HASIVU Platform - Detailed Health Check Lambda Function
 * Comprehensive health check with detailed metrics and diagnostics
 * Implements: GET /health/detailed
 */

import { APIGatewayProxyEvent, APIGatewayProxyResult, Context } from 'aws-lambda';
import { DatabaseService } from '../../services/database.service';
import { RedisService } from '../../services/redis.service';
import { LoggerService } from '../../services/logger.service';

// Initialize services
const logger = LoggerService.getInstance();

// Types and interfaces
interface DetailedHealthResult {
  status: 'healthy' | 'degraded' | 'unhealthy';
  timestamp: string;
  responseTime: number;
  services: DetailedServiceHealth[];
  system: DetailedSystemMetrics;
  environment: EnvironmentInfo;
  diagnostics: DiagnosticInfo[];
}

interface DetailedServiceHealth {
  name: string;
  status: 'healthy' | 'degraded' | 'unhealthy';
  responseTime: number;
  details: any;
  tests: ServiceTest[];
}

interface ServiceTest {
  name: string;
  status: 'passed' | 'failed' | 'warning';
  responseTime: number;
  details?: any;
  error?: string;
}

interface DetailedSystemMetrics {
  uptime: number;
  memory: {
    used: number;
    free: number;
    total: number;
    heapUsed: number;
    heapTotal: number;
    external: number;
    arrayBuffers: number;
  };
  cpu: {
    user: number;
    system: number;
  };
  process: {
    pid: number;
    uptime: number;
    platform: string;
    arch: string;
    nodeVersion: string;
  };
  gc?: {
    lastRun?: number;
    totalRuns?: number;
  };
}

interface EnvironmentInfo {
  nodeEnv: string;
  region: string;
  stage: string;
  version: string;
  deployment: {
    timestamp?: string;
    commit?: string;
    branch?: string;
  };
}

interface DiagnosticInfo {
  category: 'performance' | 'security' | 'configuration' | 'resource';
  level: 'info' | 'warning' | 'error';
  message: string;
  details?: any;
}

// Common Lambda response helper
const createResponse = (statusCode: number, body: any, headers: Record<string, string> = {}): APIGatewayProxyResult => ({
  statusCode,
  headers: {
    'Content-Type': 'application/json',
    'Access-Control-Allow-Origin': '*',
    'Access-Control-Allow-Headers': 'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token',
    'Access-Control-Allow-Methods': 'GET,POST,PUT,DELETE,OPTIONS',
    ...headers
  },
  body: JSON.stringify(body)
});

/**
 * Detailed health check handler
 * GET /health/detailed
 */
export const detailedHealthHandler = async (
  event: APIGatewayProxyEvent,
  context: Context
): Promise<APIGatewayProxyResult> => {
  const startTime = Date.now();
  
  try {
    logger.info('Starting detailed health check', {
      requestId: context.awsRequestId,
      functionName: context.functionName
    });

    // Perform all health checks in parallel for efficiency
    const [
      databaseHealth,
      redisHealth
    ] = await Promise.allSettled([
      performDetailedDatabaseCheck(),
      performDetailedRedisCheck()
    ]);

    // Process service results
    const services: DetailedServiceHealth[] = [
      databaseHealth.status === 'fulfilled' ? databaseHealth.value : createFailedServiceHealth('database', databaseHealth.reason),
      redisHealth.status === 'fulfilled' ? redisHealth.value : createFailedServiceHealth('redis', redisHealth.reason)
    ];

    // Determine overall system status
    const overallStatus = determineOverallStatus(services);

    // Get detailed system metrics
    const systemMetrics = getDetailedSystemMetrics();

    // Get environment information
    const environmentInfo = getEnvironmentInfo();

    // Run diagnostics
    const diagnostics = await runDiagnostics(services, systemMetrics);

    const totalResponseTime = Date.now() - startTime;

    const healthResult: DetailedHealthResult = {
      status: overallStatus,
      timestamp: new Date().toISOString(),
      responseTime: totalResponseTime,
      services,
      system: systemMetrics,
      environment: environmentInfo,
      diagnostics
    };

    logger.info('Detailed health check completed', {
      status: overallStatus,
      responseTime: totalResponseTime,
      servicesChecked: services.length,
      diagnosticsRun: diagnostics.length,
      requestId: context.awsRequestId
    });

    // Return appropriate status code based on health
    const statusCode = overallStatus === 'healthy' ? 200 : 
                      overallStatus === 'degraded' ? 200 : 503;

    return createResponse(statusCode, {
      success: true,
      data: healthResult,
      message: `Detailed health check completed - ${overallStatus.toUpperCase()}`
    });

  } catch (error: unknown) {
    const duration = Date.now() - startTime;
    logger.error('Detailed health check failed', {
      error: error instanceof Error ? error.message : 'Unknown error',
      duration,
      requestId: context.awsRequestId
    });

    return createResponse(500, {
      success: false,
      error: 'Internal server error during detailed health check',
      requestId: context.awsRequestId
    });
  }
};

/**
 * Perform detailed database health check
 */
async function performDetailedDatabaseCheck(): Promise<DetailedServiceHealth> {
  const startTime = Date.now();
  const tests: ServiceTest[] = [];

  // Connection test
  try {
    const testStart = Date.now();
    await DatabaseService.client.$queryRaw`SELECT 1 as test`;
    tests.push({
      name: 'connection',
      status: 'passed',
      responseTime: Date.now() - testStart
    });
  } catch (error: unknown) {
    tests.push({
      name: 'connection',
      status: 'failed',
      responseTime: 0,
      error: error instanceof Error ? error.message : 'Connection failed'
    });
  }

  // Performance test
  try {
    const testStart = Date.now();
    await DatabaseService.client.$queryRaw`SELECT pg_database_size(current_database()) as size`;
    const responseTime = Date.now() - testStart;
    tests.push({
      name: 'performance',
      status: responseTime > 1000 ? 'warning' : 'passed',
      responseTime,
      details: { threshold: '1000ms', actual: `${responseTime}ms` }
    });
  } catch (error: unknown) {
    tests.push({
      name: 'performance',
      status: 'failed',
      responseTime: 0,
      error: error instanceof Error ? error.message : 'Performance test failed'
    });
  }

  const failedTests = tests.filter(t => t.status === 'failed');
  const warningTests = tests.filter(t => t.status === 'warning');
  
  const status = failedTests.length > 0 ? 'unhealthy' :
                warningTests.length > 0 ? 'degraded' : 'healthy';

  return {
    name: 'database',
    status,
    responseTime: Date.now() - startTime,
    details: {
      testsRun: tests.length,
      testsPassed: tests.filter(t => t.status === 'passed').length,
      testsWarning: warningTests.length,
      testsFailed: failedTests.length
    },
    tests
  };
}

/**
 * Perform detailed Redis health check
 */
async function performDetailedRedisCheck(): Promise<DetailedServiceHealth> {
  const startTime = Date.now();
  const tests: ServiceTest[] = [];

  // Connection test
  try {
    const testStart = Date.now();
    const testKey = `health_detailed:${Date.now()}`;
    await RedisService.set(testKey, 'test', 5);
    const value = await RedisService.get(testKey);
    
    if (value === 'test') {
      tests.push({
        name: 'connection',
        status: 'passed',
        responseTime: Date.now() - testStart
      });
    } else {
      tests.push({
        name: 'connection',
        status: 'failed',
        responseTime: Date.now() - testStart,
        error: 'Read/write validation failed'
      });
    }
  } catch (error: unknown) {
    tests.push({
      name: 'connection',
      status: 'failed',
      responseTime: 0,
      error: error instanceof Error ? error.message : 'Connection failed'
    });
  }

  // Performance test
  try {
    const testStart = Date.now();
    const testKey = `perf_test:${Date.now()}`;
    await RedisService.set(testKey, 'performance_test', 1);
    await RedisService.get(testKey);
    const responseTime = Date.now() - testStart;
    
    tests.push({
      name: 'performance',
      status: responseTime > 500 ? 'warning' : 'passed',
      responseTime,
      details: { threshold: '500ms', actual: `${responseTime}ms` }
    });
  } catch (error: unknown) {
    tests.push({
      name: 'performance',
      status: 'failed',
      responseTime: 0,
      error: error instanceof Error ? error.message : 'Performance test failed'
    });
  }

  const failedTests = tests.filter(t => t.status === 'failed');
  const warningTests = tests.filter(t => t.status === 'warning');
  
  const status = failedTests.length > 0 ? 'unhealthy' :
                warningTests.length > 0 ? 'degraded' : 'healthy';

  return {
    name: 'redis',
    status,
    responseTime: Date.now() - startTime,
    details: {
      testsRun: tests.length,
      testsPassed: tests.filter(t => t.status === 'passed').length,
      testsWarning: warningTests.length,
      testsFailed: failedTests.length
    },
    tests
  };
}

/**
 * Create failed service health result
 */
function createFailedServiceHealth(serviceName: string, error: any): DetailedServiceHealth {
  return {
    name: serviceName,
    status: 'unhealthy',
    responseTime: 0,
    details: { error: error instanceof Error ? error.message : 'Service check failed' },
    tests: [{
      name: 'initialization',
      status: 'failed',
      responseTime: 0,
      error: error instanceof Error ? error.message : 'Unknown error'
    }]
  };
}

/**
 * Determine overall status based on service health
 */
function determineOverallStatus(services: DetailedServiceHealth[]): 'healthy' | 'degraded' | 'unhealthy' {
  const unhealthyServices = services.filter(s => s.status === 'unhealthy');
  const degradedServices = services.filter(s => s.status === 'degraded');
  
  if (unhealthyServices.length > 0) {
    return 'unhealthy';
  }
  
  if (degradedServices.length > 0) {
    return 'degraded';
  }
  
  return 'healthy';
}

/**
 * Get detailed system metrics
 */
function getDetailedSystemMetrics(): DetailedSystemMetrics {
  const memoryUsage = process.memoryUsage();
  const cpuUsage = process.cpuUsage();
  
  return {
    uptime: process.uptime(),
    memory: {
      used: memoryUsage.heapUsed,
      free: memoryUsage.heapTotal - memoryUsage.heapUsed,
      total: memoryUsage.heapTotal,
      heapUsed: memoryUsage.heapUsed,
      heapTotal: memoryUsage.heapTotal,
      external: memoryUsage.external,
      arrayBuffers: memoryUsage.arrayBuffers
    },
    cpu: {
      user: cpuUsage.user,
      system: cpuUsage.system
    },
    process: {
      pid: process.pid,
      uptime: process.uptime(),
      platform: process.platform,
      arch: process.arch,
      nodeVersion: process.version
    }
  };
}

/**
 * Get environment information
 */
function getEnvironmentInfo(): EnvironmentInfo {
  return {
    nodeEnv: process.env.NODE_ENV || 'unknown',
    region: process.env.AWS_REGION || 'unknown',
    stage: process.env.STAGE || 'unknown',
    version: process.env.APP_VERSION || '1.0.0',
    deployment: {
      timestamp: process.env.DEPLOYMENT_TIMESTAMP,
      commit: process.env.GIT_COMMIT,
      branch: process.env.GIT_BRANCH
    }
  };
}

/**
 * Run system diagnostics
 */
async function runDiagnostics(services: DetailedServiceHealth[], system: DetailedSystemMetrics): Promise<DiagnosticInfo[]> {
  const diagnostics: DiagnosticInfo[] = [];

  // Memory usage diagnostic
  const memoryUsedPercent = (system.memory.heapUsed / system.memory.heapTotal) * 100;
  if (memoryUsedPercent > 90) {
    diagnostics.push({
      category: 'resource',
      level: 'error',
      message: `Critical memory usage: ${memoryUsedPercent.toFixed(1)}%`,
      details: { threshold: '90%', current: `${memoryUsedPercent.toFixed(1)}%` }
    });
  } else if (memoryUsedPercent > 75) {
    diagnostics.push({
      category: 'resource',
      level: 'warning',
      message: `High memory usage: ${memoryUsedPercent.toFixed(1)}%`,
      details: { threshold: '75%', current: `${memoryUsedPercent.toFixed(1)}%` }
    });
  }

  // Service response time diagnostics
  services.forEach(service => {
    if (service.responseTime > 2000) {
      diagnostics.push({
        category: 'performance',
        level: 'warning',
        message: `Slow response time for ${service.name}: ${service.responseTime}ms`,
        details: { service: service.name, responseTime: service.responseTime, threshold: '2000ms' }
      });
    }
  });

  // Environment diagnostics
  if (process.env.NODE_ENV === 'development') {
    diagnostics.push({
      category: 'configuration',
      level: 'info',
      message: 'Running in development mode',
      details: { nodeEnv: process.env.NODE_ENV }
    });
  }

  return diagnostics;
}