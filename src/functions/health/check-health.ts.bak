/**
 * HASIVU Platform - System Health Check Lambda Function
 * Comprehensive system health monitoring with detailed service checks
 * Implements: GET /health, GET /health/detailed
 */

import { APIGatewayProxyEvent, APIGatewayProxyResult, Context } from 'aws-lambda';
import { DatabaseService } from '@/services/database.service';
import { RedisService } from '@/services/redis.service';
import { logger } from '@/utils/logger';
import { createSuccessResponse, createErrorResponse, handleError } from '@/shared/response.utils';
import { config } from '@/config/environment';

/**
 * Health check result interface
 */
interface HealthCheckResult {
  status: 'healthy' | 'degraded' | 'unhealthy';
  timestamp: string;
  services: {
    database: ServiceHealth;
    redis: ServiceHealth;
    external: Record<string, ExternalServiceHealth>;
  };
  system: SystemMetrics;
  recommendations?: string[];
}

/**
 * Service health check interface
 */
interface ServiceHealth {
  status: 'healthy' | 'degraded' | 'unhealthy';
  responseTime: number;
  lastChecked: string;
  details?: string;
}

/**
 * System metrics interface
 */
interface SystemMetrics {
  uptime: number;
  memory: {
    used: number;
    free: number;
    percentage: number;
  };
  timestamp: string;
}

/**
 * External service health check interface
 */
interface ExternalServiceHealth extends ServiceHealth {
  endpoint: string;
  timeout: number;
}

/**
 * Basic health check endpoint
 * GET /health
 */
export const healthCheckHandler = async (
  event: APIGatewayProxyEvent,
  context: Context
): Promise<APIGatewayProxyResult> => {
  const startTime = Date.now();
  logger.logFunctionStart('healthCheckHandler', { event, context });

  try {
    // Perform parallel health checks
    const [databaseHealth, redisHealth] = await Promise.all([
      checkDatabaseHealth(),
      checkRedisHealth()
    ]);

    // Determine overall system health
    const overallStatus = determineOverallHealth([databaseHealth, redisHealth]);
    
    const healthCheckResult: HealthCheckResult = {
      status: overallStatus,
      timestamp: new Date().toISOString(),
      services: {
        database: databaseHealth,
        redis: redisHealth,
        external: {}, // External services checked in detailed health check
      },
      system: getSystemMetrics()
    };

    const duration = Date.now() - startTime;
    logger.logFunctionEnd("handler", { statusCode: 200, duration });

    // Return appropriate status code based on health
    const statusCode = overallStatus === 'healthy' ? 200 : 
                      overallStatus === 'degraded' ? 200 : 503;

    return createSuccessResponse({
      data: healthCheckResult,
      message: `System health check completed - ${overallStatus.toUpperCase()}`
    }, statusCode);

  } catch (error: unknown) {
    const duration = Date.now() - startTime;
    logger.logFunctionEnd("handler", { statusCode: 500, duration });
    return handleError(error, 'Health check failed');
  }
};

/**
 * Detailed health check endpoint with external services
 * GET /health/detailed
 */
export const detailedHealthCheckHandler = async (
  event: APIGatewayProxyEvent,
  context: Context
): Promise<APIGatewayProxyResult> => {
  const startTime = Date.now();
  logger.logFunctionStart('detailedHealthCheckHandler', { event, context });

  try {
    // Perform parallel health checks including external services
    const [databaseHealth, redisHealth, externalServices] = await Promise.all([
      checkDatabaseHealth(),
      checkRedisHealth(),
      checkExternalServices()
    ]);

    // Determine overall system health
    const allServices = [databaseHealth, redisHealth, ...Object.values(externalServices)];
    const overallStatus = determineOverallHealth(allServices);

    const recommendations: string[] = [];
    
    // Generate recommendations based on service health
    if (databaseHealth.status !== 'healthy') {
      recommendations.push('Database service requires attention - check connection and performance');
    }
    if (redisHealth.status !== 'healthy') {
      recommendations.push('Redis service requires attention - check connection and memory usage');
    }
    
    // Check for slow external services
    Object.entries(externalServices).forEach(([serviceName, health]) => {
      if (health.responseTime > 2000) {
        recommendations.push(`${serviceName} service response time is slow`);
      }
      if (health.status === 'unhealthy') {
        recommendations.push(`${serviceName} service is unreachable - check connectivity and credentials`);
      }
    });

    const healthCheckResult: HealthCheckResult = {
      status: overallStatus,
      timestamp: new Date().toISOString(),
      services: {
        database: databaseHealth,
        redis: redisHealth,
        external: externalServices
      },
      system: getSystemMetrics(),
      recommendations: recommendations.length > 0 ? recommendations : undefined
    };

    const duration = Date.now() - startTime;
    logger.logFunctionEnd("handler", { statusCode: 200, duration });

    // Return appropriate status code based on health
    const statusCode = overallStatus === 'healthy' ? 200 : 
                      overallStatus === 'degraded' ? 200 : 503;

    return createSuccessResponse({
      data: healthCheckResult,
      message: `Detailed system health check completed - ${overallStatus.toUpperCase()}`
    }, statusCode);

  } catch (error: unknown) {
    const duration = Date.now() - startTime;
    logger.logFunctionEnd("handler", { statusCode: 500, duration });
    return handleError(error, 'Detailed health check failed');
  }
};

/**
 * Check database connectivity and performance
 */
async function checkDatabaseHealth(): Promise<ServiceHealth> {
  const startTime = Date.now();
  
  try {
    const database = DatabaseService.getInstance();
    await database.query('SELECT 1');
    
    const responseTime = Date.now() - startTime;
    
    return {
      status: responseTime < 1000 ? 'healthy' : responseTime < 3000 ? 'degraded' : 'unhealthy',
      responseTime,
      lastChecked: new Date().toISOString(),
      details: `Database query completed in ${responseTime}ms`
    };
  } catch (error: unknown) {
    return {
      status: 'unhealthy',
      responseTime: Date.now() - startTime,
      lastChecked: new Date().toISOString(),
      details: `Database connection failed: ${error instanceof Error ? error.message : 'Unknown error'}`
    };
  }
}

/**
 * Check Redis connectivity and performance
 */
async function checkRedisHealth(): Promise<ServiceHealth> {
  const startTime = Date.now();
  
  try {
    const redis = RedisService;
    await redis.ping();
    
    const responseTime = Date.now() - startTime;
    
    return {
      status: responseTime < 500 ? 'healthy' : responseTime < 1500 ? 'degraded' : 'unhealthy',
      responseTime,
      lastChecked: new Date().toISOString(),
      details: `Redis ping completed in ${responseTime}ms`
    };
  } catch (error: unknown) {
    return {
      status: 'unhealthy',
      responseTime: Date.now() - startTime,
      lastChecked: new Date().toISOString(),
      details: `Redis connection failed: ${error instanceof Error ? error.message : 'Unknown error'}`
    };
  }
}

/**
 * Check external service health
 */
async function checkExternalServices(): Promise<Record<string, ExternalServiceHealth>> {
  const externalServices: Record<string, ExternalServiceHealth> = {};
  
  // Check payment service (Razorpay)
  if (config.razorpay?.keyId) {
    externalServices.razorpay = await checkExternalService(
      'https://api.razorpay.com/v1/payments',
      'razorpay',
      5000
    );
  }
  
  // Check notification services
  if (config.notifications?.email?.apiKey) {
    externalServices.email = await checkExternalService(
      'https://api.emailservice.com/health',
      'email',
      3000
    );
  }
  
  return externalServices;
}

/**
 * Check individual external service
 */
async function checkExternalService(
  endpoint: string,
  serviceName: string,
  timeout: number
): Promise<ExternalServiceHealth> {
  const startTime = Date.now();
  
  try {
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), timeout);
    
    const response = await fetch(endpoint, {
      method: 'HEAD',
      signal: controller.signal,
    });
    
    clearTimeout(timeoutId);
    const responseTime = Date.now() - startTime;
    
    const status = response.ok ? 
      (responseTime < 2000 ? 'healthy' : 'degraded') : 
      'unhealthy';
    
    return {
      status,
      responseTime,
      lastChecked: new Date().toISOString(),
      endpoint,
      timeout,
      details: `${serviceName} service responded with ${response.status} in ${responseTime}ms`
    };
  } catch (error: unknown) {
    return {
      status: 'unhealthy',
      responseTime: Date.now() - startTime,
      lastChecked: new Date().toISOString(),
      endpoint,
      timeout,
      details: `${serviceName} service failed: ${error instanceof Error ? error.message : 'Unknown error'}`
    };
  }
}

/**
 * Determine overall system health based on individual service health
 */
function determineOverallHealth(services: ServiceHealth[]): 'healthy' | 'degraded' | 'unhealthy' {
  const unhealthyCount = services.filter(s => s.status === 'unhealthy').length;
  const degradedCount = services.filter(s => s.status === 'degraded').length;
  
  if (unhealthyCount > 0) {
    return 'unhealthy';
  }
  
  if (degradedCount > 0) {
    return 'degraded';
  }
  
  return 'healthy';
}

/**
 * Get current system metrics
 */
function getSystemMetrics(): SystemMetrics {
  const uptime = process.uptime();
  const memUsage = process.memoryUsage();
  
  return {
    uptime,
    memory: {
      used: memUsage.heapUsed,
      free: memUsage.heapTotal - memUsage.heapUsed,
      percentage: (memUsage.heapUsed / memUsage.heapTotal) * 100
    },
    timestamp: new Date().toISOString()
  };
}