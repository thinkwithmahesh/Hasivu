/**
 * HASIVU Platform - User Repository
 * Comprehensive data access layer for user management with optimized queries and caching
 * Implements Story 1.3: Core User Management System
 * Enhanced to support bulk operations, audit logging, and parent-child relationships
 */
import { PrismaClient, User, Prisma } from '@prisma/client';
import { DatabaseService } from '../services/database.service';
import { RedisService } from '../services/redis.service';
import { logger } from '../utils/logger';

// Enhanced interfaces for repository operations
export interface UserSearchOptions {
  query?: string;
  schoolId?: string;
  role?: string;
  isActive?: boolean;
  parentId?: string;
  hasChildren?: boolean;
  sortBy?: string;
  sortOrder?: 'asc' | 'desc';
  page?: number;
  limit?: number;
}

export interface UserListResult {
  users: User[];
  total: number;
  page: number;
  limit: number;
  totalPages: number;
}

export interface UserWithRelations extends User {
  school?: any;
  parent?: User;
  children?: User[];
}

export interface BulkCreateResult {
  success: boolean;
  created: User[];
  errors: { data: any; error: string }[];
}

export interface UserAuditLogEntry {
  id: string;
  userId: string;
  action: string;
  performedBy: string;
  changes: Record<string, { from: any; to: any }>;
  metadata?: Record<string, any>;
  timestamp: Date;
}

export interface UserDependencyCheck {
  hasOrders: boolean;
  hasChildren: boolean;
  dependentCount: number;
}

/**
 * User Repository - Comprehensive data access patterns with advanced features
 * Supports bulk operations, caching, audit logging, and relationship management
 */
export class UserRepository {
  private static prisma = DatabaseService.getInstance();
  private static redis = RedisService;

  // Cache TTL constants
  private static readonly CACHE_TTL = {
    USER: 3600, // 1 hour
    SEARCH: 300, // 5 minutes
    LIST: 600   // 10 minutes
  };

  /**
   * Find user by ID with comprehensive relationship loading
   */
  static async findById(id: string, includeRelations: boolean = true): Promise<UserWithRelations | null> {
    try {
      const cacheKey = `user:${id}:relations:${includeRelations}`;
      const cached = await this.redis.get(cacheKey);
      if (cached) {
        return JSON.parse(cached);
      }

      const include = includeRelations ? {
        school: true,
        parent: true,
        children: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            email: true,
            role: true,
            isActive: true,
            createdAt: true
          }
        }
      } : undefined;

      const user = await this.prisma.user.findUnique({
        where: { id },
        include
      });

      if (user) {
        await this.redis.setex(cacheKey, this.CACHE_TTL.USER, JSON.stringify(user));
      }

      return user as UserWithRelations;
    } catch (error: unknown) {
      logger.error('Error finding user by ID', { userId: id, error: (error as Error).message });
      throw error;
    }
  }

  /**
   * Find user by email with relationship data
   */
  static async findByEmail(email: string, includeRelations: boolean = false): Promise<UserWithRelations | null> {
    try {
      const normalizedEmail = email.toLowerCase().trim();
      const cacheKey = `user:email:${normalizedEmail}:relations:${includeRelations}`;
      const cached = await this.redis.get(cacheKey);
      if (cached) {
        return JSON.parse(cached);
      }

      const include = includeRelations ? {
        school: true,
        parent: true,
        children: true
      } : undefined;

      const user = await this.prisma.user.findUnique({
        where: { email: normalizedEmail },
        include
      });

      if (user) {
        await this.redis.setex(cacheKey, this.CACHE_TTL.USER, JSON.stringify(user));
      }

      return user as UserWithRelations;
    } catch (error: unknown) {
      logger.error('Error finding user by email', { email, error: (error as Error).message });
      throw error;
    }
  }

  /**
   * Create new user with enhanced data validation
   */
  static async create(data: Prisma.UserCreateInput): Promise<UserWithRelations> {
    try {
      const user = await this.prisma.user.create({
        data: {
          ...data,
          email: data.email.toLowerCase().trim(),
          createdAt: new Date(),
          updatedAt: new Date()
        },
        include: {
          school: true,
          parent: true,
          children: true
        }
      });

      // Clear related caches
      await this.clearUserCache(undefined, user.schoolId || undefined);
      
      logger.info('User created successfully', { userId: user.id, email: user.email });
      return user as UserWithRelations;
    } catch (error: unknown) {
      logger.error('Error creating user', { data: { ...data, email: data.email }, error: (error as Error).message });
      throw error;
    }
  }

  /**
   * Update user with comprehensive change tracking
   */
  static async update(id: string, data: Prisma.UserUpdateInput): Promise<UserWithRelations> {
    try {
      const user = await this.prisma.user.update({
        where: { id },
        data: {
          ...data,
          updatedAt: new Date()
        },
        include: {
          school: true,
          parent: true,
          children: true
        }
      });

      // Clear user-specific caches
      await this.clearUserCache(id, user.schoolId || undefined);

      logger.info('User updated successfully', { userId: id, changedFields: Object.keys(data) });
      return user as UserWithRelations;
    } catch (error: unknown) {
      logger.error('Error updating user', { userId: id, error: (error as Error).message });
      throw error;
    }
  }

  /**
   * Find users by school with advanced filtering and caching
   */
  static async findBySchool(
    schoolId: string,
    options: { page?: number; limit?: number; role?: string; isActive?: boolean; includeRelations?: boolean } = {}
  ): Promise<UserListResult> {
    try {
      const page = options.page || 1;
      const limit = Math.min(options.limit || 50, 100);
      const offset = (page - 1) * limit;

      const cacheKey = `school:${schoolId}:users:${JSON.stringify(options)}`;
      const cached = await this.redis.get(cacheKey);
      if (cached) {
        return JSON.parse(cached);
      }

      const where: Prisma.UserWhereInput = { 
        schoolId,
        ...(options.role && { role: options.role }),
        ...(options.isActive !== undefined && { isActive: options.isActive })
      };

      const include = options.includeRelations ? {
        school: true,
        parent: true,
        children: true
      } : undefined;

      const [users, total] = await Promise.all([
        this.prisma.user.findMany({
          where,
          skip: offset,
          take: limit,
          orderBy: { createdAt: 'desc' },
          include
        }),
        this.prisma.user.count({ where })
      ]);

      const result = {
        users,
        total,
        page,
        limit,
        totalPages: Math.ceil(total / limit)
      };

      await this.redis.setex(cacheKey, this.CACHE_TTL.LIST, JSON.stringify(result));
      return result;
    } catch (error: unknown) {
      logger.error('Error finding users by school', { schoolId, options, error: (error as Error).message });
      throw error;
    }
  }

  /**
   * Advanced user search with comprehensive filtering and caching
   */
  static async search(options: UserSearchOptions): Promise<UserListResult> {
    try {
      const page = options.page || 1;
      const limit = Math.min(options.limit || 50, 100);
      const offset = (page - 1) * limit;

      const cacheKey = `users:search:${JSON.stringify(options)}`;
      const cached = await this.redis.get(cacheKey);
      if (cached) {
        return JSON.parse(cached);
      }

      const where: Prisma.UserWhereInput = {
        AND: [
          ...(options.query ? [{
            OR: [
              { email: { contains: options.query } },
              { firstName: { contains: options.query } },
              { lastName: { contains: options.query } }
            ]
          }] : []),
          ...(options.schoolId ? [{ schoolId: options.schoolId }] : []),
          ...(options.role ? [{ role: options.role }] : []),
          ...(options.isActive !== undefined ? [{ isActive: options.isActive }] : []),
          ...(options.parentId ? [{ parentId: options.parentId }] : []),
          ...(options.hasChildren !== undefined ? [
            options.hasChildren ? { children: { some: {} } } : { children: { none: {} } }
          ] : [])
        ]
      };

      // Dynamic ordering
      const orderBy: Prisma.UserOrderByWithRelationInput = {};
      if (options.sortBy) {
        orderBy[options.sortBy as keyof Prisma.UserOrderByWithRelationInput] = options.sortOrder || 'asc';
      } else {
        orderBy.createdAt = 'desc';
      }

      const [users, total] = await Promise.all([
        this.prisma.user.findMany({
          where,
          skip: offset,
          take: limit,
          orderBy,
          include: {
            school: true,
            parent: true,
            children: true
          }
        }),
        this.prisma.user.count({ where })
      ]);

      const result = {
        users,
        total,
        page,
        limit,
        totalPages: Math.ceil(total / limit)
      };

      await this.redis.setex(cacheKey, this.CACHE_TTL.SEARCH, JSON.stringify(result));
      return result;
    } catch (error: unknown) {
      logger.error('Error searching users', { options, error: (error as Error).message });
      throw error;
    }
  }

  /**
   * Soft delete user with dependency checking
   */
  static async softDelete(id: string): Promise<UserWithRelations> {
    try {
      const user = await this.prisma.user.update({
        where: { id },
        data: {
          isActive: false,
          // deletedAt: new Date(), // Field doesn't exist in schema
          updatedAt: new Date()
        },
        include: {
          school: true,
          parent: true,
          children: true
        }
      });

      await this.clearUserCache(id, user.schoolId || undefined);
      logger.info('User soft deleted', { userId: id });
      return user as UserWithRelations;
    } catch (error: unknown) {
      logger.error('Error soft deleting user', { userId: id, error: (error as Error).message });
      throw error;
    }
  }

  /**
   * Bulk create users with transaction support
   */
  static async bulkCreate(usersData: Prisma.UserCreateInput[]): Promise<BulkCreateResult> {
    const result: BulkCreateResult = {
      success: false,
      created: [],
      errors: []
    };

    try {
      const transaction = await DatabaseService.client.$transaction(
        usersData.map(data => 
          this.prisma.user.create({
            data: {
              ...data,
              email: data.email.toLowerCase().trim(),
              createdAt: new Date(),
              updatedAt: new Date()
            }
          })
        ),
        {
          isolationLevel: Prisma.TransactionIsolationLevel.Serializable
        }
      );

      result.created = transaction;
      result.success = true;

      // Clear caches for affected schools
      const schoolIds = [...new Set(usersData.map(u => (u as any).schoolId).filter(Boolean))];
      for (const schoolId of schoolIds) {
        await this.clearUserCache(undefined, schoolId as string);
      }

      logger.info('Bulk user creation completed', { count: result.created.length });
      return result;
    } catch (error: unknown) {
      logger.error('Error in bulk user creation', { count: usersData.length, error: (error as Error).message });
      throw error;
    }
  }

  /**
   * Get user children with pagination
   */
  static async getChildren(
    parentId: string,
    options: { page?: number; limit?: number } = {}
  ): Promise<UserListResult> {
    try {
      const page = options.page || 1;
      const limit = Math.min(options.limit || 50, 100);
      const offset = (page - 1) * limit;

      const [users, total] = await Promise.all([
        this.prisma.user.findMany({
          where: { parentId },
          skip: offset,
          take: limit,
          orderBy: { firstName: 'asc' },
          include: {
            school: true
          }
        }),
        this.prisma.user.count({ where: { parentId } })
      ]);

      return {
        users,
        total,
        page,
        limit,
        totalPages: Math.ceil(total / limit)
      };
    } catch (error: unknown) {
      logger.error('Error getting user children', { parentId, error: (error as Error).message });
      throw error;
    }
  }

  /**
   * Update children associations for a parent user
   */
  static async updateChildrenAssociations(
    parentId: string,
    childrenIds: string[]
  ): Promise<void> {
    try {
      await DatabaseService.client.$transaction(async (tx) => {
        // Remove old associations
        await tx.user.updateMany({
          where: { parentId },
          data: { parentId: null }
        });

        // Add new associations
        if (childrenIds.length > 0) {
          await tx.user.updateMany({
            where: { id: { in: childrenIds } },
            data: { parentId }
          });
        }
      });

      // Clear caches
      await this.clearUserCache(parentId);
      for (const childId of childrenIds) {
        await this.clearUserCache(childId);
      }

      logger.info('Children associations updated', { parentId, childrenCount: childrenIds.length });
    } catch (error: unknown) {
      logger.error('Error updating children associations', { parentId, childrenIds, error: (error as Error).message });
      throw error;
    }
  }

  /**
   * Check user dependencies before deletion
   */
  static async checkDependencies(userId: string): Promise<UserDependencyCheck> {
    try {
      const [childrenCount] = await Promise.all([
        this.prisma.user.count({ where: { parentId: userId } })
        // Add order count when order model is available
        // this.prisma.order.count({ where: { userId } })
      ]);

      return {
        hasOrders: false, // Will be implemented when order model is available
        hasChildren: childrenCount > 0,
        dependentCount: childrenCount
      };
    } catch (error: unknown) {
      logger.error('Error checking user dependencies', { userId, error: (error as Error).message });
      throw error;
    }
  }

  /**
   * Create audit log entry
   */
  static async createAuditLog(log: Omit<UserAuditLogEntry, 'id' | 'timestamp'>): Promise<void> {
    try {
      // userAuditLog model doesn't exist in schema
      // await DatabaseService.client.userAuditLog.create({
      //   data: {
      //     ...log,
      //     timestamp: new Date()
      //   }
      // });
    } catch (error: unknown) {
      logger.error('Error creating audit log', { log, error: (error as Error).message });
      // Don't throw - audit logging should not break main operations
    }
  }

  /**
   * Get user audit logs with pagination
   */
  static async getAuditLogs(
    userId: string,
    options: { page?: number; limit?: number } = {}
  ): Promise<{ logs: UserAuditLogEntry[]; total: number; totalPages: number }> {
    try {
      const page = options.page || 1;
      const limit = Math.min(options.limit || 50, 100);
      const offset = (page - 1) * limit;

      // userAuditLog model doesn't exist in schema
      const [logs, total] = await Promise.all([
        // DatabaseService.client.userAuditLog.findMany({
        //   where: { userId },
        //   skip: offset,
        //   take: limit,
        //   orderBy: { timestamp: 'desc' }
        // }),
        // DatabaseService.client.userAuditLog.count({ where: { userId } })
        Promise.resolve([]),
        Promise.resolve(0)
      ]);

      return {
        logs: logs as UserAuditLogEntry[],
        total,
        totalPages: Math.ceil(total / limit)
      };
    } catch (error: unknown) {
      logger.error('Error getting audit logs', { userId, error: (error as Error).message });
      throw error;
    }
  }

  /**
   * Get users by role with caching
   */
  static async findByRole(
    role: string,
    schoolId?: string,
    options: { page?: number; limit?: number } = {}
  ): Promise<UserListResult> {
    try {
      const page = options.page || 1;
      const limit = Math.min(options.limit || 50, 100);
      const offset = (page - 1) * limit;

      const cacheKey = `users:role:${role}:school:${schoolId || 'all'}:${JSON.stringify(options)}`;
      const cached = await this.redis.get(cacheKey);
      if (cached) {
        return JSON.parse(cached);
      }

      const where: Prisma.UserWhereInput = {
        role,
        ...(schoolId && { schoolId })
      };

      const [users, total] = await Promise.all([
        this.prisma.user.findMany({
          where,
          skip: offset,
          take: limit,
          orderBy: { createdAt: 'desc' },
          include: {
            school: true,
            parent: true,
            children: true
          }
        }),
        this.prisma.user.count({ where })
      ]);

      const result = {
        users,
        total,
        page,
        limit,
        totalPages: Math.ceil(total / limit)
      };

      await this.redis.setex(cacheKey, this.CACHE_TTL.LIST, JSON.stringify(result));
      return result;
    } catch (error: unknown) {
      logger.error('Error finding users by role', { role, schoolId, error: (error as Error).message });
      throw error;
    }
  }

  /**
   * Get user statistics
   */
  static async getUserStats(schoolId?: string): Promise<{
    total: number;
    byRole: Record<string, number>;
    active: number;
    inactive: number;
  }> {
    try {
      const cacheKey = `users:stats:school:${schoolId || 'all'}`;
      const cached = await this.redis.get(cacheKey);
      if (cached) {
        return JSON.parse(cached);
      }

      const where = schoolId ? { schoolId } : {};

      const [total, active, inactive, byRole] = await Promise.all([
        this.prisma.user.count({ where }),
        this.prisma.user.count({ where: { ...where, isActive: true } }),
        this.prisma.user.count({ where: { ...where, isActive: false } }),
        this.prisma.user.groupBy({
          by: ['role'],
          where,
          _count: { role: true }
        })
      ]);

      const roleStats = byRole.reduce((acc, item) => {
        acc[item.role] = item._count.role;
        return acc;
      }, {} as Record<string, number>);

      const stats = {
        total,
        byRole: roleStats,
        active,
        inactive
      };

      await this.redis.setex(cacheKey, this.CACHE_TTL.SEARCH, JSON.stringify(stats));
      return stats;
    } catch (error: unknown) {
      logger.error('Error getting user statistics', { schoolId, error: (error as Error).message });
      throw error;
    }
  }

  /**
   * Comprehensive cache cleanup for user-related queries
   */
  static async clearUserCache(userId?: string, schoolId?: string): Promise<void> {
    try {
      const patterns = [
        ...(userId ? [`user:${userId}*`, `user:email:*`] : []),
        ...(schoolId ? [`school:${schoolId}:*`] : []),
        'users:*'
      ];

      for (const pattern of patterns) {
        await this.redis.del(pattern);
      }

      logger.debug('User cache cleared', { userId, schoolId, patterns });
    } catch (error: unknown) {
      logger.error('Error clearing user cache', { userId, schoolId, error: (error as Error).message });
      // Don't throw - cache clearing should not break main operations
    }
  }

  /**
   * Find multiple users with filters
   */
  static async findMany(options: {
    filters?: Record<string, any>;
    select?: string[];
    include?: any;
    skip?: number;
    take?: number;
    sortBy?: string;
    sortOrder?: 'asc' | 'desc';
  } = {}): Promise<{ items: User[]; total?: number }> {
    try {
      const {
        filters = {},
        select,
        include,
        skip,
        take,
        sortBy,
        sortOrder = 'desc'
      } = options;

      const where: Prisma.UserWhereInput = filters;
      const orderBy: Prisma.UserOrderByWithRelationInput = {};

      if (sortBy) {
        orderBy[sortBy as keyof Prisma.UserOrderByWithRelationInput] = sortOrder;
      } else {
        orderBy.createdAt = 'desc';
      }

      const items = await this.prisma.user.findMany({
        where,
        ...(select ? { select: select.reduce((acc, field) => ({ ...acc, [field]: true }), {}) } : {}),
        ...(include ? { include } : {}),
        skip,
        take,
        orderBy
      });

      return { items };
    } catch (error: unknown) {
      logger.error('Error finding users', { options, error: (error as Error).message });
      throw error;
    }
  }

  /**
   * Batch operations for performance optimization
   */
  static async batchUpdate(
    updates: Array<{ id: string; data: Prisma.UserUpdateInput }>
  ): Promise<{ updated: number; errors: Array<{ id: string; error: string }> }> {
    const errors: Array<{ id: string; error: string }> = [];
    let updated = 0;

    try {
      await DatabaseService.client.$transaction(
        updates.map(({ id, data }) =>
          this.prisma.user.update({
            where: { id },
            data: {
              ...data,
              updatedAt: new Date()
            }
          })
        )
      );

      updated = updates.length;

      // Clear caches for all updated users
      for (const { id } of updates) {
        await this.clearUserCache(id);
      }

      logger.info('Batch user update completed', { updated });
      return { updated, errors };
    } catch (error: unknown) {
      logger.error('Error in batch user update', { count: updates.length, error: (error as Error).message });
      throw error;
    }
  }
}