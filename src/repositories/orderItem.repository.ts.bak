/**
 * HASIVU Platform - OrderItem Repository
 * Data access layer for order item management
 * Implements Epic 3: Parent Ordering System - Order Items Data Layer
 * Generated by SuperClaude Wave 3: Epic 3 Implementation - REPOSITORY
 */
import { OrderItem, Prisma } from '@prisma/client';
import { DatabaseService } from '../services/database.service';
import { logger } from '../utils/logger';

/**
 * OrderItem find options interface
 */
export interface OrderItemFindOptions {
  filters?: Record<string, any>;
  skip?: number;
  take?: number;
  sortBy?: string;
  sortOrder?: 'asc' | 'desc';
  include?: Prisma.OrderItemInclude;
}

/**
 * OrderItem find result interface
 */
export interface OrderItemFindResult {
  items: OrderItem[];
  total: number;
}

/**
 * Popular item result interface
 */
export interface PopularItem {
  menuItemId: string;
  menuItemName: string;
  totalQuantity: number;
  orderCount: number;
  revenue: number;
}

/**
 * OrderItem Repository class
 */
export class OrderItemRepository {
  /**
   * Create new order item
   */
  public static async create(data: Prisma.OrderItemCreateInput): Promise<OrderItem> {
    try {
      const orderItem = await DatabaseService.client.orderItem.create({
        data
      });
      
      logger.debug('OrderItem created', { orderItemId: orderItem.id });
      return orderItem;
    } catch (error: unknown) {
      logger.error('Failed to create order item', error, { data });
      throw error;
    }
  }

  /**
   * Create multiple order items
   */
  public static async createMany(
    data: Prisma.OrderItemCreateManyInput[]
  ): Promise<Prisma.BatchPayload> {
    try {
      const result = await DatabaseService.client.orderItem.createMany({
        data
      });
      
      logger.debug('OrderItems created in batch', { count: result.count });
      return result;
    } catch (error: unknown) {
      logger.error('Failed to create order items in batch', error, { data });
      throw error;
    }
  }

  /**
   * Find order item by ID
   */
  public static async findById(id: string): Promise<OrderItem | null> {
    try {
      const orderItem = await DatabaseService.client.orderItem.findUnique({
        where: { id }
      });
      
      return orderItem;
    } catch (error: unknown) {
      logger.error('Failed to find order item by ID', error, { orderItemId: id });
      throw error;
    }
  }

  /**
   * Find order item by ID with includes
   */
  public static async findByIdWithIncludes(
    id: string, 
    include: Prisma.OrderItemInclude
  ): Promise<OrderItem | null> {
    try {
      const orderItem = await DatabaseService.client.orderItem.findUnique({
        where: { id },
        include
      });
      
      return orderItem;
    } catch (error: unknown) {
      logger.error('Failed to find order item by ID with includes', error, { orderItemId: id });
      throw error;
    }
  }

  /**
   * Find multiple order items with options
   */
  public static async findMany(options: OrderItemFindOptions = {}): Promise<OrderItemFindResult> {
    try {
      const {
        filters = {},
        skip = 0,
        take = 20,
        sortBy = 'createdAt',
        sortOrder = 'desc',
        include
      } = options;

      // Build where clause
      const where: Prisma.OrderItemWhereInput = { ...filters };

      // Build orderBy clause
      const orderBy: Prisma.OrderItemOrderByWithRelationInput = {
        [sortBy]: sortOrder
      };

      const [items, total] = await Promise.all([
        DatabaseService.client.orderItem.findMany({
          where,
          skip,
          take,
          orderBy,
          ...(include && { include })
        }),
        DatabaseService.client.orderItem.count({ where })
      ]);

      return { items, total };
    } catch (error: unknown) {
      logger.error('Failed to find order items', error, { options });
      throw error;
    }
  }

  /**
   * Update order item
   */
  public static async update(id: string, data: Prisma.OrderItemUpdateInput): Promise<OrderItem> {
    try {
      const orderItem = await DatabaseService.client.orderItem.update({
        where: { id },
        data
      });
      
      logger.debug('OrderItem updated', { orderItemId: orderItem.id });
      return orderItem;
    } catch (error: unknown) {
      logger.error('Failed to update order item', error, { orderItemId: id, data });
      throw error;
    }
  }

  /**
   * Delete order item
   */
  public static async delete(id: string): Promise<OrderItem> {
    try {
      const orderItem = await DatabaseService.client.orderItem.delete({
        where: { id }
      });
      
      logger.debug('OrderItem deleted', { orderItemId: orderItem.id });
      return orderItem;
    } catch (error: unknown) {
      logger.error('Failed to delete order item', error, { orderItemId: id });
      throw error;
    }
  }

  /**
   * Find order items by order ID
   */
  public static async findByOrderId(
    orderId: string,
    options: Omit<OrderItemFindOptions, 'filters'> = {}
  ): Promise<OrderItemFindResult> {
    try {
      return await this.findMany({
        ...options,
        filters: { orderId }
      });
    } catch (error: unknown) {
      logger.error('Failed to find order items by order ID', error, { orderId });
      throw error;
    }
  }

  /**
   * Find order items by menu item ID
   */
  public static async findByMenuItemId(
    menuItemId: string,
    options: Omit<OrderItemFindOptions, 'filters'> = {}
  ): Promise<OrderItemFindResult> {
    try {
      return await this.findMany({
        ...options,
        filters: { menuItemId }
      });
    } catch (error: unknown) {
      logger.error('Failed to find order items by menu item ID', error, { menuItemId });
      throw error;
    }
  }

  /**
   * Count order items with filters
   */
  public static async count(filters: Record<string, any> = {}): Promise<number> {
    try {
      const count = await DatabaseService.client.orderItem.count({
        where: filters
      });
      
      return count;
    } catch (error: unknown) {
      logger.error('Failed to count order items', error, { filters });
      throw error;
    }
  }

  /**
   * Get popular items based on order frequency and quantity
   */
  public static async getPopularItems(
    filters: Record<string, any> = {},
    limit: number = 10
  ): Promise<PopularItem[]> {
    try {
      // Build the SQL query with proper joins
      const whereClause = this.buildWhereClause(filters);
      
      const popularItems = await DatabaseService.client.$queryRaw<Array<{
        menuItemId: string;
        menuItemName: string;
        totalQuantity: string;
        orderCount: string;
        revenue: string;
      }>>`
        SELECT 
          oi.menuItemId,
          mi.name as menuItemName,
          SUM(oi.quantity) as totalQuantity,
          COUNT(DISTINCT oi.orderId) as orderCount,
          SUM(oi.price * oi.quantity) as revenue
        FROM OrderItem oi
        INNER JOIN MenuItem mi ON oi.menuItemId = mi.id
        INNER JOIN Order o ON oi.orderId = o.id
        ${whereClause.length > 0 ? Prisma.sql`WHERE ${Prisma.join(whereClause, ' AND ')}` : Prisma.empty}
        GROUP BY oi.menuItemId, mi.name
        ORDER BY totalQuantity DESC, orderCount DESC
        LIMIT ${limit}
      `;

      return popularItems.map((item: any) => ({
        menuItemId: item.menuItemId,
        menuItemName: item.menuItemName,
        totalQuantity: parseInt(item.totalQuantity),
        orderCount: parseInt(item.orderCount),
        revenue: parseFloat(item.revenue)
      }));
    } catch (error: unknown) {
      logger.error('Failed to get popular items', error, { filters, limit });
      throw error;
    }
  }

  /**
   * Get order item statistics
   */
  public static async getStatistics(
    filters: Record<string, any> = {}
  ): Promise<{
    totalItems: number;
    totalQuantity: number;
    totalRevenue: number;
    averageQuantityPerOrder: number;
    averageRevenuePerOrder: number;
  }> {
    try {
      const where: Prisma.OrderItemWhereInput = {};
      
      // Build where clause based on filters
      if (filters.orderId) where.orderId = filters.orderId;
      if (filters.menuItemId) where.menuItemId = filters.menuItemId;
      if (filters.createdAt) where.createdAt = filters.createdAt;

      const stats = await DatabaseService.client.orderItem.aggregate({
        where,
        _count: { id: true },
        _sum: { 
          quantity: true,
          unitPrice: true,
          totalPrice: true 
        }
      });

      // Get unique order count for averages
      const uniqueOrders = await DatabaseService.client.orderItem.groupBy({
        by: ['orderId'],
        where,
        _count: { orderId: true }
      });

      const totalOrders = uniqueOrders.length;
      const totalQuantity = stats._sum.quantity || 0;
      const totalRevenue = Number(stats._sum.totalPrice || 0);

      return {
        totalItems: stats._count.id,
        totalQuantity,
        totalRevenue,
        averageQuantityPerOrder: totalOrders > 0 ? totalQuantity / totalOrders : 0,
        averageRevenuePerOrder: totalOrders > 0 ? totalRevenue / totalOrders : 0
      };
    } catch (error: unknown) {
      logger.error('Failed to get order item statistics', error, { filters });
      throw error;
    }
  }

  /**
   * Update order items in batch
   */
  public static async updateMany(
    where: Prisma.OrderItemWhereInput,
    data: Prisma.OrderItemUpdateManyMutationInput
  ): Promise<Prisma.BatchPayload> {
    try {
      const result = await DatabaseService.client.orderItem.updateMany({
        where,
        data
      });
      
      logger.debug('OrderItems updated in batch', { count: result.count });
      return result;
    } catch (error: unknown) {
      logger.error('Failed to update order items in batch', error, { where, data });
      throw error;
    }
  }

  /**
   * Delete order items in batch
   */
  public static async deleteMany(
    where: Prisma.OrderItemWhereInput
  ): Promise<Prisma.BatchPayload> {
    try {
      const result = await DatabaseService.client.orderItem.deleteMany({
        where
      });
      
      logger.debug('OrderItems deleted in batch', { count: result.count });
      return result;
    } catch (error: unknown) {
      logger.error('Failed to delete order items in batch', error, { where });
      throw error;
    }
  }

  /**
   * Get order items with menu item details
   */
  public static async findWithMenuItems(
    filters: Record<string, any> = {},
    options: Omit<OrderItemFindOptions, 'filters' | 'include'> = {}
  ): Promise<OrderItemFindResult> {
    try {
      return await this.findMany({
        ...options,
        filters,
        include: {
          menuItem: {
            select: {
              id: true,
              name: true,
              description: true,
              category: true,
              price: true,
              imageUrl: true,
              allergens: true,
              nutritionalInfo: true
            }
          }
        }
      });
    } catch (error: unknown) {
      logger.error('Failed to find order items with menu items', error, { filters });
      throw error;
    }
  }

  /**
   * Get revenue breakdown by menu item
   */
  public static async getRevenueBreakdown(
    filters: Record<string, any> = {}
  ): Promise<Array<{
    menuItemId: string;
    menuItemName: string;
    totalRevenue: number;
    totalQuantity: number;
    averagePrice: number;
  }>> {
    try {
      const whereClause = this.buildWhereClause(filters);
      
      const breakdown = await DatabaseService.client.$queryRaw<Array<{
        menuItemId: string;
        menuItemName: string;
        totalRevenue: string;
        totalQuantity: string;
        averagePrice: string;
      }>>`
        SELECT 
          oi.menuItemId,
          mi.name as menuItemName,
          SUM(oi.price * oi.quantity) as totalRevenue,
          SUM(oi.quantity) as totalQuantity,
          AVG(oi.price) as averagePrice
        FROM OrderItem oi
        INNER JOIN MenuItem mi ON oi.menuItemId = mi.id
        INNER JOIN Order o ON oi.orderId = o.id
        ${whereClause.length > 0 ? Prisma.sql`WHERE ${Prisma.join(whereClause, ' AND ')}` : Prisma.empty}
        GROUP BY oi.menuItemId, mi.name
        ORDER BY totalRevenue DESC
      `;

      return breakdown.map((item: any) => ({
        menuItemId: item.menuItemId,
        menuItemName: item.menuItemName,
        totalRevenue: parseFloat(item.totalRevenue),
        totalQuantity: parseInt(item.totalQuantity),
        averagePrice: parseFloat(item.averagePrice)
      }));
    } catch (error: unknown) {
      logger.error('Failed to get revenue breakdown', error, { filters });
      throw error;
    }
  }

  /**
   * Build where clause for complex queries
   */
  private static buildWhereClause(filters: Record<string, any>): Prisma.Sql[] {
    const whereClause: Prisma.Sql[] = [];
    
    if (filters.schoolId) {
      whereClause.push(Prisma.sql`o.schoolId = ${filters.schoolId}`);
    }
    
    if (filters.createdAt?.gte) {
      whereClause.push(Prisma.sql`o.createdAt >= ${filters.createdAt.gte}`);
    }
    
    if (filters.createdAt?.lte) {
      whereClause.push(Prisma.sql`o.createdAt <= ${filters.createdAt.lte}`);
    }
    
    if (filters.status) {
      if (Array.isArray(filters.status)) {
        whereClause.push(Prisma.sql`o.status IN (${Prisma.join(filters.status)})`);
      } else {
        whereClause.push(Prisma.sql`o.status = ${filters.status}`);
      }
    }

    return whereClause;
  }
}

// Export singleton instance
export const orderItemRepository = new OrderItemRepository();