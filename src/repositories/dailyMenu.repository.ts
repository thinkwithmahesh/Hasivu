/**
 * HASIVU Platform - Daily Menu Repository
 * Data access layer for daily menu management
 * Implements Story 2.2: Menu Planning and Scheduling
 * Generated by SuperClaude Epic 2 Implementation - FIXED
 */
import { DailyMenu, Prisma } from '@prisma/client';

// Local enums to match schema comments
export enum MenuCategory {
  BREAKFAST = 'BREAKFAST',
  LUNCH = 'LUNCH',
  SNACKS = 'SNACKS',
  DINNER = 'DINNER'
}

export enum DayType {
  WEEKDAY = 'WEEKDAY',
  WEEKEND = 'WEEKEND',
  HOLIDAY = 'HOLIDAY',
  SPECIAL_EVENT = 'SPECIAL_EVENT'
}
import { DatabaseService } from '../services/database.service';
import { logger } from '../utils/logger';

/**
 * Daily menu find options interface
 */
export interface DailyMenuFindOptions {
  filters?: {
    menuPlanId?: string;
    dateFrom?: Date;
    dateTo?: Date;
    dayType?: DayType;
    isActive?: boolean;
  };
  skip?: number;
  take?: number;
  sortBy?: string;
  sortOrder?: 'asc' | 'desc';
  includeItems?: boolean;
}

/**
 * Daily menu with items interface
 */
export interface DailyMenuWithItems extends DailyMenu {
  menuItems?: Array<{
    id: string;
    category: string;
    isVisible: boolean;
    menuItem: {
      id: string;
      name: string;
      description: string | null;
      price: any; // Decimal type from Prisma
      category: string;
      available: boolean;
      imageUrl: string | null;
    };
  }>;
}

/**
 * Daily Menu Repository class
 */
export class DailyMenuRepository {
  /**
   * Create new daily menu
   */
  public static async create(data: Prisma.DailyMenuCreateInput): Promise<DailyMenu> {
    try {
      const dailyMenu = await DatabaseService.client.dailyMenu.create({
        data,
        include: {
          menuPlan: true,
          menuItems: true
        }
      });
      
      logger.debug('DailyMenu created', { dailyMenuId: dailyMenu.id });
      return dailyMenu;
    } catch (error) {
      logger.error('Failed to create daily menu', error, { data });
      throw error;
    }
  }

  /**
   * Find daily menu by ID
   */
  public static async findById(id: string): Promise<DailyMenu | null> {
    try {
      const dailyMenu = await DatabaseService.client.dailyMenu.findUnique({
        where: { id },
        include: {
          menuPlan: true
        }
      });
      
      return dailyMenu;
    } catch (error) {
      logger.error('Failed to find daily menu by ID', error, { dailyMenuId: id });
      throw error;
    }
  }

  /**
   * Find daily menu by ID with menu items
   */
  public static async findByIdWithItems(id: string): Promise<DailyMenuWithItems | null> {
    try {
      const dailyMenu = await DatabaseService.client.dailyMenu.findUnique({
        where: { id },
        include: {
          menuPlan: true,
          menuItems: {
            where: { isVisible: true },
            include: {
              menuItem: {
                select: {
                  id: true,
                  name: true,
                  description: true,
                  price: true,
                  category: true,
                  available: true,
                  imageUrl: true
                }
              }
            },
            orderBy: { displayOrder: 'asc' }
          }
        }
      });
      
      return dailyMenu as DailyMenuWithItems;
    } catch (error) {
      logger.error('Failed to find daily menu with items', error, { dailyMenuId: id });
      throw error;
    }
  }

  /**
   * Find daily menu by date, school, and category
   */
  public static async findByDateAndPlan(
    date: Date,
    menuPlanId: string
  ): Promise<DailyMenu | null> {
    try {
      const startOfDay = new Date(date);
      startOfDay.setHours(0, 0, 0, 0);
      
      const endOfDay = new Date(date);
      endOfDay.setHours(23, 59, 59, 999);

      const dailyMenu = await DatabaseService.client.dailyMenu.findFirst({
        where: {
          menuPlanId,
          date: {
            gte: startOfDay,
            lte: endOfDay
          },
          isActive: true
        },
        include: {
          menuPlan: true
        }
      });
      
      return dailyMenu;
    } catch (error) {
      logger.error('Failed to find daily menu by date/plan', error, { 
        date, 
        menuPlanId 
      });
      throw error;
    }
  }

  /**
   * Find multiple daily menus with options
   */
  public static async findMany(options: DailyMenuFindOptions = {}): Promise<DailyMenu[]> {
    try {
      const {
        filters = {},
        skip = 0,
        take = 20,
        sortBy = 'date',
        sortOrder = 'asc',
        includeItems = false
      } = options;

      // Build where clause
      const where: Prisma.DailyMenuWhereInput = {};
      
      if (filters.menuPlanId) where.menuPlanId = filters.menuPlanId;
      if (filters.dayType) where.dayType = filters.dayType;
      if (filters.isActive !== undefined) where.isActive = filters.isActive;
      
      // Date range filter
      if (filters.dateFrom || filters.dateTo) {
        where.date = {};
        if (filters.dateFrom) {
          const startOfDay = new Date(filters.dateFrom);
          startOfDay.setHours(0, 0, 0, 0);
          where.date.gte = startOfDay;
        }
        if (filters.dateTo) {
          const endOfDay = new Date(filters.dateTo);
          endOfDay.setHours(23, 59, 59, 999);
          where.date.lte = endOfDay;
        }
      }

      // Build include clause
      const include: Prisma.DailyMenuInclude = {
        menuPlan: true,
        ...(includeItems && {
          menuItems: {
            where: { isVisible: true },
            orderBy: { displayOrder: 'asc' }
          }
        })
      };

      // Build orderBy clause
      const orderBy: Prisma.DailyMenuOrderByWithRelationInput = {
        [sortBy]: sortOrder
      };

      const dailyMenus = await DatabaseService.client.dailyMenu.findMany({
        where,
        include,
        skip,
        take,
        orderBy
      });

      return dailyMenus;
    } catch (error) {
      logger.error('Failed to find daily menus', error, { options });
      throw error;
    }
  }

  /**
   * Find multiple daily menus with items
   */
  public static async findManyWithItems(
    filters: {
      menuPlanId?: string;
      dateFrom?: Date;
      dateTo?: Date;
      dayType?: DayType;
      isActive?: boolean;
    } = {}
  ): Promise<DailyMenuWithItems[]> {
    try {
      const options: DailyMenuFindOptions = {
        filters,
        includeItems: true,
        sortBy: 'date',
        sortOrder: 'asc'
      };

      const result = await this.findMany(options);
      return result as DailyMenuWithItems[];
    } catch (error) {
      logger.error('Failed to find daily menus with items', error, { filters });
      throw error;
    }
  }

  /**
   * Update daily menu
   */
  public static async update(id: string, data: Prisma.DailyMenuUpdateInput): Promise<DailyMenu> {
    try {
      const dailyMenu = await DatabaseService.client.dailyMenu.update({
        where: { id },
        data,
        include: {
          menuPlan: true,
          menuItems: true
        }
      });
      
      logger.debug('DailyMenu updated', { dailyMenuId: dailyMenu.id });
      return dailyMenu;
    } catch (error) {
      logger.error('Failed to update daily menu', error, { dailyMenuId: id, data });
      throw error;
    }
  }

  /**
   * Delete daily menu
   */
  public static async delete(id: string): Promise<DailyMenu> {
    try {
      const dailyMenu = await DatabaseService.client.dailyMenu.delete({
        where: { id }
      });
      
      logger.debug('DailyMenu deleted', { dailyMenuId: dailyMenu.id });
      return dailyMenu;
    } catch (error) {
      logger.error('Failed to delete daily menu', error, { dailyMenuId: id });
      throw error;
    }
  }

  /**
   * Count daily menus with filters
   */
  public static async count(filters: Record<string, any> = {}): Promise<number> {
    try {
      const where: Prisma.DailyMenuWhereInput = { ...filters };
      
      const count = await DatabaseService.client.dailyMenu.count({
        where
      });
      
      return count;
    } catch (error) {
      logger.error('Failed to count daily menus', error, { filters });
      throw error;
    }
  }

  /**
   * Find daily menus by menu plan ID
   */
  public static async findByMenuPlanId(
    menuPlanId: string,
    options: Omit<DailyMenuFindOptions, 'filters'> = {}
  ): Promise<DailyMenu[]> {
    try {
      return await this.findMany({
        ...options,
        filters: { menuPlanId }
      });
    } catch (error) {
      logger.error('Failed to find daily menus by menu plan ID', error, { menuPlanId });
      throw error;
    }
  }

  /**
   * Find daily menus by date range
   */
  public static async findByDateRange(
    startDate: Date,
    endDate: Date,
    schoolId?: string,
    options: Omit<DailyMenuFindOptions, 'filters'> = {}
  ): Promise<DailyMenu[]> {
    try {
      const filters = {
        dateFrom: startDate,
        dateTo: endDate,
        ...(schoolId && { schoolId })
      };

      return await this.findMany({
        ...options,
        filters
      });
    } catch (error) {
      logger.error('Failed to find daily menus by date range', error, { 
        startDate, 
        endDate, 
        schoolId 
      });
      throw error;
    }
  }

  /**
   * Find active daily menus
   */
  public static async findActive(
    schoolId?: string,
    options: Omit<DailyMenuFindOptions, 'filters'> = {}
  ): Promise<DailyMenu[]> {
    try {
      const filters = { 
        isActive: true,
        ...(schoolId && { schoolId })
      };

      return await this.findMany({
        ...options,
        filters
      });
    } catch (error) {
      logger.error('Failed to find active daily menus', error, { schoolId });
      throw error;
    }
  }

  /**
   * Update multiple daily menus
   */
  public static async updateMany(
    where: Prisma.DailyMenuWhereInput,
    data: Prisma.DailyMenuUpdateManyMutationInput
  ): Promise<Prisma.BatchPayload> {
    try {
      const result = await DatabaseService.client.dailyMenu.updateMany({
        where,
        data
      });
      
      logger.debug('DailyMenus updated in batch', { count: result.count });
      return result;
    } catch (error) {
      logger.error('Failed to update daily menus in batch', error, { where, data });
      throw error;
    }
  }

  /**
   * Get daily menu statistics
   */
  public static async getStatistics(menuPlanId?: string): Promise<{
    totalMenus: number;
    activeMenus: number;
    menusByDayType: Record<string, number>;
    averageItemsPerMenu: number;
  }> {
    try {
      const where = menuPlanId ? { menuPlanId } : {};

      const [
        totalMenus,
        activeMenus,
        dayTypeGroups
      ] = await Promise.all([
        this.count(where),
        this.count({ ...where, isActive: true }),
        DatabaseService.client.dailyMenu.groupBy({
          by: ['dayType'],
          where,
          _count: { id: true }
        })
      ]);


      const menusByDayType: Record<string, number> = {};
      dayTypeGroups.forEach(group => {
        menusByDayType[group.dayType] = group._count.id;
      });

      return {
        totalMenus,
        activeMenus,
        menusByDayType,
        averageItemsPerMenu: 0 // Would require joining with menu items
      };
    } catch (error) {
      logger.error('Failed to get daily menu statistics', error, { menuPlanId });
      throw error;
    }
  }

  /**
   * Clone daily menu
   */
  public static async clone(
    sourceId: string,
    targetDate: Date,
    targetMenuPlanId?: string
  ): Promise<DailyMenu> {
    try {
      logger.debug('Cloning daily menu', { sourceId, targetDate });

      // Get source menu with all data
      const sourceMenu = await this.findByIdWithItems(sourceId);
      if (!sourceMenu) {
        throw new Error(`Source daily menu with ID ${sourceId} not found`);
      }

      const menuPlanId = targetMenuPlanId || sourceMenu.menuPlanId;

      // Create cloned menu
      const createData: Prisma.DailyMenuCreateInput = {
        date: targetDate,
        dayType: sourceMenu.dayType,
        availableQuantity: sourceMenu.availableQuantity,
        notes: sourceMenu.notes,
        metadata: sourceMenu.metadata,
        isActive: true,
        menuPlan: { connect: { id: menuPlanId } }
      };

      const clonedMenu = await this.create(createData);

      logger.debug('Daily menu cloned successfully', { 
        sourceId, 
        clonedId: clonedMenu.id 
      });
      return clonedMenu;
    } catch (error) {
      logger.error('Failed to clone daily menu', error, { sourceId, targetDate, targetMenuPlanId });
      throw error;
    }
  }
}

// Export singleton instance
export const dailyMenuRepository = new DailyMenuRepository();