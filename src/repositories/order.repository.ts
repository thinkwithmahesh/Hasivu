/**
 * HASIVU Platform - Order Repository
 * Data access layer for order management
 * Implements Epic 3: Parent Ordering System - Data Layer
 * Generated by SuperClaude Wave 3: Epic 3 Implementation - REPOSITORY
 */
import { Order, Prisma } from '@prisma/client';

// Local enum to match schema
export enum OrderStatus {
  PENDING = 'pending',
  CONFIRMED = 'confirmed',
  PREPARING = 'preparing',
  READY = 'ready',
  OUT_FOR_DELIVERY = 'out_for_delivery',
  DELIVERED = 'delivered',
  CANCELLED = 'cancelled'
}
import { DatabaseService } from '../services/database.service';
import { logger } from '../utils/logger';

/**
 * Order find options interface
 */
export interface OrderFindOptions {
  filters?: Record<string, any>;
  skip?: number;
  take?: number;
  sortBy?: string;
  sortOrder?: 'asc' | 'desc';
  include?: Prisma.OrderInclude;
}

/**
 * Order find result interface
 */
export interface OrderFindResult {
  items: Order[];
  total: number;
}

/**
 * Analytics result interface
 */
export interface AnalyticsResult {
  totalOrders: number;
  totalRevenue: number;
  deliveredOrders: number;
  cancelledOrders: number;
  ordersByStatus: Record<OrderStatus, number>;
  revenueByDay: Array<{ date: string; revenue: number; orders: number }>;
}

/**
 * Order Repository class
 */
export class OrderRepository {
  /**
   * Create new order
   */
  public static async create(data: Prisma.OrderCreateInput): Promise<Order> {
    try {
      const order = await DatabaseService.client.order.create({
        data
      });
      
      logger.debug('Order created', { orderId: order.id });
      return order;
    } catch (error) {
      logger.error('Failed to create order', error, { data });
      throw error;
    }
  }

  /**
   * Find order by ID
   */
  public static async findById(id: string): Promise<Order | null> {
    try {
      const order = await DatabaseService.client.order.findUnique({
        where: { id }
      });
      
      return order;
    } catch (error) {
      logger.error('Failed to find order by ID', error, { orderId: id });
      throw error;
    }
  }

  /**
   * Find order by ID with includes
   */
  public static async findByIdWithIncludes(
    id: string, 
    include: Prisma.OrderInclude
  ): Promise<Order | null> {
    try {
      const order = await DatabaseService.client.order.findUnique({
        where: { id },
        include
      });
      
      return order;
    } catch (error) {
      logger.error('Failed to find order by ID with includes', error, { orderId: id });
      throw error;
    }
  }

  /**
   * Find multiple orders with options
   */
  public static async findMany(options: OrderFindOptions = {}): Promise<OrderFindResult> {
    try {
      const {
        filters = {},
        skip = 0,
        take = 20,
        sortBy = 'createdAt',
        sortOrder = 'desc',
        include
      } = options;

      // Build where clause
      const where: Prisma.OrderWhereInput = { ...filters };

      // Build orderBy clause
      const orderBy: Prisma.OrderOrderByWithRelationInput = {
        [sortBy]: sortOrder
      };

      const [items, total] = await Promise.all([
        DatabaseService.client.order.findMany({
          where,
          skip,
          take,
          orderBy,
          ...(include && { include })
        }),
        DatabaseService.client.order.count({ where })
      ]);

      return { items, total };
    } catch (error) {
      logger.error('Failed to find orders', error, { options });
      throw error;
    }
  }

  /**
   * Update order
   */
  public static async update(id: string, data: Prisma.OrderUpdateInput): Promise<Order> {
    try {
      const order = await DatabaseService.client.order.update({
        where: { id },
        data
      });
      
      logger.debug('Order updated', { orderId: order.id });
      return order;
    } catch (error) {
      logger.error('Failed to update order', error, { orderId: id, data });
      throw error;
    }
  }

  /**
   * Delete order
   */
  public static async delete(id: string): Promise<Order> {
    try {
      const order = await DatabaseService.client.order.delete({
        where: { id }
      });
      
      logger.debug('Order deleted', { orderId: order.id });
      return order;
    } catch (error) {
      logger.error('Failed to delete order', error, { orderId: id });
      throw error;
    }
  }

  /**
   * Count orders with filters
   */
  public static async count(filters: Record<string, any> = {}): Promise<number> {
    try {
      const count = await DatabaseService.client.order.count({
        where: filters
      });
      
      return count;
    } catch (error) {
      logger.error('Failed to count orders', error, { filters });
      throw error;
    }
  }

  /**
   * Get orders analytics
   */
  public static async getAnalytics(
    filters: Record<string, any> = {},
    groupBy?: 'day' | 'week' | 'month'
  ): Promise<AnalyticsResult> {
    try {
      // Get basic counts and sums
      const [orderStats, statusGroups] = await Promise.all([
        DatabaseService.client.order.aggregate({
          where: filters,
          _count: { id: true },
          _sum: { totalAmount: true }
        }),
        DatabaseService.client.order.groupBy({
          by: ['status'],
          where: filters,
          _count: { id: true }
        })
      ]);

      // Build status counts
      const ordersByStatus: Record<OrderStatus, number> = {
        [OrderStatus.PENDING]: 0,
        [OrderStatus.CONFIRMED]: 0,
        [OrderStatus.PREPARING]: 0,
        [OrderStatus.READY]: 0,
        [OrderStatus.OUT_FOR_DELIVERY]: 0,
        [OrderStatus.DELIVERED]: 0,
        [OrderStatus.CANCELLED]: 0
      };

      statusGroups.forEach(group => {
        ordersByStatus[group.status] = group._count.id;
      });

      // Get revenue by day if requested
      let revenueByDay: Array<{ date: string; revenue: number; orders: number }> = [];
      
      if (groupBy === 'day') {
        const dailyStats = await DatabaseService.client.$queryRaw<Array<{
          date: string;
          revenue: number;
          orders: number;
        }>>`
          SELECT 
            DATE(createdAt) as date,
            SUM(totalAmount) as revenue,
            COUNT(*) as orders
          FROM Order 
          WHERE createdAt >= ${filters.createdAt?.gte} 
            AND createdAt <= ${filters.createdAt?.lte}
            ${filters.schoolId ? Prisma.sql`AND schoolId = ${filters.schoolId}` : Prisma.empty}
          GROUP BY DATE(createdAt)
          ORDER BY date ASC
        `;
        
        revenueByDay = dailyStats.map(stat => ({
          date: stat.date,
          revenue: Number(stat.revenue),
          orders: Number(stat.orders)
        }));
      }

      return {
        totalOrders: orderStats._count.id,
        totalRevenue: Number(orderStats._sum.totalAmount || 0),
        deliveredOrders: ordersByStatus[OrderStatus.DELIVERED],
        cancelledOrders: ordersByStatus[OrderStatus.CANCELLED],
        ordersByStatus,
        revenueByDay
      };
    } catch (error) {
      logger.error('Failed to get order analytics', error, { filters });
      throw error;
    }
  }

  /**
   * Find orders by student ID
   */
  public static async findByStudentId(
    studentId: string,
    options: Omit<OrderFindOptions, 'filters'> & { status?: OrderStatus } = {}
  ): Promise<OrderFindResult> {
    try {
      const filters: Record<string, any> = { studentId };
      if (options.status) {
        filters.status = options.status;
      }

      return await this.findMany({
        ...options,
        filters
      });
    } catch (error) {
      logger.error('Failed to find orders by student ID', error, { studentId });
      throw error;
    }
  }

  /**
   * Find orders by parent ID
   */
  public static async findByParentId(
    parentId: string,
    options: Omit<OrderFindOptions, 'filters'> & { status?: OrderStatus } = {}
  ): Promise<OrderFindResult> {
    try {
      const filters: Record<string, any> = { parentId };
      if (options.status) {
        filters.status = options.status;
      }

      return await this.findMany({
        ...options,
        filters
      });
    } catch (error) {
      logger.error('Failed to find orders by parent ID', error, { parentId });
      throw error;
    }
  }

  /**
   * Find orders by school ID
   */
  public static async findBySchoolId(
    schoolId: string,
    options: Omit<OrderFindOptions, 'filters'> & { 
      status?: OrderStatus;
      dateFrom?: Date;
      dateTo?: Date;
    } = {}
  ): Promise<OrderFindResult> {
    try {
      const filters: Record<string, any> = { schoolId };
      
      if (options.status) {
        filters.status = options.status;
      }
      
      if (options.dateFrom || options.dateTo) {
        filters.createdAt = {};
        if (options.dateFrom) filters.createdAt.gte = options.dateFrom;
        if (options.dateTo) filters.createdAt.lte = options.dateTo;
      }

      return await this.findMany({
        ...options,
        filters
      });
    } catch (error) {
      logger.error('Failed to find orders by school ID', error, { schoolId });
      throw error;
    }
  }

  /**
   * Find active orders (not delivered or cancelled)
   */
  public static async findActiveOrders(
    filters: Record<string, any> = {},
    options: Omit<OrderFindOptions, 'filters'> = {}
  ): Promise<OrderFindResult> {
    try {
      const activeFilters = {
        ...filters,
        status: {
          in: ['PENDING', 'CONFIRMED', 'PREPARING', 'READY', 'OUT_FOR_DELIVERY']
        }
      };

      return await this.findMany({
        ...options,
        filters: activeFilters
      });
    } catch (error) {
      logger.error('Failed to find active orders', error, { filters });
      throw error;
    }
  }

  /**
   * Find orders for delivery date
   */
  public static async findByDeliveryDate(
    deliveryDate: Date,
    options: Omit<OrderFindOptions, 'filters'> & { schoolId?: string } = {}
  ): Promise<OrderFindResult> {
    try {
      const startOfDay = new Date(deliveryDate);
      startOfDay.setHours(0, 0, 0, 0);
      
      const endOfDay = new Date(deliveryDate);
      endOfDay.setHours(23, 59, 59, 999);

      const filters: Record<string, any> = {
        deliveryDate: {
          gte: startOfDay,
          lte: endOfDay
        }
      };

      if (options.schoolId) {
        filters.schoolId = options.schoolId;
      }

      return await this.findMany({
        ...options,
        filters
      });
    } catch (error) {
      logger.error('Failed to find orders by delivery date', error, { deliveryDate });
      throw error;
    }
  }

  /**
   * Update orders in batch
   */
  public static async updateMany(
    where: Prisma.OrderWhereInput,
    data: Prisma.OrderUpdateManyMutationInput
  ): Promise<Prisma.BatchPayload> {
    try {
      const result = await DatabaseService.client.order.updateMany({
        where,
        data
      });
      
      logger.debug('Orders updated in batch', { count: result.count });
      return result;
    } catch (error) {
      logger.error('Failed to update orders in batch', error, { where, data });
      throw error;
    }
  }

  /**
   * Get order statistics for dashboard
   */
  public static async getDashboardStats(
    schoolId?: string,
    dateRange?: { from: Date; to: Date }
  ): Promise<{
    todayOrders: number;
    pendingOrders: number;
    completedOrders: number;
    totalRevenue: number;
    averageOrderValue: number;
  }> {
    try {
      const today = new Date();
      today.setHours(0, 0, 0, 0);
      const tomorrow = new Date(today);
      tomorrow.setDate(tomorrow.getDate() + 1);

      const baseWhere: Prisma.OrderWhereInput = {};
      if (schoolId) baseWhere.schoolId = schoolId;

      const [todayStats, pendingCount, completedStats] = await Promise.all([
        // Today's orders
        DatabaseService.client.order.aggregate({
          where: {
            ...baseWhere,
            createdAt: {
              gte: today,
              lt: tomorrow
            }
          },
          _count: { id: true }
        }),
        
        // Pending orders
        DatabaseService.client.order.count({
          where: {
            ...baseWhere,
            status: {
              in: ['PENDING', 'CONFIRMED', 'PREPARING', 'READY', 'OUT_FOR_DELIVERY']
            }
          }
        }),
        
        // Completed orders (for revenue calculation)
        DatabaseService.client.order.aggregate({
          where: {
            ...baseWhere,
            status: 'DELIVERED',
            ...(dateRange && {
              createdAt: {
                gte: dateRange.from,
                lte: dateRange.to
              }
            })
          },
          _count: { id: true },
          _sum: { totalAmount: true }
        })
      ]);

      const totalRevenue = Number(completedStats._sum.totalAmount || 0);
      const averageOrderValue = completedStats._count.id > 0 ? 
        totalRevenue / completedStats._count.id : 0;

      return {
        todayOrders: todayStats._count.id,
        pendingOrders: pendingCount,
        completedOrders: completedStats._count.id,
        totalRevenue,
        averageOrderValue
      };
    } catch (error) {
      logger.error('Failed to get dashboard stats', error, { schoolId, dateRange });
      throw error;
    }
  }
}

// Export singleton instance
export const orderRepository = new OrderRepository();