/**
 * HASIVU Platform - Menu Item Repository
 * Data access layer for menu item management
 * Implements Epic 2: Menu Management System - Data Layer
 * Generated by SuperClaude Wave 3: Epic 3 Implementation - REPOSITORY
 */
import { MenuItem, Prisma } from '@prisma/client';

// Local enum to match schema
export enum MenuCategory {
  BREAKFAST = 'BREAKFAST',
  LUNCH = 'LUNCH',
  SNACKS = 'SNACKS',
  DINNER = 'DINNER'
}
import { DatabaseService } from '../services/database.service';
import { logger } from '../utils/logger';

/**
 * MenuItem find options interface
 */
export interface MenuItemFindOptions {
  filters?: Record<string, any>;
  ids?: string[];
  skip?: number;
  take?: number;
  sortBy?: string;
  sortOrder?: 'asc' | 'desc';
  include?: Prisma.MenuItemInclude;
}

/**
 * MenuItem find result interface
 */
export interface MenuItemFindResult {
  items: MenuItem[];
  total: number;
}

/**
 * Menu item search options
 */
export interface MenuItemSearchOptions {
  query?: string;
  category?: MenuCategory;
  schoolId?: string;
  available?: boolean;
  featured?: boolean;
  priceMin?: number;
  priceMax?: number;
  allergens?: string[];
  tags?: string[];
  page?: number;
  limit?: number;
  sortBy?: 'name' | 'price' | 'createdAt' | 'updatedAt';
  sortOrder?: 'asc' | 'desc';
}

/**
 * MenuItem Repository class
 */
export class MenuItemRepository {
  /**
   * Create new menu item
   */
  public static async create(data: Prisma.MenuItemCreateInput): Promise<MenuItem> {
    try {
      const menuItem = await DatabaseService.client.menuItem.create({
        data
      });
      
      logger.debug('MenuItem created', { menuItemId: menuItem.id });
      return menuItem;
    } catch (error) {
      logger.error('Failed to create menu item', error, { data });
      throw error;
    }
  }

  /**
   * Find menu item by ID
   */
  public static async findById(id: string, includeSchool: boolean = false): Promise<MenuItem | null> {
    try {
      const menuItem = await DatabaseService.client.menuItem.findUnique({
        where: { id },
        ...(includeSchool && {
          include: {
            school: true
          }
        })
      });
      
      return menuItem;
    } catch (error) {
      logger.error('Failed to find menu item by ID', error, { menuItemId: id });
      throw error;
    }
  }

  /**
   * Find menu item by name and school
   */
  public static async findByNameAndSchool(
    name: string, 
    schoolId: string
  ): Promise<MenuItem | null> {
    try {
      const menuItem = await DatabaseService.client.menuItem.findFirst({
        where: {
          name: {
            equals: name,
            mode: 'insensitive'
          },
          schoolId
        }
      });
      
      return menuItem;
    } catch (error) {
      logger.error('Failed to find menu item by name and school', error, { name, schoolId });
      throw error;
    }
  }

  /**
   * Check if menu item name exists in a school
   */
  public static async nameExists(name: string, schoolId: string): Promise<boolean> {
    try {
      const menuItem = await MenuItemRepository.findByNameAndSchool(name, schoolId);
      return menuItem !== null;
    } catch (error) {
      logger.error('Failed to check menu item name existence', error, { name, schoolId });
      throw error;
    }
  }

  /**
   * Find menu item by ID with includes
   */
  public static async findByIdWithIncludes(
    id: string, 
    include: Prisma.MenuItemInclude
  ): Promise<MenuItem | null> {
    try {
      const menuItem = await DatabaseService.client.menuItem.findUnique({
        where: { id },
        include
      });
      
      return menuItem;
    } catch (error) {
      logger.error('Failed to find menu item by ID with includes', error, { menuItemId: id });
      throw error;
    }
  }

  /**
   * Find multiple menu items with options
   */
  public static async findMany(options: MenuItemFindOptions = {}): Promise<MenuItemFindResult> {
    try {
      const {
        filters = {},
        ids,
        skip = 0,
        take = 20,
        sortBy = 'createdAt',
        sortOrder = 'desc',
        include
      } = options;

      // Build where clause
      let where: Prisma.MenuItemWhereInput = { ...filters };
      
      // Add IDs filter if provided
      if (ids && ids.length > 0) {
        where = {
          ...where,
          id: { in: ids }
        };
      }

      // Build orderBy clause
      const orderBy: Prisma.MenuItemOrderByWithRelationInput = {
        [sortBy]: sortOrder
      };

      const [items, total] = await Promise.all([
        DatabaseService.client.menuItem.findMany({
          where,
          skip,
          take,
          orderBy,
          ...(include && { include })
        }),
        DatabaseService.client.menuItem.count({ where })
      ]);

      return { items, total };
    } catch (error) {
      logger.error('Failed to find menu items', error, { options });
      throw error;
    }
  }

  /**
   * Search menu items with text query and filters
   */
  public static async search(
    searchTerm: string,
    filters: Record<string, any> = {},
    pagination: { page?: number; limit?: number } = {}
  ): Promise<MenuItemFindResult> {
    try {
      const page = pagination.page || 1;
      const limit = pagination.limit || 20;
      const skip = (page - 1) * limit;

      // Build where clause with search
      const where: Prisma.MenuItemWhereInput = {
        ...filters,
        OR: [
          { name: { contains: searchTerm, mode: 'insensitive' } },
          { description: { contains: searchTerm, mode: 'insensitive' } }
        ]
      };

      const [items, total] = await Promise.all([
        DatabaseService.client.menuItem.findMany({
          where,
          skip,
          take: limit,
          orderBy: { name: 'asc' },
          include: {
            school: true
          }
        }),
        DatabaseService.client.menuItem.count({ where })
      ]);

      return { items, total };
    } catch (error) {
      logger.error('Failed to search menu items', error, { searchTerm, filters });
      throw error;
    }
  }

  /**
   * Search menu items with advanced filtering (legacy)
   */
  public static async searchAdvanced(options: MenuItemSearchOptions = {}): Promise<MenuItemFindResult> {
    try {
      const {
        query,
        category,
        schoolId,
        available,
        featured,
        priceMin,
        priceMax,
        allergens,
        tags,
        page = 1,
        limit = 20,
        sortBy = 'name',
        sortOrder = 'asc'
      } = options;

      const skip = (page - 1) * limit;

      // Build where clause
      const where: Prisma.MenuItemWhereInput = {
        ...(schoolId && { schoolId }),
        ...(available !== undefined && { available }),
        ...(featured !== undefined && { featured }),
        ...(category && { category }),
        ...(priceMin !== undefined && { price: { gte: priceMin } }),
        ...(priceMax !== undefined && { price: { lte: priceMax } })
      };

      // Add price range filter
      if (priceMin !== undefined && priceMax !== undefined) {
        where.price = { gte: priceMin, lte: priceMax };
      } else if (priceMin !== undefined) {
        where.price = { gte: priceMin };
      } else if (priceMax !== undefined) {
        where.price = { lte: priceMax };
      }

      // Add text search
      if (query) {
        where.OR = [
          { name: { contains: query, mode: 'insensitive' } },
          { description: { contains: query, mode: 'insensitive' } }
        ];
      }

      // Add allergens filter
      if (allergens && allergens.length > 0) {
        where.allergens = {
          not: {
            in: allergens
          }
        };
      }

      // Add tags filter (tags is a JSON string field)
      if (tags && tags.length > 0) {
        where.OR = tags.map(tag => ({
          tags: {
            contains: tag
          }
        }));
      }

      const orderBy: Prisma.MenuItemOrderByWithRelationInput = {
        [sortBy]: sortOrder
      };

      const [items, total] = await Promise.all([
        DatabaseService.client.menuItem.findMany({
          where,
          skip,
          take: limit,
          orderBy,
          include: {
            school: true
          }
        }),
        DatabaseService.client.menuItem.count({ where })
      ]);

      return { items, total };
    } catch (error) {
      logger.error('Failed to search menu items', error, { options });
      throw error;
    }
  }

  /**
   * Update menu item
   */
  public static async update(id: string, data: Prisma.MenuItemUpdateInput): Promise<MenuItem> {
    try {
      const menuItem = await DatabaseService.client.menuItem.update({
        where: { id },
        data
      });
      
      logger.debug('MenuItem updated', { menuItemId: menuItem.id });
      return menuItem;
    } catch (error) {
      logger.error('Failed to update menu item', error, { menuItemId: id, data });
      throw error;
    }
  }

  /**
   * Delete menu item
   */
  public static async delete(id: string): Promise<MenuItem> {
    try {
      const menuItem = await DatabaseService.client.menuItem.delete({
        where: { id }
      });
      
      logger.debug('MenuItem deleted', { menuItemId: menuItem.id });
      return menuItem;
    } catch (error) {
      logger.error('Failed to delete menu item', error, { menuItemId: id });
      throw error;
    }
  }

  /**
   * Count menu items with filters
   */
  public static async count(filters: Record<string, any> = {}): Promise<number> {
    try {
      const count = await DatabaseService.client.menuItem.count({
        where: filters
      });
      
      return count;
    } catch (error) {
      logger.error('Failed to count menu items', error, { filters });
      throw error;
    }
  }

  /**
   * Find menu items by school ID
   */
  public static async findBySchoolId(
    schoolId: string,
    options: Omit<MenuItemFindOptions, 'filters'> = {}
  ): Promise<MenuItemFindResult> {
    try {
      return await this.findMany({
        ...options,
        filters: { schoolId }
      });
    } catch (error) {
      logger.error('Failed to find menu items by school ID', error, { schoolId });
      throw error;
    }
  }

  /**
   * Find menu items by category
   */
  public static async findByCategory(
    category: MenuCategory,
    options: Omit<MenuItemFindOptions, 'filters'> = {}
  ): Promise<MenuItemFindResult> {
    try {
      return await this.findMany({
        ...options,
        filters: { category }
      });
    } catch (error) {
      logger.error('Failed to find menu items by category', error, { category });
      throw error;
    }
  }

  /**
   * Find available menu items
   */
  public static async findAvailable(
    schoolId?: string,
    options: Omit<MenuItemFindOptions, 'filters'> = {}
  ): Promise<MenuItemFindResult> {
    try {
      const filters = { available: true };
      if (schoolId) {
        (filters as any).schoolId = schoolId;
      }

      return await this.findMany({
        ...options,
        filters
      });
    } catch (error) {
      logger.error('Failed to find available menu items', error, { schoolId });
      throw error;
    }
  }

  /**
   * Find featured menu items
   */
  public static async findFeatured(
    schoolId?: string,
    options: Omit<MenuItemFindOptions, 'filters'> = {}
  ): Promise<MenuItemFindResult> {
    try {
      const filters = { featured: true };
      if (schoolId) {
        (filters as any).schoolId = schoolId;
      }

      return await this.findMany({
        ...options,
        filters
      });
    } catch (error) {
      logger.error('Failed to find featured menu items', error, { schoolId });
      throw error;
    }
  }

  /**
   * Update menu items in batch
   */
  public static async updateMany(
    where: Prisma.MenuItemWhereInput,
    data: Prisma.MenuItemUpdateManyMutationInput
  ): Promise<Prisma.BatchPayload> {
    try {
      const result = await DatabaseService.client.menuItem.updateMany({
        where,
        data
      });
      
      logger.debug('MenuItems updated in batch', { count: result.count });
      return result;
    } catch (error) {
      logger.error('Failed to update menu items in batch', error, { where, data });
      throw error;
    }
  }

  /**
   * Get menu item statistics
   */
  public static async getStatistics(schoolId?: string): Promise<{
    totalItems: number;
    availableItems: number;
    featuredItems: number;
    itemsByCategory: Record<string, number>;
    averagePrice: number;
  }> {
    try {
      const where = schoolId ? { schoolId } : {};

      const [
        totalItems,
        availableItems,
        featuredItems,
        categoryGroups,
        priceStats
      ] = await Promise.all([
        this.count(where),
        this.count({ ...where, available: true }),
        this.count({ ...where, featured: true }),
        DatabaseService.client.menuItem.groupBy({
          by: ['category'],
          where,
          _count: { id: true }
        }),
        DatabaseService.client.menuItem.aggregate({
          where,
          _avg: { price: true }
        })
      ]);

      const itemsByCategory: Record<string, number> = {};
      categoryGroups.forEach(group => {
        itemsByCategory[group.category] = group._count.id;
      });

      return {
        totalItems,
        availableItems,
        featuredItems,
        itemsByCategory,
        averagePrice: Number(priceStats._avg.price || 0)
      };
    } catch (error) {
      logger.error('Failed to get menu item statistics', error, { schoolId });
      throw error;
    }
  }

  /**
   * Find items by price range
   */
  public static async findByPriceRange(
    minPrice: number,
    maxPrice: number,
    schoolId?: string,
    options: Omit<MenuItemFindOptions, 'filters'> = {}
  ): Promise<MenuItemFindResult> {
    try {
      const filters: any = {
        price: {
          gte: minPrice,
          lte: maxPrice
        }
      };

      if (schoolId) {
        filters.schoolId = schoolId;
      }

      return await this.findMany({
        ...options,
        filters
      });
    } catch (error) {
      logger.error('Failed to find items by price range', error, { minPrice, maxPrice, schoolId });
      throw error;
    }
  }

  /**
   * Get popular menu items based on order frequency
   */
  public static async getPopularItems(
    schoolId?: string,
    limit: number = 10
  ): Promise<Array<MenuItem & { orderCount: number }>> {
    try {
      // This would require joining with order items table
      // For now, return featured items as a fallback
      const result = await this.findFeatured(schoolId, {
        take: limit,
        sortBy: 'createdAt',
        sortOrder: 'desc'
      });

      return result.items.map(item => ({
        ...item,
        orderCount: 0 // Would be calculated from actual orders
      }));
    } catch (error) {
      logger.error('Failed to get popular items', error, { schoolId, limit });
      throw error;
    }
  }

  /**
   * Batch update sort orders for multiple menu items
   */
  public static async batchUpdateSortOrders(
    updates: Array<{ id: string; sortOrder: number }>
  ): Promise<void> {
    try {
      logger.debug('Executing batch sort order updates', { count: updates.length });

      // Use transaction for atomic updates
      await DatabaseService.client.$transaction(async (tx) => {
        const updatePromises = updates.map(({ id, sortOrder }) =>
          tx.menuItem.update({
            where: { id },
            data: { sortOrder }
          })
        );

        await Promise.all(updatePromises);
      });

      logger.debug('Batch sort order updates completed', { count: updates.length });
    } catch (error) {
      logger.error('Failed to batch update sort orders', error, { updates });
      throw error;
    }
  }
}

// Export singleton instance
export const menuItemRepository = new MenuItemRepository();