/**
 * HASIVU Platform - PaymentOrder Repository
 * Data access layer for payment order management
 * Implements Epic 3: Parent Ordering System - Payment Data Layer
 * Generated by SuperClaude Wave 3: Epic 3 Implementation - REPOSITORY
 */
import { PaymentOrder, Prisma } from '@prisma/client';

// Local enum to match schema
export enum PaymentStatus {
  PENDING = 'pending',
  PAID = 'paid',
  FAILED = 'failed',
  REFUNDED = 'refunded'
}
import { DatabaseService } from '../services/database.service';
import { logger } from '../utils/logger';

/**
 * PaymentOrder find options interface
 */
export interface PaymentOrderFindOptions {
  filters?: Record<string, any>;
  skip?: number;
  take?: number;
  sortBy?: string;
  sortOrder?: 'asc' | 'desc';
  include?: Prisma.PaymentOrderInclude;
}

/**
 * PaymentOrder find result interface
 */
export interface PaymentOrderFindResult {
  items: PaymentOrder[];
  total: number;
}

/**
 * Payment statistics interface
 */
export interface PaymentStatistics {
  totalPayments: number;
  totalAmount: number;
  successfulPayments: number;
  failedPayments: number;
  pendingPayments: number;
  successRate: number;
  averageAmount: number;
  paymentsByMethod: Record<string, number>;
}

/**
 * PaymentOrder Repository class
 */
export class PaymentOrderRepository {
  /**
   * Create new payment order
   */
  public static async create(data: Prisma.PaymentOrderCreateInput): Promise<PaymentOrder> {
    try {
      const paymentOrder = await DatabaseService.client.paymentOrder.create({
        data
      });
      
      logger.debug('PaymentOrder created', { paymentOrderId: paymentOrder.id });
      return paymentOrder;
    } catch (error: unknown) {
      logger.error('Failed to create payment order', error, { data });
      throw error;
    }
  }

  /**
   * Find payment order by ID
   */
  public static async findById(id: string): Promise<PaymentOrder | null> {
    try {
      const paymentOrder = await DatabaseService.client.paymentOrder.findUnique({
        where: { id }
      });
      
      return paymentOrder;
    } catch (error: unknown) {
      logger.error('Failed to find payment order by ID', error, { paymentOrderId: id });
      throw error;
    }
  }

  /**
   * Find payment order by ID with includes
   */
  public static async findByIdWithIncludes(
    id: string, 
    include: Prisma.PaymentOrderInclude
  ): Promise<PaymentOrder | null> {
    try {
      const paymentOrder = await DatabaseService.client.paymentOrder.findUnique({
        where: { id },
        include
      });
      
      return paymentOrder;
    } catch (error: unknown) {
      logger.error('Failed to find payment order by ID with includes', error, { paymentOrderId: id });
      throw error;
    }
  }

  /**
   * Find payment order by order ID
   */
  public static async findByOrderId(orderId: string): Promise<PaymentOrder | null> {
    try {
      const paymentOrder = await DatabaseService.client.paymentOrder.findFirst({
        where: { orderId },
        orderBy: { createdAt: 'desc' } // Get the latest payment order for the order
      });
      
      return paymentOrder;
    } catch (error: unknown) {
      logger.error('Failed to find payment order by order ID', error, { orderId });
      throw error;
    }
  }

  /**
   * Find payment order by Razorpay order ID
   */
  public static async findByRazorpayOrderId(razorpayOrderId: string): Promise<PaymentOrder | null> {
    try {
      const paymentOrder = await DatabaseService.client.paymentOrder.findFirst({
        where: { razorpayOrderId }
      });
      
      return paymentOrder;
    } catch (error: unknown) {
      logger.error('Failed to find payment order by Razorpay order ID', error, { razorpayOrderId });
      throw error;
    }
  }

  /**
   * Find multiple payment orders with options
   */
  public static async findMany(options: PaymentOrderFindOptions = {}): Promise<PaymentOrderFindResult> {
    try {
      const {
        filters = {},
        skip = 0,
        take = 20,
        sortBy = 'createdAt',
        sortOrder = 'desc',
        include
      } = options;

      // Build where clause
      const where: Prisma.PaymentOrderWhereInput = { ...filters };

      // Build orderBy clause
      const orderBy: Prisma.PaymentOrderOrderByWithRelationInput = {
        [sortBy]: sortOrder
      };

      const [items, total] = await Promise.all([
        DatabaseService.client.paymentOrder.findMany({
          where,
          skip,
          take,
          orderBy,
          ...(include && { include })
        }),
        DatabaseService.client.paymentOrder.count({ where })
      ]);

      return { items, total };
    } catch (error: unknown) {
      logger.error('Failed to find payment orders', error, { options });
      throw error;
    }
  }

  /**
   * Update payment order
   */
  public static async update(id: string, data: Prisma.PaymentOrderUpdateInput): Promise<PaymentOrder> {
    try {
      const paymentOrder = await DatabaseService.client.paymentOrder.update({
        where: { id },
        data
      });
      
      logger.debug('PaymentOrder updated', { paymentOrderId: paymentOrder.id });
      return paymentOrder;
    } catch (error: unknown) {
      logger.error('Failed to update payment order', error, { paymentOrderId: id, data });
      throw error;
    }
  }

  /**
   * Delete payment order
   */
  public static async delete(id: string): Promise<PaymentOrder> {
    try {
      const paymentOrder = await DatabaseService.client.paymentOrder.delete({
        where: { id }
      });
      
      logger.debug('PaymentOrder deleted', { paymentOrderId: paymentOrder.id });
      return paymentOrder;
    } catch (error: unknown) {
      logger.error('Failed to delete payment order', error, { paymentOrderId: id });
      throw error;
    }
  }

  /**
   * Count payment orders with filters
   */
  public static async count(filters: Record<string, any> = {}): Promise<number> {
    try {
      const count = await DatabaseService.client.paymentOrder.count({
        where: filters
      });
      
      return count;
    } catch (error: unknown) {
      logger.error('Failed to count payment orders', error, { filters });
      throw error;
    }
  }

  /**
   * Find payment orders by status
   */
  public static async findByStatus(
    status: PaymentStatus,
    options: Omit<PaymentOrderFindOptions, 'filters'> = {}
  ): Promise<PaymentOrderFindResult> {
    try {
      return await this.findMany({
        ...options,
        filters: { status }
      });
    } catch (error: unknown) {
      logger.error('Failed to find payment orders by status', error, { status });
      throw error;
    }
  }

  /**
   * Find payment orders by method
   */
  public static async findByMethod(
    method: string,
    options: Omit<PaymentOrderFindOptions, 'filters'> = {}
  ): Promise<PaymentOrderFindResult> {
    try {
      return await this.findMany({
        ...options,
        filters: { method }
      });
    } catch (error: unknown) {
      logger.error('Failed to find payment orders by method', error, { method });
      throw error;
    }
  }

  /**
   * Find pending payment orders
   */
  public static async findPendingPayments(
    options: Omit<PaymentOrderFindOptions, 'filters'> = {}
  ): Promise<PaymentOrderFindResult> {
    try {
      return await this.findByStatus(PaymentStatus.PENDING, options);
    } catch (error: unknown) {
      logger.error('Failed to find pending payment orders', error);
      throw error;
    }
  }

  /**
   * Find failed payment orders
   */
  public static async findFailedPayments(
    filters: Record<string, any> = {},
    options: Omit<PaymentOrderFindOptions, 'filters'> = {}
  ): Promise<PaymentOrderFindResult> {
    try {
      return await this.findMany({
        ...options,
        filters: {
          ...filters,
          status: 'failed'
        }
      });
    } catch (error: unknown) {
      logger.error('Failed to find failed payment orders', error, { filters });
      throw error;
    }
  }

  /**
   * Get payment statistics
   */
  public static async getStatistics(
    filters: Record<string, any> = {}
  ): Promise<PaymentStatistics> {
    try {
      const where: Prisma.PaymentOrderWhereInput = { ...filters };

      // Get aggregated data
      const [stats, statusGroups] = await Promise.all([
        DatabaseService.client.paymentOrder.aggregate({
          where,
          _count: { id: true },
          _sum: { amount: true },
          _avg: { amount: true }
        }),
        DatabaseService.client.paymentOrder.groupBy({
          by: ['status'],
          where,
          _count: { id: true }
        })
      ]);

      // Build status counts
      const statusCounts = {
        pending: 0,
        captured: 0,
        failed: 0
      };

      statusGroups.forEach(group => {
        statusCounts[group.status as keyof typeof statusCounts] = group._count.id;
      });

      // Build method counts - PaymentOrder doesn't have method field, it's in PaymentTransaction
      const paymentsByMethod: Record<string, number> = {};

      const totalPayments = stats._count.id;
      const successfulPayments = statusCounts.captured;
      const failedPayments = statusCounts.failed;
      const pendingPayments = statusCounts.pending;

      return {
        totalPayments,
        totalAmount: Number(stats._sum.amount || 0),
        successfulPayments,
        failedPayments,
        pendingPayments,
        successRate: totalPayments > 0 ? (successfulPayments / totalPayments) * 100 : 0,
        averageAmount: Number(stats._avg.amount || 0),
        paymentsByMethod
      };
    } catch (error: unknown) {
      logger.error('Failed to get payment statistics', error, { filters });
      throw error;
    }
  }

  /**
   * Find payments by date range
   */
  public static async findByDateRange(
    startDate: Date,
    endDate: Date,
    options: Omit<PaymentOrderFindOptions, 'filters'> = {}
  ): Promise<PaymentOrderFindResult> {
    try {
      return await this.findMany({
        ...options,
        filters: {
          createdAt: {
            gte: startDate,
            lte: endDate
          }
        }
      });
    } catch (error: unknown) {
      logger.error('Failed to find payments by date range', error, { startDate, endDate });
      throw error;
    }
  }

  /**
   * Find successful payments for reconciliation
   */
  public static async findSuccessfulPayments(
    startDate: Date,
    endDate: Date,
    options: Omit<PaymentOrderFindOptions, 'filters'> = {}
  ): Promise<PaymentOrderFindResult> {
    try {
      return await this.findMany({
        ...options,
        filters: {
          status: 'captured',
          paidAt: {
            gte: startDate,
            lte: endDate
          }
        }
      });
    } catch (error: unknown) {
      logger.error('Failed to find successful payments', error, { startDate, endDate });
      throw error;
    }
  }

  /**
   * Update payment orders in batch
   */
  public static async updateMany(
    where: Prisma.PaymentOrderWhereInput,
    data: Prisma.PaymentOrderUpdateManyMutationInput
  ): Promise<Prisma.BatchPayload> {
    try {
      const result = await DatabaseService.client.paymentOrder.updateMany({
        where,
        data
      });
      
      logger.debug('PaymentOrders updated in batch', { count: result.count });
      return result;
    } catch (error: unknown) {
      logger.error('Failed to update payment orders in batch', error, { where, data });
      throw error;
    }
  }

  /**
   * Get daily payment summary
   */
  public static async getDailySummary(
    date: Date,
    filters: Record<string, any> = {}
  ): Promise<{
    date: string;
    totalPayments: number;
    totalAmount: number;
    successfulPayments: number;
    failedPayments: number;
    pendingPayments: number;
    successRate: number;
  }> {
    try {
      const startOfDay = new Date(date);
      startOfDay.setHours(0, 0, 0, 0);
      
      const endOfDay = new Date(date);
      endOfDay.setHours(23, 59, 59, 999);

      const whereClause = {
        ...filters,
        createdAt: {
          gte: startOfDay,
          lte: endOfDay
        }
      };

      const stats = await this.getStatistics(whereClause);

      return {
        date: date.toISOString().split('T')[0],
        totalPayments: stats.totalPayments,
        totalAmount: stats.totalAmount,
        successfulPayments: stats.successfulPayments,
        failedPayments: stats.failedPayments,
        pendingPayments: stats.pendingPayments,
        successRate: stats.successRate
      };
    } catch (error: unknown) {
      logger.error('Failed to get daily payment summary', error, { date, filters });
      throw error;
    }
  }

  /**
   * Find payments needing reconciliation
   */
  public static async findPaymentsForReconciliation(
    olderThan: Date,
    options: Omit<PaymentOrderFindOptions, 'filters'> = {}
  ): Promise<PaymentOrderFindResult> {
    try {
      return await this.findMany({
        ...options,
        filters: {
          status: 'pending',
          createdAt: {
            lt: olderThan
          }
        }
      });
    } catch (error: unknown) {
      logger.error('Failed to find payments for reconciliation', error, { olderThan });
      throw error;
    }
  }

  /**
   * Get revenue report
   */
  public static async getRevenueReport(
    startDate: Date,
    endDate: Date,
    groupBy: 'day' | 'week' | 'month' = 'day'
  ): Promise<Array<{
    period: string;
    totalAmount: number;
    paymentCount: number;
    averageAmount: number;
  }>> {
    try {
      let dateFormat: string;
      let dateGroup: string;
      
      switch (groupBy) {
        case 'week':
          dateFormat = '%Y-%u';
          dateGroup = 'YEARWEEK(paidAt)';
          break;
        case 'month':
          dateFormat = '%Y-%m';
          dateGroup = 'DATE_FORMAT(paidAt, "%Y-%m")';
          break;
        default:
          dateFormat = '%Y-%m-%d';
          dateGroup = 'DATE(paidAt)';
      }

      const results = await DatabaseService.client.$queryRaw<Array<{
        period: string;
        totalAmount: string;
        paymentCount: string;
        averageAmount: string;
      }>>`
        SELECT 
          DATE_FORMAT(paidAt, ${dateFormat}) as period,
          SUM(amount) as totalAmount,
          COUNT(*) as paymentCount,
          AVG(amount) as averageAmount
        FROM PaymentOrder
        WHERE status = 'captured' 
          AND paidAt >= ${startDate}
          AND paidAt <= ${endDate}
        GROUP BY ${Prisma.raw(dateGroup)}
        ORDER BY period ASC
      `;

      return results.map(result => ({
        period: result.period,
        totalAmount: parseFloat(result.totalAmount),
        paymentCount: parseInt(result.paymentCount),
        averageAmount: parseFloat(result.averageAmount)
      }));
    } catch (error: unknown) {
      logger.error('Failed to get revenue report', error, { startDate, endDate, groupBy });
      throw error;
    }
  }
}

// Export singleton instance
export const paymentOrderRepository = new PaymentOrderRepository();