/**
 * Enhanced Database service with connection pooling and performance optimization
 * Epic 5: Advanced Payment Features + Priority 3 Performance Enhancements
 * Optimized for Lambda serverless environments with connection pooling
 */
import { PrismaClient } from '@prisma/client';
import { logger } from '../utils/logger';

/**
 * Database health status interface
 */
export interface DatabaseHealthStatus {
  status: 'healthy' | 'degraded' | 'unhealthy';
  latency: number;
  connections: {
    active: number;
    idle: number;
    total: number;
    max: number;
  };
  performance: {
    averageQueryTime: number;
    slowQueries: number;
    totalQueries: number;
  };
  lastCheck: Date;
  errors: string[];
  uptime: number;
}

/**
 * Query performance tracking interface
 */
export interface QueryPerformance {
  query: string;
  params: any;
  duration: number;
  timestamp: Date;
  target: string;
  slow: boolean;
}

/**
 * Database configuration interface
 */
export interface DatabaseConfig {
  url: string;
  maxConnections: number;
  connectionTimeoutMs: number;
  queryTimeoutMs: number;
  slowQueryThreshold: number;
  enableLogging: boolean;
  enableMetrics: boolean;
  poolConfig: {
    min: number;
    max: number;
    acquireTimeoutMillis: number;
    idleTimeoutMillis: number;
  };
}

/**
 * Connection metrics interface
 */
export interface ConnectionMetrics {
  created: number;
  destroyed: number;
  active: number;
  idle: number;
  pending: number;
  errors: number;
  totalQueries: number;
  slowQueries: number;
  averageLatency: number;
  uptime: number;
  lastActivity: Date;
}

/**
 * Database service class with enhanced connection management
 * Singleton pattern for optimal resource utilization in Lambda environments
 */
export class DatabaseService {
  private static instance: DatabaseService;
  private client: PrismaClient;
  private isConnected: boolean = false;
  private connectionAttempts: number = 0;
  private lastConnectionTime: Date | null = null;
  private queryMetrics: QueryPerformance[] = [];
  private connectionMetrics: ConnectionMetrics;
  private healthStatus: DatabaseHealthStatus;
  private maxRetries: number = 3;
  private retryDelay: number = 1000;

  private constructor() {
    this.initializeConnectionMetrics();
    this.initializeHealthStatus();
    this.initializeClient();
  }

  /**
   * Get singleton instance
   */
  public static getInstance(): DatabaseService {
    if (!DatabaseService.instance) {
      DatabaseService.instance = new DatabaseService();
    }
    return DatabaseService.instance;
  }

  /**
   * Get Prisma client for direct database access
   * This maintains compatibility with services that need direct client access
   * In test environments, this will be mocked
   */
  public static get client(): PrismaClient {
    return DatabaseService.getInstance().client;
  }


  /**
   * Initialize connection metrics
   */
  private initializeConnectionMetrics(): void {
    this.connectionMetrics = {
      created: 0,
      destroyed: 0,
      active: 0,
      idle: 0,
      pending: 0,
      errors: 0,
      totalQueries: 0,
      slowQueries: 0,
      averageLatency: 0,
      uptime: Date.now(),
      lastActivity: new Date()
    };
  }

  /**
   * Initialize health status
   */
  private initializeHealthStatus(): void {
    this.healthStatus = {
      status: 'healthy',
      latency: 0,
      connections: {
        active: 0,
        idle: 0,
        total: 0,
        max: parseInt(process.env.DATABASE_MAX_CONNECTIONS || '100')
      },
      performance: {
        averageQueryTime: 0,
        slowQueries: 0,
        totalQueries: 0
      },
      lastCheck: new Date(),
      errors: [],
      uptime: Date.now()
    };
  }

  /**
   * Initialize Prisma client with enhanced configuration
   */
  private initializeClient(): void {
    try {
      const config = this.getConfiguration();
      
      this.client = new PrismaClient({
        datasources: {
          db: {
            url: config.url
          }
        },
        log: config.enableLogging ? [
          { emit: 'event', level: 'query' },
          { emit: 'event', level: 'error' },
          { emit: 'event', level: 'warn' }
        ] : [],
        errorFormat: 'pretty'
      });

      // Enhanced logging and performance tracking
      if (config.enableLogging) {
        // Type-safe Prisma event handling with proper event interface
        (this.client as any).$on('query', (event: any) => {
          const queryTime = parseFloat(event.duration);
          const isSlowQuery = queryTime > config.slowQueryThreshold;
          
          this.trackQueryPerformance({
            query: event.query,
            params: event.params,
            duration: queryTime,
            timestamp: new Date(),
            target: event.target,
            slow: isSlowQuery
          });

          if (process.env.NODE_ENV === 'development' || isSlowQuery) {
            logger.debug('Database query executed', {
              query: event.query,
              params: event.params,
              duration: queryTime,
              target: event.target,
              slow: isSlowQuery
            });
          }
        });

        (this.client as any).$on('error', (event: any) => {
          this.connectionMetrics.errors++;
          this.healthStatus.errors.push(event.message);
          
          logger.error('Database error', {
            message: event.message,
            timestamp: event.timestamp
          });
        });

        (this.client as any).$on('warn', (event: any) => {
          logger.warn('Database warning', {
            message: event.message,
            timestamp: event.timestamp
          });
        });
      }

      logger.info('Database service initialized successfully');

    } catch (error: unknown) {
      logger.error('Failed to initialize database service', {
        error: error instanceof Error ? error.message : String(error),
        stack: error.stack
      });
      throw error;
    }
  }

  /**
   * Get database configuration
   */
  private getConfiguration(): DatabaseConfig {
    return {
      url: process.env.DATABASE_URL || '',
      maxConnections: parseInt(process.env.DATABASE_MAX_CONNECTIONS || '100'),
      connectionTimeoutMs: parseInt(process.env.DATABASE_CONNECTION_TIMEOUT || '10000'),
      queryTimeoutMs: parseInt(process.env.DATABASE_QUERY_TIMEOUT || '30000'),
      slowQueryThreshold: parseInt(process.env.DATABASE_SLOW_QUERY_THRESHOLD || '1000'),
      enableLogging: process.env.DATABASE_LOGGING === 'true',
      enableMetrics: process.env.DATABASE_METRICS === 'true',
      poolConfig: {
        min: parseInt(process.env.DATABASE_POOL_MIN || '2'),
        max: parseInt(process.env.DATABASE_POOL_MAX || '100'),
        acquireTimeoutMillis: parseInt(process.env.DATABASE_POOL_ACQUIRE_TIMEOUT || '60000'),
        idleTimeoutMillis: parseInt(process.env.DATABASE_POOL_IDLE_TIMEOUT || '300000')
      }
    };
  }

  /**
   * Connect to database with retry logic
   */
  public async connect(): Promise<void> {
    if (this.isConnected) {
      return;
    }

    const startTime = Date.now();
    this.connectionAttempts++;

    try {
      logger.info('Attempting to connect to database', {
        attempt: this.connectionAttempts,
        maxRetries: this.maxRetries
      });

      // Test connection
      await this.client.$connect();
      
      // Verify connection with a simple query
      await this.client.$queryRaw`SELECT 1`;
      
      this.isConnected = true;
      this.lastConnectionTime = new Date();
      this.connectionMetrics.created++;
      this.connectionMetrics.lastActivity = new Date();
      
      const connectionTime = Date.now() - startTime;
      
      logger.info('Successfully connected to database', {
        attempt: this.connectionAttempts,
        connectionTime: `${connectionTime}ms`,
        timestamp: this.lastConnectionTime
      });

      // Reset connection attempts on successful connection
      this.connectionAttempts = 0;

    } catch (error: unknown) {
      this.connectionMetrics.errors++;
      
      logger.error('Database connection failed', {
        attempt: this.connectionAttempts,
        maxRetries: this.maxRetries,
        error: error instanceof Error ? error.message : String(error),
        duration: `${Date.now() - startTime}ms`
      });

      if (this.connectionAttempts < this.maxRetries) {
        const delay = this.retryDelay * Math.pow(2, this.connectionAttempts - 1);
        
        logger.info(`Retrying database connection in ${delay}ms`, {
          nextAttempt: this.connectionAttempts + 1,
          maxRetries: this.maxRetries
        });

        await this.delay(delay);
        return this.connect();
      } else {
        logger.error('Max database connection attempts exceeded', {
          attempts: this.connectionAttempts,
          maxRetries: this.maxRetries
        });
        throw new Error(`Database connection failed after ${this.maxRetries} attempts: ${error.message}`);
      }
    }
  }

  /**
   * Disconnect from database
   */
  public async disconnect(): Promise<void> {
    if (!this.isConnected) {
      return;
    }

    try {
      await this.client.$disconnect();
      this.isConnected = false;
      this.connectionMetrics.destroyed++;
      
      logger.info('Disconnected from database successfully');
    } catch (error: unknown) {
      logger.error('Error disconnecting from database', {
        error: error instanceof Error ? error.message : String(error)
      });
      throw error;
    }
  }

  /**
   * Get Prisma client instance
   */
  public getPrismaClient(): PrismaClient {
    if (!this.isConnected) {
      logger.warn('Database client requested but not connected. Attempting to connect...');
      // Don't await here to avoid blocking synchronous calls
      this.connect().catch(error => {
        logger.error('Failed to auto-connect database', { error: error instanceof Error ? error.message : String(error) });
      });
    }
    return this.client;
  }

  /**
   * Execute database operation with connection management
   */
  public async executeOperation<T>(
    operation: (client: PrismaClient) => Promise<T>,
    operationName: string = 'unknown'
  ): Promise<T> {
    const startTime = Date.now();
    
    try {
      // Ensure connection
      await this.connect();
      
      // Execute operation
      const result = await operation(this.client);
      
      const duration = Date.now() - startTime;
      this.connectionMetrics.totalQueries++;
      this.connectionMetrics.lastActivity = new Date();
      
      // Update average latency
      this.connectionMetrics.averageLatency = 
        (this.connectionMetrics.averageLatency * (this.connectionMetrics.totalQueries - 1) + duration) 
        / this.connectionMetrics.totalQueries;

      logger.debug('Database operation completed', {
        operation: operationName,
        duration: duration,
        totalQueries: this.connectionMetrics.totalQueries
      });

      return result;

    } catch (error: unknown) {
      const duration = Date.now() - startTime;
      this.connectionMetrics.errors++;
      
      logger.error('Database operation failed', {
        operation: operationName,
        duration: `${duration}ms`,
        error: error instanceof Error ? error.message : String(error),
        stack: error.stack
      });

      // Handle connection errors
      if (this.isConnectionError(error)) {
        this.isConnected = false;
        logger.warn('Connection lost, will attempt to reconnect on next operation');
      }

      throw error;
    }
  }

  /**
   * Check if error is a connection-related error
   */
  private isConnectionError(error: any): boolean {
    const connectionErrorMessages = [
      'connection',
      'timeout',
      'network',
      'ECONNREFUSED',
      'ENOTFOUND',
      'ETIMEDOUT',
      'Client has already been connected',
      'Connection terminated unexpectedly'
    ];

    const errorMessage = error.message?.toLowerCase() || '';
    return connectionErrorMessages.some(msg => errorMessage.includes(msg));
  }

  /**
   * Track query performance
   */
  private trackQueryPerformance(performance: QueryPerformance): void {
    this.queryMetrics.push(performance);
    
    if (performance.slow) {
      this.connectionMetrics.slowQueries++;
    }

    // Keep only last 1000 query metrics to prevent memory leaks
    if (this.queryMetrics.length > 1000) {
      this.queryMetrics = this.queryMetrics.slice(-1000);
    }

    // Update health status
    this.updateHealthStatus();
  }

  /**
   * Update health status based on current metrics
   */
  private updateHealthStatus(): void {
    const now = new Date();
    const config = this.getConfiguration();
    
    // Calculate current performance metrics
    const totalQueries = this.connectionMetrics.totalQueries;
    const slowQueries = this.connectionMetrics.slowQueries;
    const averageLatency = this.connectionMetrics.averageLatency;
    const errorRate = totalQueries > 0 ? (this.connectionMetrics.errors / totalQueries) * 100 : 0;

    // Determine health status
    let status: 'healthy' | 'degraded' | 'unhealthy' = 'healthy';
    
    if (!this.isConnected || errorRate > 10 || averageLatency > config.slowQueryThreshold * 2) {
      status = 'unhealthy';
    } else if (errorRate > 5 || averageLatency > config.slowQueryThreshold || (slowQueries / totalQueries) > 0.1) {
      status = 'degraded';
    }

    this.healthStatus = {
      status,
      latency: averageLatency,
      connections: {
        active: this.connectionMetrics.active,
        idle: this.connectionMetrics.idle,
        total: this.connectionMetrics.active + this.connectionMetrics.idle,
        max: config.maxConnections
      },
      performance: {
        averageQueryTime: averageLatency,
        slowQueries: slowQueries,
        totalQueries: totalQueries
      },
      lastCheck: now,
      errors: this.healthStatus.errors.slice(-10), // Keep last 10 errors
      uptime: now.getTime() - this.connectionMetrics.uptime
    };
  }

  /**
   * Get database health status
   */
  public async getHealthStatus(): Promise<DatabaseHealthStatus> {
    try {
      // Perform health check query
      const healthCheckStart = Date.now();
      await this.client.$queryRaw`SELECT 1 as health_check`;
      const healthCheckLatency = Date.now() - healthCheckStart;
      
      // Update latency in health status
      this.healthStatus.latency = healthCheckLatency;
      this.healthStatus.lastCheck = new Date();
      
      // Update connection status
      this.healthStatus.connections.active = this.isConnected ? 1 : 0;
      
      return { ...this.healthStatus };

    } catch (error: unknown) {
      logger.error('Health check failed', { error: error instanceof Error ? error.message : String(error) });
      
      return {
        ...this.healthStatus,
        status: 'unhealthy',
        latency: -1,
        lastCheck: new Date(),
        errors: [...this.healthStatus.errors, error.message].slice(-10)
      };
    }
  }

  /**
   * Get connection metrics
   */
  public getConnectionMetrics(): ConnectionMetrics {
    return { ...this.connectionMetrics };
  }

  /**
   * Get query performance metrics
   */
  public getQueryMetrics(limit: number = 100): QueryPerformance[] {
    return this.queryMetrics.slice(-limit);
  }

  /**
   * Get slow queries
   */
  public getSlowQueries(limit: number = 50): QueryPerformance[] {
    return this.queryMetrics
      .filter(metric => metric.slow)
      .slice(-limit);
  }

  /**
   * Clear query metrics (useful for testing or memory management)
   */
  public clearMetrics(): void {
    this.queryMetrics = [];
    this.connectionMetrics.slowQueries = 0;
    this.connectionMetrics.totalQueries = 0;
    this.connectionMetrics.averageLatency = 0;
    
    logger.info('Database metrics cleared');
  }

  /**
   * Test database connection
   */
  public async testConnection(): Promise<{
    connected: boolean;
    latency: number;
    version?: string;
    error?: string;
  }> {
    const startTime = Date.now();

    try {
      await this.connect();
      
      // Test with a simple query
      const result = await this.client.$queryRaw`SELECT version() as version, current_timestamp as timestamp`;
      const latency = Date.now() - startTime;
      
      return {
        connected: true,
        latency,
        version: (result as any)[0]?.version
      };

    } catch (error: unknown) {
      const latency = Date.now() - startTime;
      
      return {
        connected: false,
        latency,
        error: error instanceof Error ? error.message : String(error)
      };
    }
  }

  /**
   * Graceful shutdown
   */
  public async shutdown(): Promise<void> {
    logger.info('Initiating database service shutdown');

    try {
      // Close connection
      await this.disconnect();
      
      // Clear metrics
      this.clearMetrics();
      
      logger.info('Database service shutdown completed');

    } catch (error: unknown) {
      logger.error('Error during database service shutdown', {
        error: error instanceof Error ? error.message : String(error)
      });
      throw error;
    }
  }

  /**
   * Get database configuration (safe for logging)
   */
  public getConfigurationSafe(): Partial<DatabaseConfig> {
    const config = this.getConfiguration();
    
    return {
      maxConnections: config.maxConnections,
      connectionTimeoutMs: config.connectionTimeoutMs,
      queryTimeoutMs: config.queryTimeoutMs,
      slowQueryThreshold: config.slowQueryThreshold,
      enableLogging: config.enableLogging,
      enableMetrics: config.enableMetrics,
      poolConfig: config.poolConfig
    };
  }

  /**
   * Simple delay utility
   */
  private delay(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  /**
   * Check if service is ready
   */
  public isReady(): boolean {
    return this.isConnected && this.healthStatus.status !== 'unhealthy';
  }

  /**
   * Get uptime in milliseconds
   */
  public getUptime(): number {
    return Date.now() - this.connectionMetrics.uptime;
  }

  /**
   * Execute raw query with performance tracking
   */
  public async executeRawQuery<T>(query: string, params?: any[]): Promise<T> {
    return this.executeOperation(async (client) => {
      if (params) {
        return await client.$queryRawUnsafe(query, ...params) as T;
      } else {
        return await client.$queryRawUnsafe(query) as T;
      }
    }, `raw_query_${query.substring(0, 50)}...`);
  }

  /**
   * Execute transaction with retry logic
   */
  public async executeTransaction<T>(
    operations: (client: PrismaClient) => Promise<T>,
    options: {
      timeout?: number;
      isolationLevel?: string;
    } = {}
  ): Promise<T> {
    return this.executeOperation(async (client) => {
      return await client.$transaction(operations, {
        timeout: options.timeout || 30000,
        isolationLevel: options.isolationLevel as any
      });
    }, 'transaction');
  }
}

/**
 * Export singleton instance for convenience
 */
export const databaseService = DatabaseService.getInstance();

export default DatabaseService;