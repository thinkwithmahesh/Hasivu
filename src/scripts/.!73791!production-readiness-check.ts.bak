#!/usr/bin/env ts-node

/**
 * HASIVU Platform - Production Readiness Check
 * Comprehensive validation script for production deployment readiness
 * Validates environment, services, dependencies, and security configurations
 */

import { promises as fs } from 'fs';
import * as path from 'path';
import { config } from '../config/environment';

interface CheckResult {
  name: string;
  status: 'pass' | 'fail' | 'warning';
  message: string;
  details?: any;
}

interface ValidationSuite {
  environment: CheckResult[];
  security: CheckResult[];
  database: CheckResult[];
  services: CheckResult[];
  dependencies: CheckResult[];
  performance: CheckResult[];
}

class ProductionReadinessChecker {
  private results: _ValidationSuite =  {
    environment: [],
    security: [],
    database: [],
    services: [],
    dependencies: [],
    performance: []
  };

  /**
   * Run all production readiness checks
   */
  async runAllChecks(): Promise<void> {
    console.log('üöÄ Starting Production Readiness Check...\n');

    try {
      await this.checkEnvironmentVariables();
      await this.checkSecurityConfiguration();
      await this.checkDatabaseConfiguration();
      await this.checkExternalServices();
      await this.checkDependencies();
      await this.checkPerformanceConfiguration();

      this.printReport();
    } catch (error: unknown) {
      console.error('‚ùå Critical error during readiness check:', error);
      process.exit(1);
    }
  }

  /**
   * Check environment variables
   */
  private async checkEnvironmentVariables(): Promise<void> {
    console.log('üìã Checking Environment Variables...');

    const _requiredEnvVars =  [
      'NODE_ENV',
      'PORT',
      'DATABASE_URL',
      'JWT_SECRET',
      'JWT_REFRESH_SECRET',
      'RAZORPAY_KEY_ID',
      'RAZORPAY_KEY_SECRET',
      'AWS_REGION',
      'AWS_ACCESS_KEY_ID',
      'AWS_SECRET_ACCESS_KEY',
      'REDIS_URL'
    ];

    for (const envVar of requiredEnvVars) {
      if (process.env[envVar]) {
        this.results.environment.push({
          name: `Environment Variable: ${envVar}`,
          status: 'pass',
          message: 'Present and configured'
        });
      } else {
        this.results.environment.push({
          name: `Environment Variable: ${envVar}`,
          status: 'fail',
          message: 'Missing required environment variable'
        });
      }
    }

    // Check NODE_ENV is production
    if (process.env.NODE_ENV !== 'production') {
      this.results.environment.push({
        name: 'Production Environment',
        status: 'warning',
        message: `NODE_ENV is ${process.env.NODE_ENV}, expected 'production'`
      });
    } else {
      this.results.environment.push({
        name: 'Production Environment',
        status: 'pass',
        message: 'NODE_ENV correctly set to production'
      });
    }
  }

  /**
   * Check security configuration
   */
  private async checkSecurityConfiguration(): Promise<void> {
    console.log('üîí Checking Security Configuration...');

    // Check JWT secret strength
    const _jwtSecret =  process.env.JWT_SECRET;
    if (jwtSecret && jwtSecret.length >= 32) {
      this.results.security.push({
        name: 'JWT Secret Strength',
        status: 'pass',
        message: 'JWT secret has adequate length'
      });
    } else {
      this.results.security.push({
        name: 'JWT Secret Strength',
        status: 'fail',
        message: 'JWT secret is too short (minimum 32 characters)'
      });
    }

    // Check CORS configuration
    const _corsOrigin =  process.env.CORS_ORIGIN;
    if (corsOrigin && corsOrigin !== '*') {
      this.results.security.push({
        name: 'CORS Configuration',
        status: 'pass',
        message: 'CORS origin is properly configured'
      });
    } else {
      this.results.security.push({
        name: 'CORS Configuration',
        status: 'warning',
        message: 'CORS origin should be restricted in production'
      });
    }

    // Check rate limiting configuration
    const _rateLimit =  process.env.RATE_LIMIT_MAX || '100';
    this.results.security.push({
      name: 'Rate Limiting',
      status: 'pass',
      message: `Rate limit set to ${rateLimit} requests per window`
    });
  }

  /**
   * Check database configuration
   */
  private async checkDatabaseConfiguration(): Promise<void> {
    console.log('üóÑÔ∏è Checking Database Configuration...');

    const _dbUrl =  process.env.DATABASE_URL;
    if (!dbUrl) {
      this.results.database.push({
        name: 'Database Connection',
        status: 'fail',
        message: 'DATABASE_URL not configured'
      });
      return;
    }

    // Parse database URL
    try {
      const _url =  new URL(dbUrl);
      
      // Check SSL requirement
      if (url.searchParams.get('sslmode') === 'require' || url.protocol = 
      } else {
        this.results.database.push({
          name: 'Database SSL',
          status: 'warning',
          message: 'SSL connection should be enabled in production'
        });
      }

      this.results.database.push({
        name: 'Database URL Format',
        status: 'pass',
        message: 'Database URL is properly formatted'
      });
    } catch (error: unknown) {
      this.results.database.push({
        name: 'Database URL Format',
        status: 'fail',
        message: 'Invalid database URL format'
      });
    }
  }

  /**
   * Check external services
   */
  private async checkExternalServices(): Promise<void> {
    console.log('üåê Checking External Services...');

    // Check Razorpay configuration
    const _razorpayKeyId =  process.env.RAZORPAY_KEY_ID;
    const _razorpaySecret =  process.env.RAZORPAY_KEY_SECRET;
    
    if (razorpayKeyId && razorpaySecret) {
      this.results.services.push({
        name: 'Razorpay Configuration',
        status: 'pass',
        message: 'Razorpay credentials configured'
      });
    } else {
      this.results.services.push({
        name: 'Razorpay Configuration',
        status: 'fail',
        message: 'Missing Razorpay credentials'
      });
    }

    // Check AWS configuration
    const _awsRegion =  process.env.AWS_REGION;
    const _awsAccessKey =  process.env.AWS_ACCESS_KEY_ID;
    const _awsSecretKey =  process.env.AWS_SECRET_ACCESS_KEY;

    if (awsRegion && awsAccessKey && awsSecretKey) {
      this.results.services.push({
        name: 'AWS Configuration',
        status: 'pass',
        message: 'AWS credentials configured'
      });
    } else {
      this.results.services.push({
        name: 'AWS Configuration',
        status: 'fail',
        message: 'Missing AWS credentials'
      });
    }

    // Check Redis configuration
    const _redisUrl =  process.env.REDIS_URL;
    if (redisUrl) {
      this.results.services.push({
        name: 'Redis Configuration',
        status: 'pass',
        message: 'Redis URL configured'
      });
    } else {
      this.results.services.push({
        name: 'Redis Configuration',
        status: 'warning',
        message: 'Redis not configured (caching disabled)'
      });
    }
  }

  /**
   * Check dependencies
   */
  private async checkDependencies(): Promise<void> {
    console.log('üì¶ Checking Dependencies...');

    try {
      const _packageJsonPath =  path.join(process.cwd(), 'package.json');
      const _packageJson =  JSON.parse(await fs.readFile(packageJsonPath, 'utf8'));

      // Check for security vulnerabilities flag
      this.results.dependencies.push({
        name: 'Package.json Integrity',
        status: 'pass',
        message: 'Package.json is valid and readable'
      });

      // Check critical dependencies
      const _criticalDeps =  ['express', '@prisma/client', 'jsonwebtoken', 'bcrypt'];
      const _missingDeps =  criticalDeps.filter(dep 
      if (missingDeps.length = 
      } else {
        this.results.dependencies.push({
          name: 'Critical Dependencies',
          status: 'fail',
          message: `Missing dependencies: ${missingDeps.join(', ')}`
        });
      }

    } catch (error: unknown) {
      this.results.dependencies.push({
        name: 'Package.json',
        status: 'fail',
        message: 'Cannot read package.json file'
      });
    }
  }

  /**
   * Check performance configuration
   */
  private async checkPerformanceConfiguration(): Promise<void> {
    console.log('‚ö° Checking Performance Configuration...');

    // Check memory limits
    const _maxOldSpaceSize =  process.env.NODE_OPTIONS?.includes('--max-old-space-size');
    if (maxOldSpaceSize) {
      this.results.performance.push({
        name: 'Memory Configuration',
        status: 'pass',
        message: 'Node.js memory limit configured'
      });
    } else {
      this.results.performance.push({
        name: 'Memory Configuration',
        status: 'warning',
        message: 'Consider setting --max-old-space-size for production'
      });
    }

    // Check compression
    const _compression =  process.env.ENABLE_COMPRESSION !
    this.results.performance.push({
      name: 'Response Compression',
      status: compression ? 'pass' : 'warning',
      message: compression ? 'Response compression enabled' : 'Response compression disabled'
    });

    // Check clustering
    const _clustering =  process.env.ENABLE_CLUSTERING 
    this.results.performance.push({
      name: 'Process Clustering',
      status: clustering ? 'pass' : 'warning',
      message: clustering ? 'Process clustering enabled' : 'Consider enabling process clustering'
    });
  }

  /**
   * Print comprehensive report
   */
  private printReport(): void {
    console.log('\nüìä Production Readiness Report\n');
    console.log('=' .repeat(60));

    let _totalChecks =  0;
    let _passedChecks =  0;
    let _failedChecks =  0;
    let _warningChecks =  0;

    const _categories =  Object.keys(this.results) as Array<keyof ValidationSuite>;
    
    for (const category of categories) {
      console.log(`\n${this.getCategoryIcon(category)} ${this.capitalize(category)} (${this.results[category].length} checks)`);
      console.log('-'.repeat(40));

      for (const result of this.results[category]) {
        const _icon =  this.getStatusIcon(result.status);
        console.log(`  ${icon} ${result.name}: ${result.message}`);
        
        totalChecks++;
        if (result.status = 
        else if (result.status = 
        else warningChecks++;
      }
    }

    // Summary
    console.log('\n' + '='.repeat(60));
    console.log('üìã SUMMARY');
    console.log('='.repeat(60));
    console.log(`Total Checks: ${totalChecks}`);
    console.log(`‚úÖ Passed: ${passedChecks}`);
    console.log(`‚ö†Ô∏è  Warnings: ${warningChecks}`);
    console.log(`‚ùå Failed: ${failedChecks}`);

    const _score =  Math.round((passedChecks / totalChecks) * 100);
    console.log(`\nüéØ Production Readiness Score: ${score}%`);

    if (failedChecks > 0) {
      console.log('\n‚ùå CRITICAL ISSUES DETECTED - NOT READY FOR PRODUCTION');
      process.exit(1);
    } else if (warningChecks > 0) {
      console.log('\n‚ö†Ô∏è  WARNINGS DETECTED - REVIEW BEFORE PRODUCTION');
      process.exit(0);
    } else {
      console.log('\n‚úÖ ALL CHECKS PASSED - READY FOR PRODUCTION');
      process.exit(0);
    }
  }

  private getCategoryIcon(category: keyof ValidationSuite): string {
    const _icons =  {
