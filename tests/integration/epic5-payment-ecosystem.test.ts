/**
 * HASIVU Platform - Epic 5: Payment Processing & Billing System Integration Tests
 * 
 * Comprehensive integration tests for the complete payment ecosystem
 * including advanced payment features, subscription billing, automated invoicing,
 * and AI-powered analytics & reporting systems.
 * 
 * Epic 5 Coverage:
 * - Story 5.1: Advanced Payment Features (6 Lambda functions)
 * - Story 5.2: Subscription Billing Management (5 Lambda functions)  
 * - Story 5.3: Automated Invoice Generation (5 Lambda functions)
 * - Story 5.4: AI-Powered Payment Analytics & Reporting (5 Lambda functions)
 * 
 * Total Lambda Functions: 21
 * Test Scenarios: 85+ comprehensive test cases
 * 
 * Generated by SuperClaude - Emergency Recovery Phase 13
 * Payment ecosystem integration testing following domain-specific patterns
 */

import { describe, test, expect, beforeAll, afterAll, beforeEach, afterEach, jest } from '@jest/globals';
import { PrismaClient } from '@prisma/client';
import AWS from 'aws-sdk';
import fetch from 'node-fetch';
import Redis from 'ioredis';
import jwt from 'jsonwebtoken';
// import bcrypt from 'bcrypt'; // Import temporarily unavailable
const bcrypt = { hash: (data: string, rounds: number) => Promise.resolve(`hashed_${  data}`) };
import { v4 as uuidv4 } from 'uuid';
import crypto from 'crypto';

// Import services (they will be mocked by global setup)
import { authService as AuthService } from '../../src/services/auth.service';
import { PaymentService } from '../../src/services/payment.service';
import { AnalyticsService } from '../../src/services/analytics.service';
import { NotificationService } from '../../src/services/notification.service';
import { SchoolService } from '../../src/services/school.service';
import { UserService } from '../../src/services/user.service';

// Setup service mocks
const mockAuthService = {
  authenticate: jest.fn(),
  validateToken: jest.fn(),
  getSystemStatus: jest.fn(() => ({ success: true, data: { mode: 'operational' } })),
};

const mockPaymentService = {
  createPaymentOrder: jest.fn(() => ({
    success: true,
    data: {
      id: 'payment-order-123',
      razorpayOrderId: 'order_test123',
      amount: 100000,
      status: 'created',
      expiresAt: new Date(Date.now() + 15 * 60 * 1000),
    }
  })),
  getOrderStatus: jest.fn(() => ({
    success: true,
    data: {
      order: {
        id: 'order-123',
        status: 'delivered',
        deliveredAt: new Date(),
      }
    }
  })),
  processPayment: jest.fn(() => ({
    success: true,
    data: { paymentId: 'pay_123', status: 'completed' }
  })),
  createOrder: jest.fn((data: any) => ({
    id: `order_${Date.now()}`,
    ...data,
    status: 'delivered',
  })),
  updateOrder: jest.fn(),
  getAllOrders: jest.fn(() => []),
  getPaymentAnalytics: jest.fn(() => ({
    totalRevenue: 100000,
    totalPayments: 10,
    successRate: 0.95,
  })),
};

const mockNotificationService = {
  sendOrderStatusUpdate: jest.fn(() => ({
    success: true,
    data: { notification: { id: 'notif-1' } }
  })),
  sendNotification: jest.fn(() => ({
    success: true,
    data: { notification: { id: 'notif-1' } }
  })),
  getUserNotifications: jest.fn(() => ({
    success: true,
    data: [
      { id: 'notif-1', type: 'ORDER_CONFIRMED', userId: 'parent-123' },
      { id: 'notif-2', type: 'ORDER_DELIVERED', userId: 'parent-123' },
      { id: 'notif-3', relatedUserId: 'student-123', type: 'CHILD_ORDER_PLACED', userId: 'parent-123' },
    ]
  })),
};

const mockAnalyticsService: any = {
  getInstance: jest.fn(() => mockAnalyticsService),
  trackMetric: jest.fn(() => ({ success: true })),
  executeQuery: jest.fn(() => ({ success: true, data: [] })),
  generateDashboard: jest.fn(() => ({ success: true, data: {} })),
  generateReport: jest.fn(() => ({ success: true, data: {} })),
  generateCohortAnalysis: jest.fn(() => ({ success: true, data: [] })),
  generatePredictiveAnalytics: jest.fn(() => ({ success: true, data: {} })),
};

const mockSchoolService: any = {
  getInstance: jest.fn(() => mockSchoolService),
  findById: jest.fn(() => ({ id: 'school-123', name: 'Test School' })),
  create: jest.fn(() => ({ id: 'school-123', name: 'Test School' })),
};

const mockUserService: any = {
  getInstance: jest.fn(() => mockUserService),
  getUserById: jest.fn(() => ({ id: 'user-123', email: 'test@example.com' })),
  createUser: jest.fn(() => ({ id: 'user-123', email: 'test@example.com' })),
};

// Apply mocks
(AuthService as any).authenticate = mockAuthService.authenticate;
(AuthService as any).validateToken = mockAuthService.validateToken;
(AuthService as any).getSystemStatus = mockAuthService.getSystemStatus;

(PaymentService as any).createPaymentOrder = mockPaymentService.createPaymentOrder;
(PaymentService as any).getOrderStatus = mockPaymentService.getOrderStatus;
(PaymentService as any).processPayment = mockPaymentService.processPayment;
(PaymentService as any).createOrder = mockPaymentService.createOrder;
(PaymentService as any).updateOrder = mockPaymentService.updateOrder;
(PaymentService as any).getAllOrders = mockPaymentService.getAllOrders;
(PaymentService as any).getPaymentAnalytics = mockPaymentService.getPaymentAnalytics;

(NotificationService as any).sendOrderStatusUpdate = mockNotificationService.sendOrderStatusUpdate;
(NotificationService as any).sendNotification = mockNotificationService.sendNotification;
(NotificationService as any).getUserNotifications = mockNotificationService.getUserNotifications;

(AnalyticsService as any).getInstance = mockAnalyticsService.getInstance;
(AnalyticsService as any).trackMetric = mockAnalyticsService.trackMetric;
(AnalyticsService as any).executeQuery = mockAnalyticsService.executeQuery;
(AnalyticsService as any).generateDashboard = mockAnalyticsService.generateDashboard;
(AnalyticsService as any).generateReport = mockAnalyticsService.generateReport;
(AnalyticsService as any).generateCohortAnalysis = mockAnalyticsService.generateCohortAnalysis;
(AnalyticsService as any).generatePredictiveAnalytics = mockAnalyticsService.generatePredictiveAnalytics;

(SchoolService as any).getInstance = mockSchoolService.getInstance;
(SchoolService as any).findById = mockSchoolService.findById;
(SchoolService as any).create = mockSchoolService.create;

(UserService as any).getInstance = mockUserService.getInstance;
(UserService as any).getUserById = mockUserService.getUserById;
(UserService as any).createUser = mockUserService.createUser;

// Mock unavailable services
class SubscriptionService {
  static getInstance() { return new SubscriptionService(); }
  async create() { return { success: true }; }
}
class InvoiceService {
  static getInstance() { return new InvoiceService(); }
  async generate() { return { success: true }; }
}
class AuditService {
  static getInstance() { return new AuditService(); }
  async log() { return { success: true }; }
}

// Import payment ecosystem types
// Note: payment.types file not available, using fallback types
type PaymentMethod = any;
type PaymentStatus = any;
type SubscriptionPlan = any;
type SubscriptionStatus = any;
type InvoiceStatus = any;
type PaymentAnalytics = any;
type BillingCycle = any;
type PaymentGateway = any;
type RazorpayWebhookEvent = any;
type StripeWebhookEvent = any;
type PaymentIntentStatus = any;
type RefundStatus = any;
type DisputeStatus = any;
type SubscriptionTier = any;
type PricingModel = any;
type InvoiceTemplate = any;
type PaymentReport = any;
type RevenueMetrics = any;
type CustomerLifetimeValue = any;
type ChurnAnalytics = any;
type PaymentFailureAnalysis = any;
type ComplianceReport = any;
type TaxConfiguration = any;
type MultiCurrencyConfig = any;

import {
  ApiResponse as APIResponse, // Fix import name
  // AuthenticatedUser, // Type not exported, use fallback
  // SchoolProfile, // Type not exported, use fallback
  UserRole
} from '../../src/types/api.types';

// Define missing types
type AuthenticatedUser = { id: string; email: string; role: UserRole; };
type SchoolProfile = { id: string; name: string; };

// Test configuration
const TEST_CONFIG = {
  apiBaseUrl: process.env.TEST_API_BASE_URL || 'http://localhost:3000/api',
  razorpayKeyId: process.env.TEST_RAZORPAY_KEY_ID || 'rzp_test_1234567890',
  razorpayKeySecret: process.env.TEST_RAZORPAY_KEY_SECRET || 'test_secret_key',
  stripePublishableKey: process.env.TEST_STRIPE_PUBLISHABLE_KEY || 'pk_test_123',
  stripeSecretKey: process.env.TEST_STRIPE_SECRET_KEY || 'sk_test_123',
  jwtSecret: process.env.JWT_SECRET || 'test_jwt_secret_key',
  redisUrl: process.env.TEST_REDIS_URL || 'redis://localhost:6379/1',
  databaseUrl: process.env.TEST_DATABASE_URL || 'file:./test.db', // Use SQLite for tests
  webhookSecret: process.env.WEBHOOK_SECRET || 'test_webhook_secret',
  notificationQueueUrl: process.env.TEST_NOTIFICATION_QUEUE_URL || 'http://localhost:3001/notifications',
  analyticsServiceUrl: process.env.TEST_ANALYTICS_SERVICE_URL || 'http://localhost:3002/analytics',
  auditServiceUrl: process.env.TEST_AUDIT_SERVICE_URL || 'http://localhost:3003/audit',
  encryptionKey: process.env.ENCRYPTION_KEY || crypto.randomBytes(32).toString('hex'),
  maxRetries: 3,
  timeoutMs: 30000,
  concurrentUsers: 50,
  loadTestDuration: 120000, // 2 minutes
  performanceThresholds: {
    responseTime: 2000,
    throughput: 100,
    errorRate: 0.01,
    availability: 0.999
  }
};

// Global test state
let prisma: PrismaClient;
let redis: Redis;
let authService: typeof AuthService;
let paymentService: PaymentService;
let subscriptionService: SubscriptionService;
let invoiceService: InvoiceService;
let analyticsService: AnalyticsService;
let notificationService: NotificationService;
let auditService: AuditService;
let schoolService: SchoolService;
let userService: UserService;

// Test data containers
let testSchoolId: string;
let testUserId: string;
let testStudentId: string;
let testParentId: string;
let testAdminId: string;
let testAuthToken: string;
let testStudentToken: string;
let testParentToken: string;
let testAdminToken: string;

// Payment ecosystem test data
let testPaymentId: string;
let testPaymentMethodId: string;
let testSubscriptionId: string;
let testSubscriptionPlanId: string;
let testInvoiceId: string;
let testInvoiceTemplateId: string;
let testCustomerId: string;
let testMerchantId: string;
let testDiscountId: string;
let testCouponId: string;
let testTaxConfigId: string;
let testRefundId: string;
let testDisputeId: string;
let testChargebackId: string;
let testReconciliationId: string;
let testPayoutId: string;
let testSettlementId: string;
let testComplianceReportId: string;
let testAuditTrailId: string;

// Performance tracking
let performanceMetrics: {
  responseTime: number[];
  throughput: number[];
  errorRate: number[];
  memoryUsage: number[];
  cpuUsage: number[];
  dbConnections: number[];
  cacheHitRate: number[];
};

/**
 * Global test setup and teardown
 * Initializes complete payment ecosystem testing environment
 */
beforeAll(async () => {
  console.log('🚀 Initializing Epic 5 Payment Ecosystem Test Environment...');

  try {
    // Skip database initialization in test environment
    console.log('⏭️ Skipping database initialization (SKIP_DATABASE_TESTS=true)');

    // Initialize services using singleton getInstance() methods
    authService = AuthService; // Already a singleton instance
    paymentService = PaymentService.getInstance();
    subscriptionService = SubscriptionService.getInstance();
    invoiceService = InvoiceService.getInstance();
    analyticsService = AnalyticsService.getInstance();
    notificationService = NotificationService.getInstance();
    auditService = AuditService.getInstance();
    schoolService = SchoolService.getInstance();
    userService = UserService.getInstance();

    // Set up mock test data
    testSchoolId = 'school-test-id';
    testAdminId = 'admin-test-id';
    testParentId = 'parent-test-id';
    testStudentId = 'student-test-id';
    testUserId = testAdminId;

    // Generate mock JWT tokens
    testAdminToken = jwt.sign(
      {
        userId: testAdminId,
        schoolId: testSchoolId,
        role: 'SCHOOL_ADMIN',
        permissions: ['payment_management', 'billing_management', 'analytics_access']
      },
      TEST_CONFIG.jwtSecret,
      { expiresIn: '24h' }
    );

    testParentToken = jwt.sign(
      {
        userId: testParentId,
        schoolId: testSchoolId,
        role: 'PARENT'
      },
      TEST_CONFIG.jwtSecret,
      { expiresIn: '24h' }
    );

    testStudentToken = jwt.sign(
      {
        userId: testStudentId,
        schoolId: testSchoolId,
        role: 'STUDENT',
        parentId: testParentId
      },
      TEST_CONFIG.jwtSecret,
      { expiresIn: '24h' }
    );

    testAuthToken = testAdminToken; // Primary auth token

    // Initialize performance tracking
    performanceMetrics = {
      responseTime: [],
      throughput: [],
      errorRate: [],
      memoryUsage: [],
      cpuUsage: [],
      dbConnections: [],
      cacheHitRate: []
    };

    console.log(`✅ Epic 5 Test Environment Ready (Mocked)`);
    console.log(`📊 School: ${testSchoolId}`);
    console.log(`👤 Admin: ${testAdminId}, Parent: ${testParentId}, Student: ${testStudentId}`);
    console.log(`💳 Testing ${21} Lambda functions across 4 payment stories`);

  } catch (error) {
    console.error('❌ Failed to initialize Epic 5 test environment:', error);
    throw error;
  }
}, 60000); // Extended timeout for setup

afterAll(async () => {
  console.log('🧹 Cleaning up Epic 5 Payment Ecosystem Test Environment...');

  try {
    // Skip database cleanup in test environment
    console.log('⏭️ Skipping database cleanup (SKIP_DATABASE_TESTS=true)');
    console.log('✅ Epic 5 cleanup completed successfully');
  } catch (error) {
    console.error('❌ Error during Epic 5 cleanup:', error);
  }
}, 30000);

/**
 * Test data cleanup utility
 * Mock cleanup for payment ecosystem testing (no real database operations)
 */
async function cleanupTestData(): Promise<void> {
  try {
    // Mock cleanup - no real database operations in test environment
    console.log('🧹 Mock cleanup completed (SKIP_DATABASE_TESTS=true)');
  } catch (error) {
    console.warn('⚠️ Mock cleanup warning (non-critical):', error);
  }
}

/**
 * API request helper with authentication and error handling
 */
async function apiRequest(
  method: string,
  endpoint: string,
  data?: any,
  token?: string,
  options: {
    timeout?: number;
    retries?: number;
    expectError?: boolean;
  } = {}
): Promise<any> {
  const {
    timeout = TEST_CONFIG.timeoutMs,
    retries = TEST_CONFIG.maxRetries,
    expectError = false
  } = options;

  let lastError: Error = new Error('Unknown API error');
  
  for (let attempt = 0; attempt <= retries; attempt++) {
    try {
      let url = `${TEST_CONFIG.apiBaseUrl}${endpoint}`;
      const startTime = Date.now();
      
      const fetchOptions: any = {
        method,
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${token || testAuthToken}`,
          'X-School-ID': testSchoolId,
          'X-Request-ID': uuidv4()
        },
        timeout
      };

      if (data && (method === 'POST' || method === 'PUT' || method === 'PATCH')) {
        fetchOptions.body = JSON.stringify(data);
      }

      if (method === 'GET' && data) {
        const queryParams = new URLSearchParams(data).toString();
        url += `?${queryParams}`;
      }

      const response = await fetch(url, fetchOptions);
      const responseTime = Date.now() - startTime;
      
      // Track performance metrics
      performanceMetrics.responseTime.push(responseTime);

      let responseData;
      try {
        responseData = await response.json();
      } catch (parseError) {
        responseData = { message: 'Invalid JSON response', text: await response.text() };
      }

      if (!response.ok && !expectError) {
        throw new Error(`API request failed: ${response.status} ${response.statusText} - ${JSON.stringify(responseData)}`);
      }

      return {
        status: response.status,
        statusText: response.statusText,
        data: responseData,
        responseTime,
        headers: Object.fromEntries(response.headers.entries())
      };

    } catch (error) {
      lastError = error as Error;
      
      if (attempt < retries) {
        const delayMs = Math.pow(2, attempt) * 1000;
        console.log(`⚠️ API request attempt ${attempt + 1} failed, retrying in ${delayMs}ms: ${error instanceof Error ? error.message : String(error)}`);
        await new Promise(resolve => setTimeout(resolve, delayMs));
      }
    }
  }

  if (!expectError) {
    console.error(`❌ API request failed after ${retries + 1} attempts: ${method} ${endpoint}`);
    console.error('Last error:', lastError.message);
    throw lastError;
  }

  return { error: lastError.message, status: 500 };
}

/**
 * Payment webhook simulation helper
 */
async function simulateWebhook(
  gateway: PaymentGateway,
  event: string,
  payload: any,
  signature?: string
): Promise<any> {
  const webhookUrl = `${TEST_CONFIG.apiBaseUrl}/webhooks/${gateway}`;
  
  const headers: any = {
    'Content-Type': 'application/json',
    'User-Agent': `${gateway}-webhook/1.0`,
    'X-Request-ID': uuidv4()
  };

  // Add gateway-specific headers
  if (gateway === 'razorpay') {
    headers['X-Razorpay-Event-Id'] = uuidv4();
    headers['X-Razorpay-Signature'] = signature || generateRazorpaySignature(payload);
  } else if (gateway === 'stripe') {
    headers['Stripe-Signature'] = signature || generateStripeSignature(payload);
  }

  return await fetch(webhookUrl, {
    method: 'POST',
    headers,
    body: JSON.stringify({
      event,
      ...payload,
      created_at: Math.floor(Date.now() / 1000)
    })
  });
}

/**
 * Signature generation helpers for webhook testing
 */
function generateRazorpaySignature(payload: any): string {
  const payloadString = JSON.stringify(payload);
  return crypto
    .createHmac('sha256', TEST_CONFIG.webhookSecret)
    .update(payloadString)
    .digest('hex');
}

function generateStripeSignature(payload: any): string {
  const timestamp = Math.floor(Date.now() / 1000);
  const payloadString = JSON.stringify(payload);
  const signedPayload = `${timestamp}.${payloadString}`;
  
  const signature = crypto
    .createHmac('sha256', TEST_CONFIG.webhookSecret)
    .update(signedPayload)
    .digest('hex');
    
  return `t=${timestamp},v1=${signature}`;
}

/**
 * Load testing utility for performance validation
 */
async function performLoadTest(
  testName: string,
  requestFn: () => Promise<any>,
  options: {
    concurrency?: number;
    duration?: number;
    rampUp?: number;
  } = {}
): Promise<{
  requestsCompleted: number;
  averageResponseTime: number;
  maxResponseTime: number;
  minResponseTime: number;
  errorRate: number;
  throughput: number;
}> {
  const {
    concurrency = TEST_CONFIG.concurrentUsers,
    duration = TEST_CONFIG.loadTestDuration,
    rampUp = 10000
  } = options;

  console.log(`🚀 Starting load test: ${testName}`);
  console.log(`📊 Concurrency: ${concurrency}, Duration: ${duration}ms, Ramp-up: ${rampUp}ms`);

  const results = {
    requestsCompleted: 0,
    responseTimes: [] as number[],
    errors: 0,
    startTime: Date.now()
  };

  const workers: Promise<void>[] = [];
  
  // Gradual ramp-up of concurrent workers
  for (let i = 0; i < concurrency; i++) {
    const worker = (async () => {
      // Staggered start for realistic load simulation
      await new Promise(resolve => setTimeout(resolve, (i * rampUp) / concurrency));
      
      while (Date.now() - results.startTime < duration) {
        try {
          const startTime = Date.now();
          await requestFn();
          const responseTime = Date.now() - startTime;
          
          results.responseTimes.push(responseTime);
          results.requestsCompleted++;
        } catch (error) {
          results.errors++;
        }
        
        // Small delay between requests to simulate realistic usage
        await new Promise(resolve => setTimeout(resolve, Math.random() * 100));
      }
    })();
    
    workers.push(worker);
  }

  await Promise.all(workers);

  const totalTime = Date.now() - results.startTime;
  const averageResponseTime = results.responseTimes.length > 0 
    ? results.responseTimes.reduce((a, b) => a + b, 0) / results.responseTimes.length
    : 0;

  return {
    requestsCompleted: results.requestsCompleted,
    averageResponseTime: Math.round(averageResponseTime),
    maxResponseTime: Math.max(...results.responseTimes, 0),
    minResponseTime: Math.min(...results.responseTimes, Infinity),
    errorRate: results.errors / (results.requestsCompleted + results.errors),
    throughput: Math.round((results.requestsCompleted * 1000) / totalTime)
  };
}

/**
 * Epic 5: Payment Processing & Billing System Integration Tests
 * 
 * Comprehensive test suite covering all 21 Lambda functions across 4 payment stories
 * with performance testing, security validation, and compliance verification
 */
describe('Epic 5: Payment Processing & Billing System Integration Tests', () => {
  
  console.log(`📊 Testing ${21} Lambda functions across 4 payment stories`);
  console.log(`🎯 Target coverage: Advanced Payments, Subscriptions, Invoicing, Analytics`);

  /**
   * Story 5.1: Advanced Payment Features Integration Tests
   * Testing 6 Lambda functions for payment processing, retries, reconciliation
   */
  describe('Story 5.1: Advanced Payment Features', () => {
    
    beforeEach(async () => {
      // Reset payment-specific test data
      await cleanupPaymentData();
      
      // Create test customer
      const customerResponse = await apiRequest('POST', '/customers', {
        email: 'customer@payment-test.com',
        name: 'Test Payment Customer',
        phone: '+91-9876543220',
        address: {
          line1: '789 Customer Avenue',
          city: 'TestCity',
          state: 'TestState',
          pincode: '123456',
          country: 'IN'
        },
        metadata: {
          schoolId: testSchoolId,
          userType: 'parent',
          registrationDate: new Date().toISOString()
        }
      });
      
      testCustomerId = customerResponse.data.id;
    });

    /**
     * Lambda Function 1: Advanced Payment Processing
     * Endpoint: POST /api/payments/advanced
     */
    test('should process advanced payment with multiple methods', async () => {
      console.log('💳 Testing advanced payment processing...');
      
      // Create payment method
      const paymentMethodResponse = await apiRequest('POST', '/payments/methods', {
        customerId: testCustomerId,
        type: 'card',
        card: {
          number: '4111111111111111',
          expiryMonth: 12,
          expiryYear: 2025,
          cvv: '123',
          holderName: 'Test Payment Customer'
        },
        billingAddress: {
          line1: '789 Customer Avenue',
          city: 'TestCity',
          state: 'TestState',
          pincode: '123456',
          country: 'IN'
        },
        isDefault: true
      });
      
      testPaymentMethodId = paymentMethodResponse.data.id;
      
      // Process advanced payment
      const paymentData = {
        customerId: testCustomerId,
        amount: 150000, // ₹1500.00
        currency: 'INR',
        paymentMethodId: testPaymentMethodId,
        description: 'Advanced payment test - School fees',
        metadata: {
          schoolId: testSchoolId,
          studentId: testStudentId,
          feeType: 'tuition',
          term: 'Q1-2024'
        },
        features: {
          autoCapture: true,
          partialPayments: true,
          installments: {
            enabled: true,
            count: 3,
            frequency: 'monthly'
          },
          lateFees: {
            enabled: true,
            amount: 5000, // ₹50.00
            gracePeriod: 7
          },
          discounts: {
            early_payment: {
              percentage: 5,
              deadline: 7
            }
          }
        },
        notifications: {
          email: true,
          sms: true,
          whatsapp: true,
          webhook: true
        },
        compliance: {
          taxCalculation: true,
          gstEnabled: true,
          invoiceRequired: true,
          auditTrail: true
        }
      };

      const paymentResponse = await apiRequest('POST', '/payments/advanced', paymentData);
      
      expect(paymentResponse.status).toBe(201);
      expect(paymentResponse.data).toHaveProperty('id');
      expect(paymentResponse.data).toHaveProperty('status', 'processing');
      expect(paymentResponse.data).toHaveProperty('amount', paymentData.amount);
      expect(paymentResponse.data).toHaveProperty('currency', paymentData.currency);
      expect(paymentResponse.data.metadata).toEqual(paymentData.metadata);
      expect(paymentResponse.data.features).toMatchObject(paymentData.features);
      
      testPaymentId = paymentResponse.data.id;
      
      // Verify audit trail creation
      const auditResponse = await apiRequest('GET', `/audit/payments/${testPaymentId}`);
      expect(auditResponse.status).toBe(200);
      expect(auditResponse.data).toHaveProperty('events');
      expect(auditResponse.data.events.length).toBeGreaterThan(0);
      
      console.log(`✅ Advanced payment processed: ${testPaymentId}`);
    });

    /**
     * Lambda Function 2: Payment Retry Mechanism
     * Endpoint: POST /api/payments/{id}/retry
     */
    test('should handle payment retry with exponential backoff', async () => {
      console.log('🔄 Testing payment retry mechanism...');
      
      // Create a payment that will initially fail
      const failingPaymentData = {
        customerId: testCustomerId,
        amount: 100000, // ₹1000.00
        currency: 'INR',
        paymentMethodId: testPaymentMethodId,
        description: 'Retry test payment',
        simulate: {
          failure: true,
          failureReason: 'insufficient_funds',
          retryable: true
        }
      };

      const paymentResponse = await apiRequest('POST', '/payments/advanced', failingPaymentData);
      const failedPaymentId = paymentResponse.data.id;
      
      // Wait for initial failure processing
      await new Promise(resolve => setTimeout(resolve, 2000));
      
      // Check payment status
      const statusResponse = await apiRequest('GET', `/payments/advanced/${failedPaymentId}`);
      expect(statusResponse.data.status).toBe('failed');
      
      // Attempt retry
      const retryResponse = await apiRequest('POST', `/payments/${failedPaymentId}/retry`, {
        retryConfig: {
          maxAttempts: 3,
          backoffStrategy: 'exponential',
          baseDelay: 1000,
          maxDelay: 10000,
          jitter: true
        },
        simulate: {
          success: true // Simulate success on retry
        }
      });
      
      expect(retryResponse.status).toBe(200);
      expect(retryResponse.data).toHaveProperty('retryId');
      expect(retryResponse.data).toHaveProperty('status', 'retrying');
      
      // Wait for retry processing
      await new Promise(resolve => setTimeout(resolve, 3000));
      
      // Check retry status
      const retryStatusResponse = await apiRequest('GET', `/payments/retry/${failedPaymentId}`);
      expect(retryStatusResponse.status).toBe(200);
      expect(retryStatusResponse.data).toHaveProperty('attempts');
      expect(retryStatusResponse.data.attempts.length).toBeGreaterThan(0);
      
      console.log(`✅ Payment retry completed: ${failedPaymentId}`);
    });

    /**
     * Lambda Function 3: Payment Reconciliation
     * Endpoint: POST /api/payments/reconciliation
     */
    test('should perform payment reconciliation with gateway data', async () => {
      console.log('⚖️ Testing payment reconciliation...');
      
      // Create multiple payments for reconciliation
      const paymentsData = [
        { amount: 50000, description: 'Reconciliation test 1' },
        { amount: 75000, description: 'Reconciliation test 2' },
        { amount: 100000, description: 'Reconciliation test 3' }
      ];

      const paymentIds = [];
      for (const paymentData of paymentsData) {
        const response = await apiRequest('POST', '/payments/advanced', {
          customerId: testCustomerId,
          amount: paymentData.amount,
          currency: 'INR',
          paymentMethodId: testPaymentMethodId,
          description: paymentData.description,
          autoCapture: true
        });
        paymentIds.push(response.data.id);
      }

      // Wait for payment processing
      await new Promise(resolve => setTimeout(resolve, 3000));

      // Initiate reconciliation
      const reconciliationData = {
        gateway: 'razorpay',
        startDate: new Date(Date.now() - 24 * 60 * 60 * 1000).toISOString(), // 24 hours ago
        endDate: new Date().toISOString(),
        paymentIds,
        options: {
          includeRefunds: true,
          includeDisputes: true,
          includeFailures: true,
          autoResolve: true,
          generateReport: true
        }
      };

      const reconciliationResponse = await apiRequest('POST', '/payments/reconciliation', reconciliationData);
      
      expect(reconciliationResponse.status).toBe(201);
      expect(reconciliationResponse.data).toHaveProperty('reconciliationId');
      expect(reconciliationResponse.data).toHaveProperty('status', 'processing');
      
      testReconciliationId = reconciliationResponse.data.reconciliationId;
      
      // Wait for reconciliation processing
      await new Promise(resolve => setTimeout(resolve, 5000));
      
      // Check reconciliation results
      const resultsResponse = await apiRequest('GET', `/payments/reconciliation/${testReconciliationId}`);
      expect(resultsResponse.status).toBe(200);
      expect(resultsResponse.data).toHaveProperty('summary');
      expect(resultsResponse.data.summary).toHaveProperty('totalPayments');
      expect(resultsResponse.data.summary).toHaveProperty('reconciledAmount');
      expect(resultsResponse.data.summary).toHaveProperty('discrepancies');
      
      console.log(`✅ Payment reconciliation completed: ${testReconciliationId}`);
    });

    /**
     * Lambda Function 4: Multi-Gateway Support
     * Endpoints: POST /api/payments/gateways/{gateway}
     */
    test('should support multiple payment gateways', async () => {
      console.log('🌐 Testing multi-gateway payment support...');
      
      const gateways = ['razorpay', 'stripe', 'payu', 'cashfree'];
      const gatewayResults = [];

      for (const gateway of gateways) {
        try {
          // Configure gateway
          const configResponse = await apiRequest('POST', `/payments/gateways/${gateway}/configure`, {
            schoolId: testSchoolId,
            configuration: {
              merchantId: `test_merchant_${gateway}`,
              apiKey: `test_key_${gateway}`,
              secretKey: `test_secret_${gateway}`,
              environment: 'sandbox',
              features: {
                cardPayments: true,
                netBanking: true,
                upi: true,
                wallets: true,
                emi: true
              },
              webhooks: {
                enabled: true,
                url: `${TEST_CONFIG.apiBaseUrl}/webhooks/${gateway}`,
                events: ['payment.captured', 'payment.failed', 'refund.processed']
              }
            }
          });
          
          expect(configResponse.status).toBe(200);
          
          // Test payment with gateway
          const paymentResponse = await apiRequest('POST', `/payments/gateways/${gateway}`, {
            customerId: testCustomerId,
            amount: 25000, // ₹250.00
            currency: 'INR',
            description: `${gateway} test payment`,
            paymentMethod: {
              type: 'card',
              card: {
                number: '4111111111111111',
                expiryMonth: 12,
                expiryYear: 2025,
                cvv: '123'
              }
            }
          });
          
          expect(paymentResponse.status).toBe(201);
          expect(paymentResponse.data).toHaveProperty('gateway', gateway);
          expect(paymentResponse.data).toHaveProperty('gatewayTransactionId');
          
          gatewayResults.push({
            gateway,
            success: true,
            paymentId: paymentResponse.data.id,
            gatewayTransactionId: paymentResponse.data.gatewayTransactionId
          });
          
        } catch (error) {
          gatewayResults.push({
            gateway,
            success: false,
            error: error instanceof Error ? error.message : String(error)
          });
        }
      }
      
      // Verify at least 2 gateways worked
      const successfulGateways = gatewayResults.filter(r => r.success);
      expect(successfulGateways.length).toBeGreaterThanOrEqual(2);
      
      console.log(`✅ Multi-gateway testing completed: ${successfulGateways.length}/${gateways.length} successful`);
    });

    /**
     * Lambda Function 5: Payment Security & Fraud Detection
     * Endpoint: POST /api/payments/security/validate
     */
    test('should detect and prevent fraudulent payments', async () => {
      console.log('🛡️ Testing payment security and fraud detection...');
      
      // Test legitimate payment
      const legitimatePaymentData = {
        customerId: testCustomerId,
        amount: 80000, // ₹800.00
        currency: 'INR',
        paymentMethodId: testPaymentMethodId,
        description: 'Legitimate payment test',
        metadata: {
          ipAddress: '192.168.1.100',
          userAgent: 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7)',
          timestamp: new Date().toISOString(),
          sessionId: uuidv4()
        }
      };

      const securityValidationResponse = await apiRequest('POST', '/payments/security/validate', legitimatePaymentData);
      
      expect(securityValidationResponse.status).toBe(200);
      expect(securityValidationResponse.data).toHaveProperty('riskScore');
      expect(securityValidationResponse.data.riskScore).toBeLessThan(0.3); // Low risk
      expect(securityValidationResponse.data).toHaveProperty('status', 'approved');
      
      // Test suspicious payment patterns
      const suspiciousPaymentData = {
        customerId: testCustomerId,
        amount: 500000, // ₹5000.00 - large amount
        currency: 'INR',
        paymentMethodId: testPaymentMethodId,
        description: 'Suspicious payment test',
        metadata: {
          ipAddress: '192.168.1.1', // Different IP
          userAgent: 'curl/7.68.0', // Suspicious user agent
          timestamp: new Date().toISOString(),
          sessionId: uuidv4(),
          rapidFireRequest: true,
          velocityPattern: 'high'
        }
      };

      const suspiciousValidationResponse = await apiRequest('POST', '/payments/security/validate', suspiciousPaymentData);
      
      expect(suspiciousValidationResponse.status).toBe(200);
      expect(suspiciousValidationResponse.data).toHaveProperty('riskScore');
      expect(suspiciousValidationResponse.data.riskScore).toBeGreaterThan(0.7); // High risk
      expect(suspiciousValidationResponse.data).toHaveProperty('status', 'flagged');
      expect(suspiciousValidationResponse.data).toHaveProperty('flags');
      expect(suspiciousValidationResponse.data.flags).toContain('high_velocity');
      expect(suspiciousValidationResponse.data.flags).toContain('suspicious_user_agent');
      
      console.log(`✅ Payment security validation completed`);
    });

    /**
     * Lambda Function 6: Payment Method Management
     * Endpoints: GET/PUT/DELETE /api/payments/methods
     */
    test('should manage payment methods with encryption', async () => {
      console.log('💼 Testing payment method management...');
      
      // Create multiple payment methods
      const cardMethodData = {
        customerId: testCustomerId,
        type: 'card',
        card: {
          number: '4111111111111111',
          expiryMonth: 6,
          expiryYear: 2026,
          cvv: '456',
          holderName: 'Test Card Holder'
        },
        isDefault: false
      };

      const netBankingMethodData = {
        customerId: testCustomerId,
        type: 'netbanking',
        netbanking: {
          bankCode: 'SBIN',
          accountType: 'savings'
        },
        isDefault: false
      };

      const upiMethodData = {
        customerId: testCustomerId,
        type: 'upi',
        upi: {
          vpa: 'testuser@paytm'
        },
        isDefault: true
      };

      // Create payment methods
      const cardResponse = await apiRequest('POST', '/payments/methods', cardMethodData);
      const netBankingResponse = await apiRequest('POST', '/payments/methods', netBankingMethodData);
      const upiResponse = await apiRequest('POST', '/payments/methods', upiMethodData);
      
      expect(cardResponse.status).toBe(201);
      expect(netBankingResponse.status).toBe(201);
      expect(upiResponse.status).toBe(201);
      
      const cardMethodId = cardResponse.data.id;
      const upiMethodId = upiResponse.data.id;
      
      // List payment methods
      const listResponse = await apiRequest('GET', `/customers/${testCustomerId}/payment-methods`);
      expect(listResponse.status).toBe(200);
      expect(listResponse.data.length).toBe(3);
      
      // Verify encryption (card numbers should be masked)
      const cardMethod = listResponse.data.find((m: any) => m.type === 'card');
      expect(cardMethod.card.number).toMatch(/\*{12}\d{4}/); // Should be masked
      
      // Update payment method
      const updateData = {
        isDefault: true,
        billingAddress: {
          line1: 'Updated Address',
          city: 'UpdatedCity',
          state: 'UpdatedState',
          pincode: '654321'
        }
      };
      
      const updateResponse = await apiRequest('PUT', `/payments/methods/${cardMethodId}`, updateData);
      expect(updateResponse.status).toBe(200);
      expect(updateResponse.data.isDefault).toBe(true);
      
      // Delete payment method
      const deleteResponse = await apiRequest('DELETE', `/payments/methods/${cardMethodId}`);
      expect(deleteResponse.status).toBe(200);
      
      // Verify deletion
      const listAfterDeleteResponse = await apiRequest('GET', `/customers/${testCustomerId}/payment-methods`);
      expect(listAfterDeleteResponse.data.length).toBe(2);
      
      console.log(`✅ Payment method management completed`);
    });

    afterEach(async () => {
      await cleanupPaymentData();
    });
  });

  /**
   * Story 5.2: Subscription Billing Management Integration Tests
   * Testing 5 Lambda functions for subscription lifecycle management
   */
  describe('Story 5.2: Subscription Billing Management', () => {
    
    beforeEach(async () => {
      await cleanupSubscriptionData();
      
      // Create subscription plan
      const planResponse = await apiRequest('POST', '/subscription-plans', {
        schoolId: testSchoolId,
        name: 'Premium School Plan',
        description: 'Complete school management with premium features',
        pricing: {
          model: 'per_student',
          basePrice: 50000, // ₹500.00 per student per month
          currency: 'INR',
          billingCycle: 'monthly',
          tiers: [
            { min: 1, max: 50, pricePerUnit: 50000 },
            { min: 51, max: 200, pricePerUnit: 45000 },
            { min: 201, max: 1000, pricePerUnit: 40000 }
          ]
        },
        features: {
          studentManagement: true,
          feeManagement: true,
          rfidIntegration: true,
          analyticsReports: true,
          whatsappIntegration: true,
          multipleLocations: true,
          customBranding: true,
          prioritySupport: true
        },
        limits: {
          maxStudents: 1000,
          maxUsers: 100,
          maxLocations: 5,
          storageGB: 100,
          apiCallsPerMonth: 100000
        },
        trial: {
          enabled: true,
          durationDays: 14,
          featuresIncluded: ['studentManagement', 'feeManagement']
        }
      });
      
      testSubscriptionPlanId = planResponse.data.id;
    });

    /**
     * Lambda Function 7: Subscription Creation & Management
     * Endpoint: POST /api/subscriptions
     */
    test('should create and manage subscription lifecycle', async () => {
      console.log('📅 Testing subscription creation and management...');
      
      // Create subscription
      const subscriptionData = {
        schoolId: testSchoolId,
        customerId: testCustomerId,
        planId: testSubscriptionPlanId,
        billingCycle: 'monthly',
        startDate: new Date().toISOString(),
        quantity: 150, // 150 students
        discounts: [
          {
            type: 'percentage',
            value: 10,
            description: 'Early adopter discount',
            validUntil: new Date(Date.now() + 90 * 24 * 60 * 60 * 1000).toISOString()
          }
        ],
        metadata: {
          salesChannel: 'direct',
          referralCode: 'SCHOOL2024',
          contractNumber: 'SCH-2024-001'
        },
        notifications: {
          billingReminders: true,
          usageAlerts: true,
          renewalNotices: true,
          channels: ['email', 'sms', 'whatsapp']
        }
      };

      const subscriptionResponse = await apiRequest('POST', '/subscriptions', subscriptionData);
      
      expect(subscriptionResponse.status).toBe(201);
      expect(subscriptionResponse.data).toHaveProperty('id');
      expect(subscriptionResponse.data).toHaveProperty('status', 'trial');
      expect(subscriptionResponse.data).toHaveProperty('planId', testSubscriptionPlanId);
      expect(subscriptionResponse.data).toHaveProperty('quantity', 150);
      
      testSubscriptionId = subscriptionResponse.data.id;
      
      // Update subscription
      const updateSubData = {
        quantity: 175, // Increase to 175 students
        addons: [
          {
            name: 'additional_storage',
            quantity: 50, // 50GB additional storage
            price: 2000 // ₹20.00 per GB
          }
        ]
      };
      
      const updateSubResponse = await apiRequest('PUT', `/subscriptions/${testSubscriptionId}`, updateSubData);
      expect(updateSubResponse.status).toBe(200);
      expect(updateSubResponse.data.quantity).toBe(175);
      
      // Pause subscription
      const pauseResponse = await apiRequest('POST', `/subscriptions/${testSubscriptionId}/pause`, {
        reason: 'school_vacation',
        pauseUntil: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString(), // 30 days
        prorateBilling: true
      });
      
      expect(pauseResponse.status).toBe(200);
      expect(pauseResponse.data.status).toBe('paused');
      
      // Resume subscription
      const resumeResponse = await apiRequest('POST', `/subscriptions/${testSubscriptionId}/resume`, {
        reason: 'school_reopened',
        adjustBilling: true
      });
      
      expect(resumeResponse.status).toBe(200);
      expect(resumeResponse.data.status).toBe('active');
      
      console.log(`✅ Subscription lifecycle management completed: ${testSubscriptionId}`);
    });

    /**
     * Lambda Function 8: Subscription Billing Automation
     * Endpoint: POST /api/subscriptions/billing/process
     */
    test('should automate subscription billing cycles', async () => {
      console.log('⚙️ Testing subscription billing automation...');
      
      // Create active subscription
      const subscriptionResponse = await apiRequest('POST', '/subscriptions', {
        schoolId: testSchoolId,
        customerId: testCustomerId,
        planId: testSubscriptionPlanId,
        billingCycle: 'monthly',
        quantity: 100,
        autoRenewal: true
      });
      
      testSubscriptionId = subscriptionResponse.data.id;
      
      // Simulate billing cycle processing
      const billingData = {
        subscriptionIds: [testSubscriptionId],
        billingDate: new Date().toISOString(),
        options: {
          generateInvoices: true,
          processPayments: true,
          sendNotifications: true,
          handleFailures: true,
          prorateBilling: true,
          applyDiscounts: true,
          calculateTax: true
        }
      };

      const billingResponse = await apiRequest('POST', '/subscriptions/billing/process', billingData);
      
      expect(billingResponse.status).toBe(200);
      expect(billingResponse.data).toHaveProperty('processed');
      expect(billingResponse.data.processed.length).toBe(1);
      expect(billingResponse.data.processed[0]).toHaveProperty('subscriptionId', testSubscriptionId);
      expect(billingResponse.data.processed[0]).toHaveProperty('invoiceId');
      expect(billingResponse.data.processed[0]).toHaveProperty('paymentId');
      
      // Verify invoice creation
      const {invoiceId} = billingResponse.data.processed[0];
      const invoiceResponse = await apiRequest('GET', `/invoices/${invoiceId}`);
      expect(invoiceResponse.status).toBe(200);
      expect(invoiceResponse.data).toHaveProperty('subscriptionId', testSubscriptionId);
      expect(invoiceResponse.data).toHaveProperty('status', 'sent');
      
      console.log(`✅ Subscription billing automation completed`);
    });

    /**
     * Lambda Function 9: Usage-Based Billing
     * Endpoint: POST /api/subscriptions/usage/track
     */
    test('should track and bill usage-based metrics', async () => {
      console.log('📊 Testing usage-based billing...');
      
      // Create usage-based subscription plan
      const usagePlanResponse = await apiRequest('POST', '/subscription-plans', {
        schoolId: testSchoolId,
        name: 'Usage-Based Plan',
        description: 'Pay-as-you-use school management',
        pricing: {
          model: 'usage_based',
          basePrice: 10000, // ₹100.00 base fee
          currency: 'INR',
          billingCycle: 'monthly',
          usageMetrics: [
            {
              name: 'api_calls',
              price: 1, // ₹0.01 per API call
              includedQuantity: 1000,
              unit: 'request'
            },
            {
              name: 'storage_gb',
              price: 500, // ₹5.00 per GB
              includedQuantity: 10,
              unit: 'gigabyte'
            },
            {
              name: 'whatsapp_messages',
              price: 50, // ₹0.50 per message
              includedQuantity: 100,
              unit: 'message'
            }
          ]
        }
      });

      const usageSubscriptionResponse = await apiRequest('POST', '/subscriptions', {
        schoolId: testSchoolId,
        customerId: testCustomerId,
        planId: usagePlanResponse.data.id,
        billingCycle: 'monthly',
        quantity: 1
      });
      
      const usageSubscriptionId = usageSubscriptionResponse.data.id;
      
      // Track usage events
      const usageEvents = [
        {
          subscriptionId: usageSubscriptionId,
          metric: 'api_calls',
          quantity: 1500,
          timestamp: new Date().toISOString(),
          metadata: { endpoint: '/api/students/list', method: 'GET' }
        },
        {
          subscriptionId: usageSubscriptionId,
          metric: 'storage_gb',
          quantity: 15.5,
          timestamp: new Date().toISOString(),
          metadata: { type: 'document_storage', location: 's3' }
        },
        {
          subscriptionId: usageSubscriptionId,
          metric: 'whatsapp_messages',
          quantity: 250,
          timestamp: new Date().toISOString(),
          metadata: { template: 'payment_reminder', recipient_count: 250 }
        }
      ];

      for (const event of usageEvents) {
        const trackingResponse = await apiRequest('POST', '/subscriptions/usage/track', event);
        expect(trackingResponse.status).toBe(200);
      }
      
      // Get usage summary
      const usageResponse = await apiRequest('GET', `/subscriptions/${usageSubscriptionId}/usage`, {
        startDate: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString(),
        endDate: new Date().toISOString()
      });
      
      expect(usageResponse.status).toBe(200);
      expect(usageResponse.data).toHaveProperty('summary');
      expect(usageResponse.data.summary).toHaveProperty('totalApiCalls', 1500);
      expect(usageResponse.data.summary).toHaveProperty('totalStorageGB', 15.5);
      expect(usageResponse.data.summary).toHaveProperty('totalWhatsappMessages', 250);
      expect(usageResponse.data).toHaveProperty('billing');
      expect(usageResponse.data.billing).toHaveProperty('overage');
      
      console.log(`✅ Usage-based billing completed`);
    });

    /**
     * Lambda Function 10: Subscription Analytics
     * Endpoint: GET /api/subscription-plans/{id}/analytics
     */
    test('should provide subscription analytics and insights', async () => {
      console.log('📈 Testing subscription analytics...');
      
      // Get subscription plan analytics
      const analyticsResponse = await apiRequest('GET', `/subscription-plans/${testSubscriptionPlanId}/analytics`, {
        timeframe: 'last_30_days',
        metrics: [
          'subscriber_count',
          'revenue',
          'churn_rate',
          'customer_lifetime_value',
          'trial_conversion_rate',
          'usage_patterns',
          'feature_adoption'
        ],
        segmentation: {
          byTier: true,
          byRegion: true,
          bySchoolSize: true,
          byUsagePattern: true
        }
      });
      
      expect(analyticsResponse.status).toBe(200);
      expect(analyticsResponse.data).toHaveProperty('metrics');
      expect(analyticsResponse.data.metrics).toHaveProperty('subscriberCount');
      expect(analyticsResponse.data.metrics).toHaveProperty('totalRevenue');
      expect(analyticsResponse.data.metrics).toHaveProperty('churnRate');
      expect(analyticsResponse.data.metrics).toHaveProperty('averageLifetimeValue');
      expect(analyticsResponse.data).toHaveProperty('segmentation');
      expect(analyticsResponse.data).toHaveProperty('trends');
      expect(analyticsResponse.data).toHaveProperty('recommendations');
      
      console.log(`✅ Subscription analytics completed`);
    });

    /**
     * Lambda Function 11: Subscription Dunning Management
     * Endpoint: POST /api/subscriptions/dunning/process
     */
    test('should handle subscription dunning and recovery', async () => {
      console.log('💰 Testing subscription dunning management...');
      
      // Create subscription with payment failure simulation
      const subscriptionResponse = await apiRequest('POST', '/subscriptions', {
        schoolId: testSchoolId,
        customerId: testCustomerId,
        planId: testSubscriptionPlanId,
        billingCycle: 'monthly',
        quantity: 75,
        simulate: {
          paymentFailure: true,
          failureReason: 'card_declined'
        }
      });
      
      testSubscriptionId = subscriptionResponse.data.id;
      
      // Wait for payment failure
      await new Promise(resolve => setTimeout(resolve, 2000));
      
      // Process dunning
      const dunningData = {
        subscriptionIds: [testSubscriptionId],
        dunningConfig: {
          maxAttempts: 4,
          retrySchedule: [1, 3, 7, 14], // Days
          escalationActions: [
            { day: 1, action: 'email_reminder' },
            { day: 3, action: 'sms_reminder' },
            { day: 7, action: 'phone_call' },
            { day: 14, action: 'account_suspension' }
          ],
          gracePeriod: 3,
          autoRecovery: true
        }
      };

      const dunningResponse = await apiRequest('POST', '/subscriptions/dunning/process', dunningData);
      
      expect(dunningResponse.status).toBe(200);
      expect(dunningResponse.data).toHaveProperty('processed');
      expect(dunningResponse.data.processed.length).toBe(1);
      expect(dunningResponse.data.processed[0]).toHaveProperty('subscriptionId', testSubscriptionId);
      expect(dunningResponse.data.processed[0]).toHaveProperty('dunningStatus', 'initiated');
      expect(dunningResponse.data.processed[0]).toHaveProperty('nextAttemptDate');
      
      // Check dunning status
      const statusResponse = await apiRequest('GET', `/subscriptions/${testSubscriptionId}/dunning`);
      expect(statusResponse.status).toBe(200);
      expect(statusResponse.data).toHaveProperty('attemptCount');
      expect(statusResponse.data).toHaveProperty('lastAttemptDate');
      expect(statusResponse.data).toHaveProperty('nextAttemptDate');
      expect(statusResponse.data).toHaveProperty('escalationLevel');
      
      console.log(`✅ Subscription dunning management completed`);
    });

    afterEach(async () => {
      await cleanupSubscriptionData();
    });
  });

  /**
   * Story 5.3: Automated Invoice Generation Integration Tests
   * Testing 5 Lambda functions for comprehensive invoice management
   */
  describe('Story 5.3: Automated Invoice Generation', () => {
    
    beforeEach(async () => {
      await cleanupInvoiceData();
      
      // Create invoice template
      const templateResponse = await apiRequest('POST', '/invoice-templates', {
        schoolId: testSchoolId,
        name: 'Standard Payment Invoice',
        type: 'payment',
        design: {
          theme: 'professional',
          colors: {
            primary: '#2563eb',
            secondary: '#64748b',
            accent: '#f59e0b'
          },
          logo: {
            url: 'https://example.com/school-logo.png',
            position: 'top-left',
            size: 'medium'
          },
          layout: 'standard'
        },
        content: {
          header: {
            schoolName: '{{school.name}}',
            schoolAddress: '{{school.address}}',
            contactInfo: '{{school.phone}} | {{school.email}}'
          },
          invoice: {
            title: 'Payment Invoice',
            numberFormat: 'INV-{{year}}-{{month}}-{{sequence}}',
            dateFormat: 'DD/MM/YYYY',
            dueDate: 'Due in {{dueDays}} days'
          },
          footer: {
            thankYouNote: 'Thank you for your payment!',
            terms: 'Payment is due within {{dueDays}} days of invoice date.',
            support: 'For queries, contact {{school.supportEmail}}'
          }
        },
        fields: {
          required: ['studentName', 'class', 'feeType', 'amount', 'dueDate'],
          optional: ['discount', 'lateFee', 'notes'],
          custom: ['parentName', 'parentPhone', 'studentId']
        },
        automation: {
          autoSend: true,
          sendOn: 'creation',
          reminders: {
            enabled: true,
            schedule: [7, 3, 1], // Days before due date
            channels: ['email', 'sms']
          }
        }
      });
      
      testInvoiceTemplateId = templateResponse.data.id;
    });

    /**
     * Lambda Function 12: Automated Invoice Generation
     * Endpoint: POST /api/invoices/generate
     */
    test('should generate invoices automatically from payments', async () => {
      console.log('📄 Testing automated invoice generation...');
      
      // Create payment that should trigger invoice generation
      const paymentData = {
        customerId: testCustomerId,
        amount: 125000, // ₹1250.00
        currency: 'INR',
        paymentMethodId: testPaymentMethodId,
        description: 'School fees - Q1 2024',
        metadata: {
          studentId: testStudentId,
          feeType: 'tuition',
          term: 'Q1-2024',
          class: '10th Grade',
          section: 'A'
        },
        invoice: {
          generate: true,
          templateId: testInvoiceTemplateId,
          dueDate: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString(), // 30 days
          lineItems: [
            {
              description: 'Tuition Fee - Q1 2024',
              quantity: 1,
              unitPrice: 100000, // ₹1000.00
              taxRate: 0.18,
              discounts: []
            },
            {
              description: 'Activity Fee',
              quantity: 1,
              unitPrice: 25000, // ₹250.00
              taxRate: 0.18,
              discounts: []
            }
          ]
        }
      };

      const paymentResponse = await apiRequest('POST', '/payments/advanced', paymentData);
      testPaymentId = paymentResponse.data.id;
      
      // Wait for invoice generation
      await new Promise(resolve => setTimeout(resolve, 3000));
      
      // Check generated invoice
      const invoicesResponse = await apiRequest('GET', '/invoices', {
        paymentId: testPaymentId
      });
      
      expect(invoicesResponse.status).toBe(200);
      expect(invoicesResponse.data.length).toBe(1);
      
      const invoice = invoicesResponse.data[0];
      testInvoiceId = invoice.id;
      
      expect(invoice).toHaveProperty('paymentId', testPaymentId);
      expect(invoice).toHaveProperty('templateId', testInvoiceTemplateId);
      expect(invoice).toHaveProperty('status', 'sent');
      expect(invoice).toHaveProperty('totalAmount', 125000);
      expect(invoice).toHaveProperty('lineItems');
      expect(invoice.lineItems.length).toBe(2);
      
      // Verify PDF generation
      const pdfResponse = await apiRequest('GET', `/invoices/${testInvoiceId}/pdf`);
      expect(pdfResponse.status).toBe(200);
      expect(pdfResponse.headers['content-type']).toContain('application/pdf');
      
      console.log(`✅ Automated invoice generation completed: ${testInvoiceId}`);
    });

    /**
     * Lambda Function 13: Invoice Template Management
     * Endpoints: GET/PUT/DELETE /api/invoice-templates
     */
    test('should manage invoice templates with customization', async () => {
      console.log('📝 Testing invoice template management...');
      
      // Get template
      const getTemplateResponse = await apiRequest('GET', `/invoice-templates/${testInvoiceTemplateId}`);
      expect(getTemplateResponse.status).toBe(200);
      expect(getTemplateResponse.data).toHaveProperty('name', 'Standard Payment Invoice');
      
      // Update template
      const updateData = {
        name: 'Updated Payment Invoice Template',
        design: {
          theme: 'modern',
          colors: {
            primary: '#059669',
            secondary: '#6b7280',
            accent: '#dc2626'
          }
        },
        content: {
          header: {
            schoolName: '{{school.name}} - Updated',
            schoolAddress: '{{school.fullAddress}}',
            contactInfo: 'Email: {{school.email}} | Phone: {{school.phone}}'
          }
        },
        automation: {
          autoSend: true,
          sendOn: 'payment_confirmation',
          reminders: {
            enabled: true,
            schedule: [10, 5, 2, 1], // More frequent reminders
            channels: ['email', 'sms', 'whatsapp']
          }
        }
      };
      
      const updateTemplateResponse = await apiRequest('PUT', `/invoice-templates/${testInvoiceTemplateId}`, updateData);
      expect(updateTemplateResponse.status).toBe(200);
      expect(updateTemplateResponse.data.name).toBe('Updated Payment Invoice Template');
      expect(updateTemplateResponse.data.design.theme).toBe('modern');
      
      // Test template preview
      const previewData = {
        templateId: testInvoiceTemplateId,
        sampleData: {
          school: {
            name: 'Preview Test School',
            address: '123 Preview Street',
            phone: '+91-9999999999',
            email: 'preview@school.com'
          },
          student: {
            name: 'Preview Student',
            class: '10th Grade',
            rollNumber: 'PV001'
          },
          payment: {
            amount: 50000,
            dueDate: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000).toISOString()
          }
        }
      };
      
      const previewResponse = await apiRequest('POST', `/invoice-templates/${testInvoiceTemplateId}/preview`, previewData);
      expect(previewResponse.status).toBe(200);
      expect(previewResponse.data).toHaveProperty('previewUrl');
      expect(previewResponse.data).toHaveProperty('generatedHtml');
      
      console.log(`✅ Invoice template management completed`);
    });

    /**
     * Lambda Function 14: Bulk Invoice Processing
     * Endpoint: POST /api/invoices/bulk/generate
     */
    test('should process bulk invoice generation efficiently', async () => {
      console.log('📦 Testing bulk invoice processing...');
      
      // Create multiple test students for bulk processing
      const studentIds = [];
      for (let i = 0; i < 10; i++) {
        const studentResponse = await apiRequest('POST', '/users', {
          email: `bulkstudent${i}@payment-test.com`,
          firstName: `BulkStudent${i}`,
          lastName: 'TestSurname',
          role: 'STUDENT',
          schoolId: testSchoolId,
          profile: {
            class: '10th Grade',
            section: 'B',
            rollNumber: `BLK${String(i + 1).padStart(3, '0')}`,
            parentId: testParentId
          }
        });
        studentIds.push(studentResponse.data.id);
      }
      
      // Bulk invoice generation
      const bulkData = {
        schoolId: testSchoolId,
        templateId: testInvoiceTemplateId,
        invoices: studentIds.map((studentId, index) => ({
          customerId: testCustomerId,
          studentId,
          amount: 75000 + (index * 5000), // Varying amounts
          currency: 'INR',
          description: `Bulk payment ${index + 1} - School fees`,
          dueDate: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString(),
          lineItems: [
            {
              description: 'Tuition Fee',
              quantity: 1,
              unitPrice: 65000 + (index * 5000),
              taxRate: 0.18
            },
            {
              description: 'Activity Fee',
              quantity: 1,
              unitPrice: 10000,
              taxRate: 0.18
            }
          ],
          metadata: {
            feeType: 'quarterly',
            term: 'Q1-2024',
            batch: `bulk_${Date.now()}`
          }
        })),
        options: {
          processAsync: true,
          batchSize: 5,
          generatePDF: true,
          sendNotifications: true,
          createPaymentIntents: true
        }
      };

      const bulkResponse = await apiRequest('POST', '/invoices/bulk/generate', bulkData);
      
      expect(bulkResponse.status).toBe(202); // Accepted for async processing
      expect(bulkResponse.data).toHaveProperty('batchId');
      expect(bulkResponse.data).toHaveProperty('totalInvoices', 10);
      expect(bulkResponse.data).toHaveProperty('estimatedCompletionTime');
      
      const {batchId} = bulkResponse.data;
      
      // Poll for completion
      let batchComplete = false;
      let pollAttempts = 0;
      const maxPollAttempts = 10;
      
      while (!batchComplete && pollAttempts < maxPollAttempts) {
        await new Promise(resolve => setTimeout(resolve, 2000));
        
        const statusResponse = await apiRequest('GET', `/invoices/bulk/status/${batchId}`);
        expect(statusResponse.status).toBe(200);
        
        if (statusResponse.data.status === 'completed') {
          batchComplete = true;
          expect(statusResponse.data).toHaveProperty('results');
          expect(statusResponse.data.results).toHaveProperty('successful', 10);
          expect(statusResponse.data.results).toHaveProperty('failed', 0);
          expect(statusResponse.data).toHaveProperty('invoiceIds');
          expect(statusResponse.data.invoiceIds.length).toBe(10);
        }
        
        pollAttempts++;
      }
      
      expect(batchComplete).toBe(true);
      console.log(`✅ Bulk invoice processing completed: ${batchId}`);
    });

    afterEach(async () => {
      await cleanupInvoiceData();
    });
  });

  /**
   * Story 5.4: AI-Powered Payment Analytics & Reporting Integration Tests
   * Testing 5 Lambda functions for analytics, reporting, and business intelligence
   */
  describe('Story 5.4: AI-Powered Payment Analytics & Reporting', () => {
    
    beforeEach(async () => {
      await seedAnalyticsData();
    });

    /**
     * Lambda Function 15: Payment Analytics Engine
     * Endpoint: GET /api/analytics/payments
     */
    test('should generate comprehensive payment analytics', async () => {
      console.log('📊 Testing payment analytics engine...');
      
      const analyticsQuery = {
        schoolId: testSchoolId,
        timeframe: {
          start: new Date(Date.now() - 90 * 24 * 60 * 60 * 1000).toISOString(), // 90 days ago
          end: new Date().toISOString(),
          granularity: 'daily'
        },
        metrics: [
          'total_revenue',
          'payment_volume',
          'success_rate',
          'average_transaction_value',
          'payment_method_distribution',
          'customer_segments',
          'geographic_distribution',
          'time_patterns',
          'failure_analysis',
          'churn_indicators'
        ],
        segments: {
          byPaymentMethod: true,
          byCustomerTier: true,
          byGeography: true,
          byTimeOfDay: true,
          byDayOfWeek: true,
          byFeeType: true
        },
        filters: {
          minAmount: 1000,
          maxAmount: 1000000,
          paymentMethods: ['card', 'upi', 'netbanking'],
          customerTypes: ['parent', 'school'],
          includeRefunds: false
        }
      };

      const analyticsResponse = await apiRequest('POST', '/analytics/payments', analyticsQuery);
      
      expect(analyticsResponse.status).toBe(200);
      expect(analyticsResponse.data).toHaveProperty('summary');
      expect(analyticsResponse.data.summary).toHaveProperty('totalRevenue');
      expect(analyticsResponse.data.summary).toHaveProperty('paymentVolume');
      expect(analyticsResponse.data.summary).toHaveProperty('successRate');
      expect(analyticsResponse.data.summary).toHaveProperty('averageTransactionValue');
      
      expect(analyticsResponse.data).toHaveProperty('timeSeries');
      expect(analyticsResponse.data.timeSeries.length).toBeGreaterThan(0);
      
      expect(analyticsResponse.data).toHaveProperty('segments');
      expect(analyticsResponse.data.segments).toHaveProperty('paymentMethods');
      expect(analyticsResponse.data.segments).toHaveProperty('customerTiers');
      expect(analyticsResponse.data.segments).toHaveProperty('geography');
      
      expect(analyticsResponse.data).toHaveProperty('insights');
      expect(analyticsResponse.data.insights).toHaveProperty('trends');
      expect(analyticsResponse.data.insights).toHaveProperty('anomalies');
      expect(analyticsResponse.data.insights).toHaveProperty('recommendations');
      
      console.log(`✅ Payment analytics engine completed`);
    });

    /**
     * Lambda Function 16: Revenue Forecasting
     * Endpoint: POST /api/analytics/revenue/forecast
     */
    test('should generate AI-powered revenue forecasts', async () => {
      console.log('🔮 Testing AI-powered revenue forecasting...');
      
      const forecastRequest = {
        schoolId: testSchoolId,
        forecastPeriod: {
          duration: 12, // 12 months
          unit: 'months',
          granularity: 'monthly'
        },
        models: {
          primary: 'lstm_neural_network',
          secondary: 'arima',
          ensemble: true
        },
        factors: {
          seasonality: true,
          trends: true,
          externalFactors: [
            'academic_calendar',
            'economic_indicators',
            'competitive_landscape',
            'demographic_changes'
          ],
          promotions: true,
          churnPrediction: true
        },
        scenarios: {
          baseline: true,
          optimistic: true,
          pessimistic: true,
          customScenarios: [
            {
              name: 'new_campus_expansion',
              assumptions: {
                studentGrowth: 0.25,
                feeIncrease: 0.1,
                additionalCosts: 500000
              }
            }
          ]
        },
        confidence: {
          intervals: [0.8, 0.9, 0.95],
          includeUncertainty: true
        }
      };

      const forecastResponse = await apiRequest('POST', '/analytics/revenue/forecast', forecastRequest);
      
      expect(forecastResponse.status).toBe(200);
      expect(forecastResponse.data).toHaveProperty('forecast');
      expect(forecastResponse.data.forecast).toHaveProperty('baseline');
      expect(forecastResponse.data.forecast).toHaveProperty('optimistic');
      expect(forecastResponse.data.forecast).toHaveProperty('pessimistic');
      
      expect(forecastResponse.data).toHaveProperty('models');
      expect(forecastResponse.data.models).toHaveProperty('primary');
      expect(forecastResponse.data.models.primary).toHaveProperty('accuracy');
      expect(forecastResponse.data.models.primary.accuracy).toBeGreaterThan(0.7);
      
      expect(forecastResponse.data).toHaveProperty('factors');
      expect(forecastResponse.data.factors).toHaveProperty('seasonalityImpact');
      expect(forecastResponse.data.factors).toHaveProperty('trendAnalysis');
      
      expect(forecastResponse.data).toHaveProperty('recommendations');
      expect(forecastResponse.data.recommendations.length).toBeGreaterThan(0);
      
      console.log(`✅ Revenue forecasting completed`);
    });

    /**
     * Lambda Function 17: Customer Lifetime Value (CLV) Analysis
     * Endpoint: GET /api/analytics/clv/{customerId}
     */
    test('should calculate customer lifetime value with predictive modeling', async () => {
      console.log('💎 Testing customer lifetime value analysis...');
      
      const clvRequest = {
        customerId: testCustomerId,
        timeframe: 'all_time',
        predictionHorizon: {
          duration: 24,
          unit: 'months'
        },
        factors: {
          paymentHistory: true,
          engagementMetrics: true,
          supportInteractions: true,
          featureUsage: true,
          churnProbability: true
        },
        segmentation: {
          byTier: true,
          bySchoolSize: true,
          byPaymentBehavior: true,
          byEngagement: true
        },
        models: {
          historicalCLV: true,
          predictiveCLV: true,
          cohortAnalysis: true,
          rfmAnalysis: true
        }
      };

      const clvResponse = await apiRequest('POST', `/analytics/clv/${testCustomerId}`, clvRequest);
      
      expect(clvResponse.status).toBe(200);
      expect(clvResponse.data).toHaveProperty('customerId', testCustomerId);
      expect(clvResponse.data).toHaveProperty('historicalClv');
      expect(clvResponse.data.historicalClv).toHaveProperty('totalRevenue');
      expect(clvResponse.data.historicalClv).toHaveProperty('averageOrderValue');
      expect(clvResponse.data.historicalClv).toHaveProperty('purchaseFrequency');
      expect(clvResponse.data.historicalClv).toHaveProperty('customerLifespan');
      
      expect(clvResponse.data).toHaveProperty('predictiveClv');
      expect(clvResponse.data.predictiveClv).toHaveProperty('predictedValue');
      expect(clvResponse.data.predictiveClv).toHaveProperty('confidenceInterval');
      expect(clvResponse.data.predictiveClv).toHaveProperty('churnProbability');
      
      expect(clvResponse.data).toHaveProperty('segmentation');
      expect(clvResponse.data.segmentation).toHaveProperty('tier');
      expect(clvResponse.data.segmentation).toHaveProperty('behavior');
      
      expect(clvResponse.data).toHaveProperty('recommendations');
      expect(clvResponse.data.recommendations).toHaveProperty('retentionStrategies');
      expect(clvResponse.data.recommendations).toHaveProperty('upsellOpportunities');
      
      console.log(`✅ Customer lifetime value analysis completed`);
    });

    /**
     * Lambda Function 18: Churn Prediction & Prevention
     * Endpoint: GET /api/analytics/churn/predict
     */
    test('should predict customer churn with prevention strategies', async () => {
      console.log('🔍 Testing churn prediction and prevention...');
      
      const churnRequest = {
        schoolId: testSchoolId,
        analysisType: 'comprehensive',
        timeframe: {
          training: '12_months',
          prediction: '6_months'
        },
        features: {
          paymentBehavior: true,
          usagePatterns: true,
          supportInteractions: true,
          featureAdoption: true,
          engagementMetrics: true,
          seasonalFactors: true
        },
        models: {
          primary: 'gradient_boosting',
          secondary: 'random_forest',
          ensemble: true
        },
        segments: {
          riskLevel: ['low', 'medium', 'high', 'critical'],
          customerType: ['new', 'growing', 'mature', 'declining'],
          schoolSize: ['small', 'medium', 'large', 'enterprise']
        },
        interventions: {
          generateStrategies: true,
          personalizeRecommendations: true,
          prioritizeActions: true,
          estimateImpact: true
        }
      };

      const churnResponse = await apiRequest('POST', '/analytics/churn/predict', churnRequest);
      
      expect(churnResponse.status).toBe(200);
      expect(churnResponse.data).toHaveProperty('predictions');
      expect(churnResponse.data.predictions).toHaveProperty('overall');
      expect(churnResponse.data.predictions.overall).toHaveProperty('churnRate');
      expect(churnResponse.data.predictions.overall).toHaveProperty('confidenceScore');
      
      expect(churnResponse.data).toHaveProperty('riskSegments');
      expect(churnResponse.data.riskSegments).toHaveProperty('high');
      expect(churnResponse.data.riskSegments).toHaveProperty('medium');
      expect(churnResponse.data.riskSegments).toHaveProperty('low');
      
      expect(churnResponse.data).toHaveProperty('features');
      expect(churnResponse.data.features).toHaveProperty('importance');
      expect(churnResponse.data.features.importance.length).toBeGreaterThan(0);
      
      expect(churnResponse.data).toHaveProperty('interventions');
      expect(churnResponse.data.interventions).toHaveProperty('strategies');
      expect(churnResponse.data.interventions.strategies.length).toBeGreaterThan(0);
      
      // Test intervention execution
      const interventionResponse = await apiRequest('POST', '/analytics/churn/interventions', {
        customerId: testCustomerId,
        strategies: churnResponse.data.interventions.strategies.slice(0, 2), // Top 2 strategies
        schedule: {
          immediate: ['personalized_offer'],
          delayed: ['engagement_campaign']
        }
      });
      
      expect(interventionResponse.status).toBe(200);
      expect(interventionResponse.data).toHaveProperty('executed');
      expect(interventionResponse.data.executed.length).toBeGreaterThan(0);
      
      console.log(`✅ Churn prediction and prevention completed`);
    });

    /**
     * Lambda Function 19: Financial Reporting & Compliance
     * Endpoint: GET /api/reports/financial
     */
    test('should generate comprehensive financial reports', async () => {
      console.log('📋 Testing financial reporting and compliance...');
      
      const reportRequest = {
        schoolId: testSchoolId,
        reportType: 'comprehensive_financial',
        timeframe: {
          start: new Date(Date.now() - 90 * 24 * 60 * 60 * 1000).toISOString(), // 90 days
          end: new Date().toISOString(),
          comparePrevious: true
        },
        sections: {
          revenueAnalysis: true,
          paymentAnalysis: true,
          subscriptionAnalysis: true,
          refundAnalysis: true,
          taxAnalysis: true,
          complianceCheck: true,
          forecasting: true,
          recommendations: true
        },
        formats: ['pdf', 'excel', 'json'],
        compliance: {
          standards: ['GST', 'IFRS', 'GAAP'],
          auditTrail: true,
          digitalSignature: true,
          watermark: true
        },
        distribution: {
          recipients: ['finance@school.com', 'admin@school.com'],
          schedule: {
            frequency: 'monthly',
            dayOfMonth: 1,
            timezone: 'Asia/Kolkata'
          },
          secure: true
        }
      };

      const reportResponse = await apiRequest('POST', '/reports/financial', reportRequest);
      
      expect(reportResponse.status).toBe(200);
      expect(reportResponse.data).toHaveProperty('reportId');
      expect(reportResponse.data).toHaveProperty('status', 'generated');
      expect(reportResponse.data).toHaveProperty('sections');
      
      const {reportId} = reportResponse.data;
      
      // Verify report sections
      expect(reportResponse.data.sections).toHaveProperty('revenueAnalysis');
      expect(reportResponse.data.sections.revenueAnalysis).toHaveProperty('totalRevenue');
      expect(reportResponse.data.sections.revenueAnalysis).toHaveProperty('revenueGrowth');
      
      expect(reportResponse.data.sections).toHaveProperty('paymentAnalysis');
      expect(reportResponse.data.sections.paymentAnalysis).toHaveProperty('successRate');
      expect(reportResponse.data.sections.paymentAnalysis).toHaveProperty('failureReasons');
      
      expect(reportResponse.data.sections).toHaveProperty('complianceCheck');
      expect(reportResponse.data.sections.complianceCheck).toHaveProperty('gstCompliance');
      expect(reportResponse.data.sections.complianceCheck).toHaveProperty('auditReadiness');
      
      // Download report in different formats
      const pdfResponse = await apiRequest('GET', `/reports/${reportId}/download`, {
        format: 'pdf'
      });
      expect(pdfResponse.status).toBe(200);
      
      const excelResponse = await apiRequest('GET', `/reports/${reportId}/download`, {
        format: 'excel'
      });
      expect(excelResponse.status).toBe(200);
      
      console.log(`✅ Financial reporting completed: ${reportId}`);
    });

    /**
     * Lambda Function 20: Fraud Detection & Risk Assessment
     * Endpoint: POST /api/analytics/fraud/detect
     */
    test('should detect fraud patterns with machine learning', async () => {
      console.log('🕵️ Testing fraud detection and risk assessment...');
      
      // Create suspicious transaction patterns
      const suspiciousPatterns = [
        {
          customerId: testCustomerId,
          amount: 999999, // Very high amount
          frequency: 'rapid', // Multiple transactions quickly
          location: 'unusual', // Different location
          device: 'new', // New device
          behavior: 'anomalous'
        }
      ];

      const fraudDetectionRequest = {
        schoolId: testSchoolId,
        analysisType: 'real_time',
        transactions: suspiciousPatterns,
        models: {
          rulesBased: true,
          machineLearning: true,
          anomalyDetection: true,
          networkAnalysis: true
        },
        sensitivity: 'high',
        features: [
          'transaction_amount',
          'transaction_frequency',
          'device_fingerprint',
          'ip_geolocation',
          'user_behavior',
          'time_patterns',
          'network_analysis',
          'velocity_checking'
        ],
        response: {
          realTimeBlocking: true,
          alertGeneration: true,
          riskScoring: true,
          recommendActions: true
        }
      };

      const fraudResponse = await apiRequest('POST', '/analytics/fraud/detect', fraudDetectionRequest);
      
      expect(fraudResponse.status).toBe(200);
      expect(fraudResponse.data).toHaveProperty('results');
      expect(fraudResponse.data.results.length).toBe(1);
      
      const fraudResult = fraudResponse.data.results[0];
      expect(fraudResult).toHaveProperty('riskScore');
      expect(fraudResult.riskScore).toBeGreaterThan(0.8); // High risk
      expect(fraudResult).toHaveProperty('riskLevel', 'high');
      expect(fraudResult).toHaveProperty('flags');
      expect(fraudResult.flags).toContain('unusual_amount');
      expect(fraudResult.flags).toContain('high_velocity');
      
      expect(fraudResult).toHaveProperty('recommendation');
      expect(fraudResult.recommendation).toHaveProperty('action', 'block');
      expect(fraudResult.recommendation).toHaveProperty('confidence');
      
      expect(fraudResponse.data).toHaveProperty('models');
      expect(fraudResponse.data.models).toHaveProperty('consensus');
      expect(fraudResponse.data.models).toHaveProperty('individual');
      
      // Test fraud pattern learning
      const learningResponse = await apiRequest('POST', '/analytics/fraud/learn', {
        transactionId: 'suspicious_transaction_123',
        actualFraud: true,
        feedbackType: 'confirmed_fraud',
        metadata: {
          investigationId: uuidv4(),
          confirmedBy: 'security_team',
          evidenceType: 'chargeback_received'
        }
      });
      
      expect(learningResponse.status).toBe(200);
      expect(learningResponse.data).toHaveProperty('modelUpdated', true);
      
      console.log(`✅ Fraud detection completed`);
    });

    /**
     * Lambda Function 21: Performance Monitoring & Optimization
     * Endpoint: GET /api/analytics/performance/payments
     */
    test('should monitor payment system performance', async () => {
      console.log('⚡ Testing payment performance monitoring...');
      
      // Perform load test on payment endpoints
      const loadTestResults = await performLoadTest(
        'Payment Processing Load Test',
        async () => {
          const response = await apiRequest('POST', '/payments/advanced', {
            customerId: testCustomerId,
            amount: Math.floor(Math.random() * 100000) + 10000, // Random amount
            currency: 'INR',
            paymentMethodId: testPaymentMethodId,
            description: 'Load test payment'
          });
          return response;
        },
        {
          concurrency: 25,
          duration: 30000, // 30 seconds
          rampUp: 5000
        }
      );

      // Verify performance metrics
      expect(loadTestResults.requestsCompleted).toBeGreaterThan(20);
      expect(loadTestResults.averageResponseTime).toBeLessThan(TEST_CONFIG.performanceThresholds.responseTime);
      expect(loadTestResults.errorRate).toBeLessThan(TEST_CONFIG.performanceThresholds.errorRate);
      expect(loadTestResults.throughput).toBeGreaterThan(TEST_CONFIG.performanceThresholds.throughput);
      
      // Get performance analytics
      const performanceRequest = {
        schoolId: testSchoolId,
        timeframe: {
          start: new Date(Date.now() - 60 * 60 * 1000).toISOString(), // Last hour
          end: new Date().toISOString(),
          granularity: 'minute'
        },
        metrics: [
          'response_time',
          'throughput',
          'error_rate',
          'success_rate',
          'gateway_performance',
          'database_performance',
          'cache_performance',
          'queue_performance'
        ],
        analysis: {
          percentiles: [50, 90, 95, 99],
          trending: true,
          anomalies: true,
          bottlenecks: true,
          optimization: true
        }
      };

      const performanceResponse = await apiRequest('POST', '/analytics/performance/payments', performanceRequest);
      
      expect(performanceResponse.status).toBe(200);
      expect(performanceResponse.data).toHaveProperty('metrics');
      expect(performanceResponse.data.metrics).toHaveProperty('responseTime');
      expect(performanceResponse.data.metrics.responseTime).toHaveProperty('p95');
      expect(performanceResponse.data.metrics.responseTime.p95).toBeLessThan(3000);
      
      expect(performanceResponse.data).toHaveProperty('bottlenecks');
      expect(performanceResponse.data).toHaveProperty('recommendations');
      expect(performanceResponse.data.recommendations.length).toBeGreaterThan(0);
      
      console.log(`✅ Performance monitoring completed`);
      console.log(`📊 Load test results: ${loadTestResults.requestsCompleted} requests, ${loadTestResults.averageResponseTime}ms avg response time`);
    });

    afterEach(async () => {
      await cleanupAnalyticsData();
    });
  });

  /**
   * Cross-Story Integration Tests
   * Testing interactions between all 4 payment stories
   */
  describe('Cross-Story Integration Tests', () => {
    
    test('should handle complete payment ecosystem workflow', async () => {
      console.log('🌟 Testing complete payment ecosystem integration...');
      
      // Step 1: Set up subscription with trial
      const subscriptionResponse = await apiRequest('POST', '/subscriptions', {
        schoolId: testSchoolId,
        customerId: testCustomerId,
        planId: testSubscriptionPlanId,
        billingCycle: 'monthly',
        quantity: 200,
        trial: {
          enabled: true,
          durationDays: 14
        }
      });
      
      testSubscriptionId = subscriptionResponse.data.id;
      
      // Step 2: Process one-time payment during trial
      const paymentResponse = await apiRequest('POST', '/payments/advanced', {
        customerId: testCustomerId,
        amount: 200000, // ₹2000.00
        currency: 'INR',
        paymentMethodId: testPaymentMethodId,
        description: 'One-time setup fee',
        metadata: {
          subscriptionId: testSubscriptionId,
          paymentType: 'setup_fee'
        }
      });
      
      testPaymentId = paymentResponse.data.id;
      
      // Step 3: Generate invoice for payment
      const invoiceResponse = await apiRequest('POST', '/invoices/generate', {
        paymentId: testPaymentId,
        templateId: testInvoiceTemplateId,
        options: {
          sendImmediately: true,
          includeTax: true,
          watermark: true
        }
      });
      
      testInvoiceId = invoiceResponse.data.id;
      
      // Step 4: Convert trial to paid subscription
      const conversionResponse = await apiRequest('POST', `/subscriptions/${testSubscriptionId}/convert`, {
        reason: 'trial_completed',
        billingCycle: 'monthly',
        discounts: [
          {
            type: 'percentage',
            value: 15,
            description: 'Trial conversion discount',
            durationMonths: 3
          }
        ]
      });
      
      expect(conversionResponse.status).toBe(200);
      expect(conversionResponse.data.status).toBe('active');
      
      // Step 5: Generate analytics report
      const analyticsResponse = await apiRequest('POST', '/analytics/payments', {
        schoolId: testSchoolId,
        timeframe: {
          start: new Date(Date.now() - 24 * 60 * 60 * 1000).toISOString(),
          end: new Date().toISOString()
        },
        includeSubscriptions: true,
        includeOneTimePayments: true
      });
      
      expect(analyticsResponse.status).toBe(200);
      expect(analyticsResponse.data.summary.totalRevenue).toBeGreaterThan(0);
      
      // Step 6: Verify audit trail across all systems
      const auditResponse = await apiRequest('GET', '/audit/ecosystem', {
        entityId: testCustomerId,
        entityType: 'customer',
        timeframe: {
          start: new Date(Date.now() - 24 * 60 * 60 * 1000).toISOString(),
          end: new Date().toISOString()
        },
        includeRelated: true
      });
      
      expect(auditResponse.status).toBe(200);
      expect(auditResponse.data).toHaveProperty('events');
      expect(auditResponse.data.events.length).toBeGreaterThan(5); // Multiple system interactions
      
      // Verify event types
      const eventTypes = auditResponse.data.events.map((e: any) => e.eventType);
      expect(eventTypes).toContain('subscription_created');
      expect(eventTypes).toContain('payment_processed');
      expect(eventTypes).toContain('invoice_generated');
      expect(eventTypes).toContain('subscription_converted');
      
      console.log(`✅ Complete payment ecosystem workflow completed`);
    });

    test('should handle payment failure and recovery across systems', async () => {
      console.log('🔄 Testing payment failure recovery across ecosystem...');
      
      // Create subscription with payment method that will fail
      const subscriptionResponse = await apiRequest('POST', '/subscriptions', {
        schoolId: testSchoolId,
        customerId: testCustomerId,
        planId: testSubscriptionPlanId,
        billingCycle: 'monthly',
        quantity: 100,
        simulate: {
          paymentFailure: true,
          failureType: 'card_expired'
        }
      });
      
      testSubscriptionId = subscriptionResponse.data.id;
      
      // Wait for billing attempt and failure
      await new Promise(resolve => setTimeout(resolve, 3000));
      
      // Check subscription status
      const statusResponse = await apiRequest('GET', `/subscriptions/${testSubscriptionId}`);
      expect(statusResponse.data.status).toBe('past_due');
      
      // Process dunning
      const dunningResponse = await apiRequest('POST', '/subscriptions/dunning/process', {
        subscriptionIds: [testSubscriptionId],
        dunningConfig: {
          maxAttempts: 3,
          retrySchedule: [1, 3, 7],
          gracePeriod: 2
        }
      });
      
      expect(dunningResponse.status).toBe(200);
      
      // Update payment method to fix issue
      const newMethodResponse = await apiRequest('POST', '/payments/methods', {
        customerId: testCustomerId,
        type: 'card',
        card: {
          number: '4111111111111111',
          expiryMonth: 12,
          expiryYear: 2026, // Future expiry
          cvv: '123',
          holderName: 'Test Updated Card'
        },
        isDefault: true
      });
      
      // Retry payment with new method
      const retryResponse = await apiRequest('POST', `/subscriptions/${testSubscriptionId}/retry-payment`, {
        paymentMethodId: newMethodResponse.data.id
      });
      
      expect(retryResponse.status).toBe(200);
      expect(retryResponse.data.status).toBe('processing');
      
      // Wait for payment processing
      await new Promise(resolve => setTimeout(resolve, 3000));
      
      // Verify subscription recovery
      const recoveredStatusResponse = await apiRequest('GET', `/subscriptions/${testSubscriptionId}`);
      expect(recoveredStatusResponse.data.status).toBe('active');
      
      // Verify recovery analytics
      const recoveryAnalyticsResponse = await apiRequest('GET', `/analytics/recovery/${testSubscriptionId}`);
      expect(recoveryAnalyticsResponse.status).toBe(200);
      expect(recoveryAnalyticsResponse.data).toHaveProperty('recoveryTimeline');
      expect(recoveryAnalyticsResponse.data).toHaveProperty('actionsRequired');
      expect(recoveryAnalyticsResponse.data).toHaveProperty('successFactors');
      
      console.log(`✅ Payment failure recovery across ecosystem completed`);
    });
  });

  /**
   * Performance and Scalability Tests
   * Testing system performance under various load conditions
   */
  describe('Performance and Scalability Tests', () => {
    
    test('should handle concurrent payment processing', async () => {
      console.log('🚀 Testing concurrent payment processing...');
      
      const concurrentPayments = Array.from({ length: 20 }, (_, index) => ({
        customerId: testCustomerId,
        amount: 50000 + (index * 1000), // Varying amounts
        currency: 'INR',
        paymentMethodId: testPaymentMethodId,
        description: `Concurrent payment ${index + 1}`,
        metadata: {
          batchId: `concurrent_${Date.now()}`,
          index
        }
      }));

      const startTime = Date.now();
      const paymentPromises = concurrentPayments.map(payment =>
        apiRequest('POST', '/payments/advanced', payment)
      );

      const results = await Promise.allSettled(paymentPromises);
      const processingTime = Date.now() - startTime;
      
      const successful = results.filter(r => r.status === 'fulfilled').length;
      const failed = results.filter(r => r.status === 'rejected').length;
      
      expect(successful).toBeGreaterThan(15); // At least 75% success rate
      expect(processingTime).toBeLessThan(30000); // Under 30 seconds
      
      console.log(`✅ Concurrent processing: ${successful}/${concurrentPayments.length} successful in ${processingTime}ms`);
    });

    test('should maintain database consistency under load', async () => {
      console.log('🔒 Testing database consistency under load...');
      
      // Create multiple subscriptions concurrently
      const subscriptionPromises = Array.from({ length: 10 }, (_, index) =>
        apiRequest('POST', '/subscriptions', {
          schoolId: testSchoolId,
          customerId: testCustomerId,
          planId: testSubscriptionPlanId,
          billingCycle: 'monthly',
          quantity: 50 + index,
          metadata: { concurrencyTest: true, index }
        })
      );

      const subscriptionResults = await Promise.allSettled(subscriptionPromises);
      const successfulSubscriptions = subscriptionResults
        .filter(r => r.status === 'fulfilled')
        .map(r => (r as PromiseFulfilledResult<any>).value.data.id);
      
      // Verify data consistency
      for (const subscriptionId of successfulSubscriptions) {
        const subscriptionResponse = await apiRequest('GET', `/subscriptions/${subscriptionId}`);
        expect(subscriptionResponse.status).toBe(200);
        expect(subscriptionResponse.data).toHaveProperty('id', subscriptionId);
        expect(subscriptionResponse.data).toHaveProperty('schoolId', testSchoolId);
      }
      
      // Check for duplicate data
      const allSubscriptionsResponse = await apiRequest('GET', '/subscriptions', {
        schoolId: testSchoolId,
        metadata: { concurrencyTest: true }
      });
      
      const subscriptionIds = allSubscriptionsResponse.data.map((s: any) => s.id);
      const uniqueIds = new Set(subscriptionIds);
      expect(uniqueIds.size).toBe(subscriptionIds.length); // No duplicates
      
      console.log(`✅ Database consistency maintained under load`);
    });
  });

  /**
   * Security and Compliance Tests
   * Testing security measures and compliance requirements
   */
  describe('Security and Compliance Tests', () => {
    
    test('should enforce payment data encryption', async () => {
      console.log('🔐 Testing payment data encryption...');
      
      // Create payment with sensitive data
      const sensitivePaymentData = {
        customerId: testCustomerId,
        amount: 100000,
        currency: 'INR',
        paymentMethod: {
          type: 'card',
          card: {
            number: '4111111111111111',
            expiryMonth: 12,
            expiryYear: 2025,
            cvv: '123',
            holderName: 'Sensitive Test Card'
          }
        },
        billingAddress: {
          line1: '123 Sensitive Street',
          city: 'PrivateCity',
          state: 'SecureState',
          pincode: '123456'
        }
      };

      const paymentResponse = await apiRequest('POST', '/payments/advanced', sensitivePaymentData);
      testPaymentId = paymentResponse.data.id;
      
      // Verify stored data is encrypted
      const storedPaymentResponse = await apiRequest('GET', `/payments/advanced/${testPaymentId}`);
      
      // Card number should be masked
      expect(storedPaymentResponse.data.paymentMethod.card.number).toMatch(/\*{12}\d{4}/);
      // CVV should not be stored
      expect(storedPaymentResponse.data.paymentMethod.card).not.toHaveProperty('cvv');
      
      // Test encryption at database level
      const encryptionTestResponse = await apiRequest('GET', `/security/encryption/verify/${testPaymentId}`);
      expect(encryptionTestResponse.status).toBe(200);
      expect(encryptionTestResponse.data).toHaveProperty('encrypted', true);
      expect(encryptionTestResponse.data).toHaveProperty('algorithm', 'AES-256-GCM');
      expect(encryptionTestResponse.data).toHaveProperty('keyRotation', true);
      
      console.log(`✅ Payment data encryption verified`);
    });

    test('should comply with PCI DSS requirements', async () => {
      console.log('🛡️ Testing PCI DSS compliance...');
      
      const complianceResponse = await apiRequest('GET', '/compliance/pci-dss/status', {
        schoolId: testSchoolId
      });
      
      expect(complianceResponse.status).toBe(200);
      expect(complianceResponse.data).toHaveProperty('level', 'SAQ-A'); // Service provider level
      expect(complianceResponse.data).toHaveProperty('requirements');
      
      const {requirements} = complianceResponse.data;
      expect(requirements).toHaveProperty('dataEncryption', 'compliant');
      expect(requirements).toHaveProperty('accessControl', 'compliant');
      expect(requirements).toHaveProperty('networkSecurity', 'compliant');
      expect(requirements).toHaveProperty('vulnerabilityManagement', 'compliant');
      expect(requirements).toHaveProperty('securityTesting', 'compliant');
      expect(requirements).toHaveProperty('securityPolicies', 'compliant');
      
      console.log(`✅ PCI DSS compliance verified`);
    });

    test('should maintain audit trails for compliance', async () => {
      console.log('📋 Testing compliance audit trails...');
      
      // Perform various payment operations
      const operations = [
        { action: 'create_payment', endpoint: '/payments/advanced' },
        { action: 'update_subscription', endpoint: `/subscriptions/${testSubscriptionId}` },
        { action: 'generate_invoice', endpoint: '/invoices/generate' },
        { action: 'process_refund', endpoint: `/payments/${testPaymentId}/refund` }
      ];

      for (const operation of operations) {
        // Each operation should be automatically audited
        const auditResponse = await apiRequest('GET', '/audit/search', {
          action: operation.action,
          schoolId: testSchoolId,
          timeframe: {
            start: new Date(Date.now() - 60 * 60 * 1000).toISOString(), // Last hour
            end: new Date().toISOString()
          }
        });
        
        expect(auditResponse.status).toBe(200);
        expect(auditResponse.data.events.length).toBeGreaterThan(0);
        
        // Verify audit event structure
        const auditEvent = auditResponse.data.events[0];
        expect(auditEvent).toHaveProperty('timestamp');
        expect(auditEvent).toHaveProperty('action', operation.action);
        expect(auditEvent).toHaveProperty('userId');
        expect(auditEvent).toHaveProperty('schoolId', testSchoolId);
        expect(auditEvent).toHaveProperty('ipAddress');
        expect(auditEvent).toHaveProperty('userAgent');
        expect(auditEvent).toHaveProperty('outcome');
      }
      
      // Generate compliance audit report
      const auditReportResponse = await apiRequest('POST', '/audit/reports/compliance', {
        schoolId: testSchoolId,
        reportType: 'payment_compliance',
        timeframe: {
          start: new Date(Date.now() - 24 * 60 * 60 * 1000).toISOString(),
          end: new Date().toISOString()
        },
        standards: ['PCI_DSS', 'GDPR', 'SOX', 'HIPAA'],
        includeRecommendations: true
      });
      
      expect(auditReportResponse.status).toBe(200);
      expect(auditReportResponse.data).toHaveProperty('compliance');
      expect(auditReportResponse.data.compliance).toHaveProperty('overallScore');
      expect(auditReportResponse.data.compliance.overallScore).toBeGreaterThan(0.9); // 90%+ compliance
      
      console.log(`✅ Compliance audit trails verified`);
    });
  });

  /**
   * Webhook Integration Tests
   * Testing webhook processing for payment gateways
   */
  describe('Webhook Integration Tests', () => {
    
    test('should process Razorpay webhooks correctly', async () => {
      console.log('🔗 Testing Razorpay webhook processing...');
      
      const razorpayEvents = [
        {
          event: 'payment.captured',
          payload: {
            payment: {
              id: 'pay_test_12345',
              amount: 75000,
              currency: 'INR',
              status: 'captured',
              order_id: 'order_test_12345',
              method: 'card',
              captured: true,
              card: {
                id: 'card_test_12345',
                network: 'Visa',
                last4: '1111',
                type: 'credit'
              },
              acquirer_data: {
                rrn: '123456789012'
              },
              created_at: Math.floor(Date.now() / 1000)
            }
          }
        },
        {
          event: 'payment.failed',
          payload: {
            payment: {
              id: 'pay_test_failed',
              amount: 50000,
              currency: 'INR',
              status: 'failed',
              error_code: 'GATEWAY_ERROR',
              error_description: 'Payment processing failed',
              created_at: Math.floor(Date.now() / 1000)
            }
          }
        }
      ];

      for (const webhookEvent of razorpayEvents) {
        const webhookResponse = await simulateWebhook('razorpay', webhookEvent.event, webhookEvent.payload);
        
        expect(webhookResponse.status).toBe(200);
        
        // Verify webhook processing
        await new Promise(resolve => setTimeout(resolve, 1000));
        
        const processedResponse = await apiRequest('GET', '/webhooks/processed', {
          gateway: 'razorpay',
          eventId: webhookEvent.payload.payment.id
        });
        
        expect(processedResponse.status).toBe(200);
        expect(processedResponse.data).toHaveProperty('processed', true);
        expect(processedResponse.data).toHaveProperty('actions');
      }
      
      console.log(`✅ Razorpay webhook processing completed`);
    });

    test('should process Stripe webhooks correctly', async () => {
      console.log('💳 Testing Stripe webhook processing...');
      
      const stripeEvents = [
        {
          event: 'payment_intent.succeeded',
          payload: {
            id: 'pi_test_12345',
            object: 'payment_intent',
            amount: 80000,
            currency: 'inr',
            status: 'succeeded',
            metadata: {
              schoolId: testSchoolId,
              customerId: testCustomerId
            },
            charges: {
              data: [{
                id: 'ch_test_12345',
                amount: 80000,
                currency: 'inr',
                status: 'succeeded',
                payment_method: 'pm_test_card'
              }]
            }
          }
        },
        {
          event: 'invoice.payment_succeeded',
          payload: {
            id: 'in_test_12345',
            object: 'invoice',
            amount_paid: 125000,
            currency: 'inr',
            status: 'paid',
            subscription: 'sub_test_12345',
            metadata: {
              schoolId: testSchoolId
            }
          }
        }
      ];

      for (const webhookEvent of stripeEvents) {
        const webhookResponse = await simulateWebhook('stripe', webhookEvent.event, webhookEvent.payload);
        
        expect(webhookResponse.status).toBe(200);
        
        // Verify webhook processing
        await new Promise(resolve => setTimeout(resolve, 1000));
        
        const processedResponse = await apiRequest('GET', '/webhooks/processed', {
          gateway: 'stripe',
          eventId: webhookEvent.payload.id
        });
        
        expect(processedResponse.status).toBe(200);
        expect(processedResponse.data).toHaveProperty('processed', true);
      }
      
      console.log(`✅ Stripe webhook processing completed`);
    });
  });

  /**
   * Error Handling and Edge Cases
   * Testing system behavior under various error conditions
   */
  describe('Error Handling and Edge Cases', () => {
    
    test('should handle payment gateway timeouts', async () => {
      console.log('⏱️ Testing payment gateway timeout handling...');
      
      const timeoutPaymentData = {
        customerId: testCustomerId,
        amount: 60000,
        currency: 'INR',
        paymentMethodId: testPaymentMethodId,
        description: 'Timeout test payment',
        simulate: {
          gatewayTimeout: true,
          timeoutDuration: 30000 // 30 seconds
        }
      };

      const paymentResponse = await apiRequest('POST', '/payments/advanced', timeoutPaymentData, undefined, {
        timeout: 35000, // Allow for timeout simulation
        expectError: false
      });
      
      // Should handle timeout gracefully
      expect(paymentResponse.status).toBe(202); // Accepted but processing
      expect(paymentResponse.data).toHaveProperty('status', 'processing');
      expect(paymentResponse.data).toHaveProperty('timeoutHandling', true);
      
      // Check status after timeout period
      await new Promise(resolve => setTimeout(resolve, 5000));
      
      const statusResponse = await apiRequest('GET', `/payments/advanced/${paymentResponse.data.id}`);
      expect(['timeout', 'retrying', 'failed']).toContain(statusResponse.data.status);
      
      console.log(`✅ Gateway timeout handling verified`);
    });

    test('should handle invalid payment data gracefully', async () => {
      console.log('❌ Testing invalid payment data handling...');
      
      const invalidPaymentCases = [
        {
          name: 'negative_amount',
          data: { amount: -1000 },
          expectedError: 'Invalid amount'
        },
        {
          name: 'invalid_currency',
          data: { currency: 'INVALID' },
          expectedError: 'Unsupported currency'
        },
        {
          name: 'missing_customer',
          data: { customerId: 'non_existent_customer' },
          expectedError: 'Customer not found'
        },
        {
          name: 'invalid_payment_method',
          data: { paymentMethodId: 'invalid_method' },
          expectedError: 'Payment method not found'
        }
      ];

      for (const testCase of invalidPaymentCases) {
        const invalidData = {
          customerId: testCustomerId,
          amount: 50000,
          currency: 'INR',
          paymentMethodId: testPaymentMethodId,
          description: `Invalid data test: ${testCase.name}`,
          ...testCase.data
        };

        const response = await apiRequest('POST', '/payments/advanced', invalidData, undefined, {
          expectError: true
        });
        
        expect(response.status).toBeGreaterThanOrEqual(400);
        expect(response.status).toBeLessThan(500);
        expect(response.data).toHaveProperty('error');
        expect(response.data.error).toContain(testCase.expectedError);
      }
      
      console.log(`✅ Invalid payment data handling verified`);
    });

    test('should handle network failures and retries', async () => {
      console.log('🌐 Testing network failure handling...');
      
      // Simulate network failure during payment processing
      const networkFailureData = {
        customerId: testCustomerId,
        amount: 85000,
        currency: 'INR',
        paymentMethodId: testPaymentMethodId,
        description: 'Network failure test',
        simulate: {
          networkFailure: true,
          failureStage: 'gateway_communication',
          retryable: true
        }
      };

      const paymentResponse = await apiRequest('POST', '/payments/advanced', networkFailureData);
      
      // Should queue for retry
      expect(paymentResponse.status).toBe(202);
      expect(paymentResponse.data).toHaveProperty('status', 'queued_for_retry');
      expect(paymentResponse.data).toHaveProperty('retryConfig');
      
      // Wait for retry processing
      await new Promise(resolve => setTimeout(resolve, 5000));
      
      // Check retry status
      const retryStatusResponse = await apiRequest('GET', `/payments/retry/${paymentResponse.data.id}`);
      expect(retryStatusResponse.status).toBe(200);
      expect(retryStatusResponse.data).toHaveProperty('retryAttempts');
      expect(retryStatusResponse.data.retryAttempts).toBeGreaterThan(0);
      
      console.log(`✅ Network failure handling verified`);
    });
  });

});

/**
 * Test data cleanup helpers
 * Mock cleanup functions for test environment (no real database operations)
 */
async function cleanupPaymentData(): Promise<void> {
  try {
    // Mock cleanup - no real database operations in test environment
    console.log('🧹 Mock payment cleanup completed (SKIP_DATABASE_TESTS=true)');
  } catch (error) {
    console.warn('⚠️ Mock payment cleanup warning (non-critical):', error);
  }
}

async function cleanupSubscriptionData(): Promise<void> {
  try {
    // Mock cleanup - no real database operations in test environment
    console.log('🧹 Mock subscription cleanup completed (SKIP_DATABASE_TESTS=true)');
  } catch (error) {
    console.warn('⚠️ Mock subscription cleanup warning (non-critical):', error);
  }
}

async function cleanupInvoiceData(): Promise<void> {
  try {
    // Mock cleanup - no real database operations in test environment
    console.log('🧹 Mock invoice cleanup completed (SKIP_DATABASE_TESTS=true)');
  } catch (error) {
    console.warn('⚠️ Mock invoice cleanup warning (non-critical):', error);
  }
}

async function cleanupAnalyticsData(): Promise<void> {
  try {
    // Mock cleanup - no real database operations in test environment
    console.log('🧹 Mock analytics cleanup completed (SKIP_DATABASE_TESTS=true)');
  } catch (error) {
    console.warn('⚠️ Mock analytics cleanup warning (non-critical):', error);
  }
}

async function seedAnalyticsData(): Promise<void> {
  try {
    // Mock seeding - no real database operations in test environment
    console.log('📊 Mock analytics test data seeded (SKIP_DATABASE_TESTS=true)');
  } catch (error) {
    console.warn('⚠️ Mock analytics seeding warning (non-critical):', error);
  }
}