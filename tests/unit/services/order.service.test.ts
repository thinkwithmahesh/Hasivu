/**
 * HASIVU Platform - Order Management Service Tests
 * Complete test coverage for order lifecycle: cart, checkout, tracking, delivery
 * Tests order creation, status management, payment integration, and delivery verification
 * Generated by SuperClaude Wave 3: Epic 3 Implementation - COMPREHENSIVE TESTS
 */
import { OrderService, OrderStatus } from '../../../src/services/order.service';
import { OrderRepository } from '../../../src/repositories/order.repository';
import { OrderItemRepository } from '../../../src/repositories/orderItem.repository';
import { PaymentOrderRepository } from '../../../src/repositories/paymentOrder.repository';
import { MenuItemRepository } from '../../../src/repositories/menuItem.repository';
import { UserRepository } from '../../../src/repositories/user.repository';
import { DatabaseService } from '../../../src/services/database.service';
import { PaymentService } from '../../../src/services/payment.service';
import { NotificationService } from '../../../src/services/notification.service';
import { RedisService } from '../../../src/services/redis.service';
import { cache } from '../../../src/utils/cache';

// Mock dependencies
jest.mock('../../../src/repositories/order.repository');
jest.mock('../../../src/repositories/orderItem.repository');
jest.mock('../../../src/repositories/paymentOrder.repository');
jest.mock('../../../src/repositories/menuItem.repository');
jest.mock('../../../src/repositories/user.repository');
jest.mock('../../../src/services/database.service');
jest.mock('../../../src/services/payment.service', () => ({
  PaymentService: {
    processPayment: jest.fn(),
    refundPayment: jest.fn()
  }
}));
jest.mock('../../../src/services/notification.service');
jest.mock('../../../src/services/redis.service');
jest.mock('../../../src/utils/logger');
jest.mock('../../../src/utils/cache', () => ({
  cache: {
    get: jest.fn(),
    setex: jest.fn()
  }
}));

describe('OrderService', () => {
  // Mock data
  const mockOrder = {
    id: 'order-123',
    orderNumber: 'ORD-2024-001',
    userId: 'parent-123',
    studentId: 'student-123',
    schoolId: 'school-123',
    status: 'PENDING',
    totalAmount: 375,
    currency: 'INR',
    orderDate: new Date(),
    deliveryDate: new Date(Date.now() + 24 * 60 * 60 * 1000), // Tomorrow
    deliveredAt: null,
    specialInstructions: 'Handle with care',
    allergyInfo: null,
    paymentStatus: 'pending',
    metadata: '{}',
    createdAt: new Date(),
    updatedAt: new Date()
  };

  const mockMenuItem1 = {
    id: 'item-1',
    name: 'Delicious Meal',
    price: 150,
    available: true,
    allergens: null,
    tags: null
  };

  const mockMenuItem2 = {
    id: 'item-2',
    name: 'Healthy Snack',
    price: 75,
    available: true,
    allergens: null,
    tags: null
  };

  const mockUser = {
    id: 'student-123',
    dietaryRestrictions: null,
    allergies: null
  };

  const mockPaymentOrder = {
    id: 'payment-123',
    orderId: 'order-123',
    amount: 375,
    status: 'pending'
  };

  beforeEach(() => {
    jest.clearAllMocks();
    
    // Setup default mocks
    (DatabaseService.transaction as jest.Mock).mockImplementation(async (callback) => {
      return await callback({
        order: {
          create: jest.fn().mockResolvedValue(mockOrder)
        },
        orderItem: {
          createMany: jest.fn().mockResolvedValue({ count: 2 })
        }
      });
    });
  });

  describe('Order Creation', () => {
    it('should create order successfully with valid data', async () => {
      const orderData = {
        studentId: 'student-123',
        parentId: 'parent-123',
        schoolId: 'school-123',
        items: [
          { menuItemId: 'item-1', quantity: 2, specialInstructions: 'No onions' },
          { menuItemId: 'item-2', quantity: 1, specialInstructions: undefined }
        ],
        deliveryDate: new Date(Date.now() + 24 * 60 * 60 * 1000), // Tomorrow
        deliveryType: 'delivery' as const,
        deliveryAddress: '123 Main St'
      };

      const mockMenuItems = {
        items: [mockMenuItem1, mockMenuItem2],
        total: 2
      };

      (MenuItemRepository.findMany as jest.Mock).mockResolvedValue(mockMenuItems);
      (UserRepository.findById as jest.Mock).mockResolvedValue(mockUser);
      (RedisService.del as jest.Mock).mockResolvedValue(true);
      (NotificationService.sendOrderConfirmation as jest.Mock).mockResolvedValue(true);

      const result = await OrderService.createOrder(orderData);

      expect(result.success).toBe(true);
      expect(result.data?.totalAmount).toBe(375);
      expect(result.data?.status).toBe('PENDING');
      expect(MenuItemRepository.findMany).toHaveBeenCalledWith({
        filters: { schoolId: 'school-123', available: true },
        ids: ['item-1', 'item-2']
      });
    });

    it('should reject order with unavailable menu items', async () => {
      const orderData = {
        studentId: 'student-123',
        parentId: 'parent-123',
        schoolId: 'school-123',
        items: [
          { menuItemId: 'unavailable-item', quantity: 1 }
        ],
        deliveryDate: new Date(Date.now() + 24 * 60 * 60 * 1000), // Tomorrow
        deliveryType: 'delivery' as const
      };

      const mockMenuItems = {
        items: [], // No items found
        total: 0
      };

      (MenuItemRepository.findMany as jest.Mock).mockResolvedValue(mockMenuItems);

      const result = await OrderService.createOrder(orderData);

      expect(result.success).toBe(false);
      expect(result.error?.message).toContain('not available');
      expect(result.error?.code).toBe('ITEMS_UNAVAILABLE');
    });

    it('should validate delivery date is not in the past', async () => {
      const orderData = {
        studentId: 'student-123',
        parentId: 'parent-123',
        schoolId: 'school-123',
        items: [{ menuItemId: 'item-1', quantity: 1 }],
        deliveryDate: new Date('2020-01-01'), // Past date
        deliveryType: 'delivery' as const
      };

      const result = await OrderService.createOrder(orderData);

      expect(result.success).toBe(false);
      expect(result.error?.message).toContain('Delivery date cannot be in the past');
      expect(result.error?.code).toBe('INVALID_DELIVERY_DATE');
    });

    it('should apply dietary restrictions and allergies', async () => {
      const orderData = {
        studentId: 'student-123',
        parentId: 'parent-123',
        schoolId: 'school-123',
        items: [{ menuItemId: 'item-1', quantity: 1 }],
        deliveryDate: new Date(Date.now() + 24 * 60 * 60 * 1000), // Tomorrow
        deliveryType: 'delivery' as const
      };

      const studentWithAllergies = {
        id: 'student-123',
        dietaryRestrictions: null,
        allergies: JSON.stringify(['nuts', 'dairy'])
      };

      const menuItemWithNuts = {
        id: 'item-1',
        name: 'Nutty Delight',
        price: 150,
        available: true,
        allergens: JSON.stringify(['nuts']),
        tags: null
      };

      const mockMenuItems = {
        items: [menuItemWithNuts],
        total: 1
      };

      (UserRepository.findById as jest.Mock).mockResolvedValue(studentWithAllergies);
      (MenuItemRepository.findMany as jest.Mock).mockResolvedValue(mockMenuItems);

      const result = await OrderService.createOrder(orderData);

      expect(result.success).toBe(false);
      expect(result.error?.message).toContain('dietary restrictions or allergies');
      expect(result.error?.code).toBe('DIETARY_RESTRICTION_CONFLICT');
    });
  });

  describe('Cart Management', () => {
    describe('addToCart', () => {
      it('should add item to empty cart', async () => {
        const cartData = {
          studentId: 'student-123',
          menuItemId: 'item-1',
          quantity: 2,
          specialInstructions: 'Extra sauce'
        };

        (MenuItemRepository.findById as jest.Mock).mockResolvedValue(mockMenuItem1);
        (RedisService.get as jest.Mock).mockResolvedValue(null); // Empty cart
        (RedisService.set as jest.Mock).mockResolvedValue('OK');

        const result = await OrderService.addToCart(cartData);

        expect(result.success).toBe(true);
        expect(result.data?.items).toHaveLength(1);
        expect(result.data?.items[0].quantity).toBe(2);
        expect(result.data?.totalAmount).toBe(300);
        expect(RedisService.set).toHaveBeenCalledWith(
          'cart:student-123',
          expect.any(String),
          3600 // 1 hour expiry
        );
      });

      it('should update quantity if item already in cart', async () => {
        const cartData = {
          studentId: 'student-123',
          menuItemId: 'item-1',
          quantity: 1
        };

        const existingCart = {
          items: [
            { menuItemId: 'item-1', quantity: 2, price: 150 }
          ],
          totalAmount: 300,
          lastUpdated: new Date(),
          expiresAt: new Date(Date.now() + 3600000)
        };

        (MenuItemRepository.findById as jest.Mock).mockResolvedValue(mockMenuItem1);
        (RedisService.get as jest.Mock).mockResolvedValue(JSON.stringify(existingCart));
        (RedisService.set as jest.Mock).mockResolvedValue('OK');

        const result = await OrderService.addToCart(cartData);

        expect(result.success).toBe(true);
        expect(result.data?.items[0].quantity).toBe(3);
        expect(result.data?.totalAmount).toBe(450);
      });
    });
  });

  describe('Order Status Management', () => {
    it('should update order status successfully', async () => {
      const orderId = 'order-123';
      const newStatus = OrderStatus.CONFIRMED;

      const updatedOrder = {
        ...mockOrder,
        status: newStatus,
        statusHistory: JSON.stringify([
          { status: 'PENDING', timestamp: new Date('2024-01-01T10:00:00Z') },
          { status: newStatus, timestamp: expect.any(Date) }
        ])
      };

      (OrderRepository.findById as jest.Mock).mockResolvedValue(mockOrder);
      (OrderRepository.update as jest.Mock).mockResolvedValue(updatedOrder);
      (NotificationService.sendOrderStatusUpdate as jest.Mock).mockResolvedValue(true);

      const result = await OrderService.updateOrderStatus(orderId, newStatus);

      expect(result.success).toBe(true);
      expect(result.data?.status).toBe(newStatus);
      expect(OrderRepository.update).toHaveBeenCalledWith(orderId, expect.objectContaining({
        status: newStatus,
        statusHistory: expect.any(String),
        updatedAt: expect.any(Date)
      }));
      expect(NotificationService.sendOrderStatusUpdate).toHaveBeenCalledWith({
        orderId,
        studentId: mockOrder.studentId,
        parentId: mockOrder.userId,
        newStatus,
        message: undefined
      });
    });

    it('should validate status transitions', async () => {
      const orderId = 'order-123';
      const invalidStatus = OrderStatus.DELIVERED; // Can't go directly from PENDING to DELIVERED

      (OrderRepository.findById as jest.Mock).mockResolvedValue(mockOrder);

      const result = await OrderService.updateOrderStatus(orderId, invalidStatus);

      expect(result.success).toBe(false);
      expect(result.error?.message).toContain('Invalid status transition');
      expect(result.error?.code).toBe('INVALID_STATUS_TRANSITION');
      expect(OrderRepository.update).not.toHaveBeenCalled();
    });
  });

  describe('Payment Integration', () => {
    it('should process payment successfully', async () => {
      const paymentData = {
        orderId: 'order-123',
        paymentMethod: 'razorpay' as const,
        paymentDetails: { cardNumber: '**** 1234' }
      };

      const mockPaymentResult = {
        success: true,
        data: { paymentId: 'pay_123', status: 'captured' }
      };

      (OrderRepository.findById as jest.Mock).mockResolvedValue(mockOrder);
      (PaymentOrderRepository.create as jest.Mock).mockResolvedValue(mockPaymentOrder);
      (PaymentService.processPayment as jest.Mock).mockResolvedValue(mockPaymentResult);
      (PaymentOrderRepository.update as jest.Mock).mockResolvedValue({
        ...mockPaymentOrder,
        status: 'captured',
        paymentId: 'pay_123'
      });
      // Mock updateOrderStatus as a spy since it's called internally
      jest.spyOn(OrderService, 'updateOrderStatus').mockResolvedValue({
        success: true,
        data: { ...mockOrder, status: 'CONFIRMED' }
      });

      const result = await OrderService.processOrderPayment(paymentData);

      expect(result.success).toBe(true);
      expect(result.data?.paymentStatus).toBe('captured');
      expect(PaymentOrderRepository.create).toHaveBeenCalledWith(expect.objectContaining({
        orderId: 'order-123',
        amount: 375,
        method: 'razorpay'
      }));
    });

    it('should handle payment failures gracefully', async () => {
      const paymentData = {
        orderId: 'order-123',
        paymentMethod: 'razorpay' as const
      };

      const mockPaymentResult = {
        success: false,
        error: { message: 'Payment declined', code: 'CARD_DECLINED' }
      };

      (OrderRepository.findById as jest.Mock).mockResolvedValue(mockOrder);
      (PaymentOrderRepository.create as jest.Mock).mockResolvedValue(mockPaymentOrder);
      (PaymentService.processPayment as jest.Mock).mockResolvedValue(mockPaymentResult);

      const result = await OrderService.processOrderPayment(paymentData);

      expect(result.success).toBe(false);
      expect(result.error?.message).toContain('Payment declined');
      expect(result.error?.code).toBe('PAYMENT_FAILED');
    });
  });

  describe('Order Tracking', () => {
    it('should return order tracking information', async () => {
      const orderId = 'order-123';
      const orderWithIncludes = {
        ...mockOrder,
        orderItems: [
          {
            id: 'item-1',
            menuItem: { id: 'menu-1', name: 'Test Item' },
            quantity: 2
          }
        ],
        deliveryVerifications: []
      };

      (OrderRepository.findByIdWithIncludes as jest.Mock).mockResolvedValue(orderWithIncludes);

      const result = await OrderService.getOrderTracking(orderId);

      expect(result.success).toBe(true);
      expect(result.data?.status).toBe('PENDING');
      expect(result.data?.timeline).toBeDefined();
      expect(result.data?.estimatedDelivery).toBeDefined();
      expect(result.data?.canCancel).toBe(true);
    });

    it('should include delivery verification details when available', async () => {
      const orderId = 'order-123';
      const orderWithDelivery = {
        ...mockOrder,
        status: 'DELIVERED',
        orderItems: [],
        deliveryVerifications: [
          {
            id: 'verification-123',
            verifiedAt: new Date(),
            rfidCard: { id: 'card-123', cardNumber: 'A1B2C3D4E5F6' },
            rfidReader: { id: 'reader-123', location: 'Main Entrance' }
          }
        ]
      };

      // Ensure cache returns null so repository mock is called
      (cache.get as jest.Mock).mockResolvedValue(null);
      
      (OrderRepository.findByIdWithIncludes as jest.Mock).mockResolvedValue(orderWithDelivery);

      const result = await OrderService.getOrderTracking(orderId);

      expect(result.success).toBe(true);
      expect(result.data?.deliveryDetails).toBeDefined();
      expect(result.data?.deliveryDetails?.verifiedAt).toBeDefined();
      expect(result.data?.deliveryDetails?.location).toBe('Main Entrance');
    });
  });

  describe('getOrdersByStudent', () => {
    it('should return paginated orders for student', async () => {
      const studentId = 'student-123';
      const query = { page: 1, limit: 10, status: OrderStatus.DELIVERED };
      const mockOrders = [mockOrder, { ...mockOrder, id: 'order-456' }];

      (OrderRepository.findMany as jest.Mock).mockResolvedValue({
        items: mockOrders,
        total: 2
      });
      (OrderRepository.count as jest.Mock).mockResolvedValue(2);

      const result = await OrderService.getOrdersByStudent(studentId, query);

      expect(result.success).toBe(true);
      expect(result.data?.orders).toHaveLength(2);
      expect(result.data?.pagination.total).toBe(2);
      expect(result.data?.pagination.page).toBe(1);
      expect(OrderRepository.findMany).toHaveBeenCalledWith(expect.objectContaining({
        filters: { studentId, status: 'DELIVERED' },
        skip: 0,
        take: 10,
        sortBy: 'createdAt',
        sortOrder: 'desc'
      }));
    });
  });

  describe('Order Cancellation', () => {
    it('should cancel order and process refund', async () => {
      const orderId = 'order-123';
      const cancellationReason = 'Change of plans';

      const refundResult = {
        success: true,
        data: { refundId: 'refund-123', status: 'processed' }
      };

      (OrderRepository.findById as jest.Mock).mockResolvedValue(mockOrder);
      (PaymentOrderRepository.findByOrderId as jest.Mock).mockResolvedValue({
        ...mockPaymentOrder,
        status: 'captured',
        paymentId: 'pay_123'
      });
      ((PaymentService as any).refundPayment as jest.Mock).mockResolvedValue(refundResult);
      // Mock updateOrderStatus as a spy since it's called internally
      jest.spyOn(OrderService, 'updateOrderStatus').mockResolvedValue({
        success: true,
        data: { ...mockOrder, status: 'CANCELLED' }
      });

      const result = await OrderService.cancelOrder(orderId, cancellationReason);

      expect(result.success).toBe(true);
      expect(result.data?.status).toBe('CANCELLED');
      expect(result.data?.paymentStatus).toBe('refunded');
      expect((PaymentService as any).refundPayment).toHaveBeenCalledWith({
        paymentId: 'pay_123',
        amount: 375,
        reason: cancellationReason
      });
    });

    it('should not allow cancellation of delivered orders', async () => {
      const orderId = 'order-123';
      const deliveredOrder = { ...mockOrder, status: 'DELIVERED' };

      (OrderRepository.findById as jest.Mock).mockResolvedValue(deliveredOrder);

      const result = await OrderService.cancelOrder(orderId, 'Change of mind');

      expect(result.success).toBe(false);
      expect(result.error?.message).toContain('cannot be cancelled');
      expect(result.error?.code).toBe('CANCELLATION_NOT_ALLOWED');
    });
  });

  describe('Analytics and Reporting', () => {
    it('should return order analytics', async () => {
      const analyticsQuery = {
        schoolId: 'school-123',
        startDate: new Date('2024-01-01'),
        endDate: new Date('2024-01-31')
      };

      const mockAnalytics = {
        totalOrders: 50,
        totalRevenue: 67500,
        deliveredOrders: 45,
        cancelledOrders: 5,
        ordersByStatus: {
          PENDING: 5,
          CONFIRMED: 10,
          PREPARING: 8,
          READY: 2,
          OUT_FOR_DELIVERY: 0,
          DELIVERED: 45,
          CANCELLED: 5
        },
        revenueByDay: []
      };

      (OrderRepository.getAnalytics as jest.Mock).mockResolvedValue(mockAnalytics);

      const result = await OrderService.getOrderAnalytics(analyticsQuery);

      expect(result.success).toBe(true);
      expect(result.data?.totalOrders).toBe(50);
      expect(result.data?.totalRevenue).toBe(67500);
      expect(result.data?.deliveryRate).toBe(90);
      expect(result.data?.cancellationRate).toBe(10);
      expect(result.data?.averageOrderValue).toBe(1350);
    });

    describe('getPopularItems', () => {
      it('should return popular menu items', async () => {
        const query = {
          schoolId: 'school-123',
          startDate: new Date('2024-01-01'),
          endDate: new Date('2024-01-31'),
          limit: 5
        };

        const mockPopularItems = [
          {
            menuItemId: 'item-1',
            menuItemName: 'Popular Meal',
            totalQuantity: 120,
            orderCount: 45,
            revenue: 18000
          },
          {
            menuItemId: 'item-2',
            menuItemName: 'Favorite Snack',
            totalQuantity: 80,
            orderCount: 30,
            revenue: 6000
          }
        ];

        (OrderItemRepository.getPopularItems as jest.Mock).mockResolvedValue(mockPopularItems);

        const result = await OrderService.getPopularItems(query);

        expect(result.success).toBe(true);
        expect(result.data).toHaveLength(2);
        expect(result.data?.[0].totalQuantity).toBe(120);
        expect(result.data?.[0].orderCount).toBe(45);
        expect(result.data?.[0].revenue).toBe(18000);
      });
    });
  });

  describe('Error Handling and Edge Cases', () => {
    it('should handle database constraint errors', async () => {
      const orderData = {
        studentId: 'student-123',
        parentId: 'parent-123',
        schoolId: 'school-123',
        items: [{ menuItemId: 'item-1', quantity: 1 }],
        deliveryDate: new Date(Date.now() + 24 * 60 * 60 * 1000), // Tomorrow
        deliveryType: 'delivery' as const
      };

      // Simulate database constraint error
      const constraintError = new Error('Unique constraint failed');
      constraintError.message = 'Unique constraint failed on the fields: (`id`)';

      (MenuItemRepository.findMany as jest.Mock).mockResolvedValue({
        items: [mockMenuItem1],
        total: 1
      });
      (UserRepository.findById as jest.Mock).mockResolvedValue(mockUser);
      (DatabaseService.transaction as jest.Mock).mockRejectedValue(constraintError);

      const result = await OrderService.createOrder(orderData);

      expect(result.success).toBe(false);
      expect(result.error?.code).toBe('DUPLICATE_ORDER');
    });

    it('should handle inventory shortage gracefully', async () => {
      const orderData = {
        studentId: 'student-123',
        parentId: 'parent-123',
        schoolId: 'school-123',
        items: [{ menuItemId: 'item-1', quantity: 100 }], // Large quantity
        deliveryDate: new Date(Date.now() + 24 * 60 * 60 * 1000), // Tomorrow
        deliveryType: 'delivery' as const
      };

      const result = await OrderService.createOrder(orderData);

      expect(result.success).toBe(false);
      expect(result.error?.message).toContain('exceeds maximum allowed');
      expect(result.error?.code).toBe('QUANTITY_EXCEEDED');
    });

    it('should validate order timing restrictions', async () => {
      // Set a specific delivery date for tomorrow at 10am
      const deliveryDate = new Date('2024-02-01T10:00:00Z');
      const orderData = {
        studentId: 'student-123',
        parentId: 'parent-123',
        schoolId: 'school-123',
        items: [{ menuItemId: 'item-1', quantity: 1 }],
        deliveryDate,
        deliveryType: 'delivery' as const
      };

      // Setup menu items mock
      const mockMenuItems = {
        items: [mockMenuItem1],
        total: 1
      };
      (MenuItemRepository.findMany as jest.Mock).mockResolvedValue(mockMenuItems);
      (UserRepository.findById as jest.Mock).mockResolvedValue(mockUser);

      // Mock current time to be past ordering cutoff 
      // (delivery is at 10am on Feb 1, cutoff is 8am, current time is 9am - past cutoff)
      const mockNow = new Date('2024-02-01T09:00:00Z');
      
      // Override the Date constructor for new Date() calls
      const OriginalDate = global.Date;
      global.Date = class extends Date {
        constructor(...args: any[]) {
          if (args.length === 0) {
            super(mockNow.getTime());
          } else {
            super(args[0] as any);
          }
        }
        static now() {
          return mockNow.getTime();
        }
      } as any;

      const result = await OrderService.createOrder(orderData);

      expect(result.success).toBe(false);
      expect(result.error?.message).toContain('Order cutoff time has passed');
      expect(result.error?.code).toBe('ORDER_CUTOFF_PASSED');

      // Cleanup
      global.Date = OriginalDate;
    });
  });
});