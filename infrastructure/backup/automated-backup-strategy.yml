# Automated Backup Strategy for Hasivu Platform
# Comprehensive backup solution with point-in-time recovery

Resources:
  # RDS Backup Configuration
  DatabaseBackupPolicy:
    Type: AWS::RDS::DBInstance
    Properties:
      DBInstanceIdentifier: !Sub '${Environment}-hasivu-postgres'
      BackupRetentionPeriod: 30 # 30 days retention
      PreferredBackupWindow: '03:00-04:00' # UTC - during low traffic
      PreferredMaintenanceWindow: 'Sun:04:00-Sun:05:00'
      DeletionProtection: true
      MultiAZ: true # High availability
      StorageEncrypted: true
      KmsKeyId: !Ref DatabaseEncryptionKey
      EnablePerformanceInsights: true
      PerformanceInsightsRetentionPeriod: 7
      MonitoringInterval: 60
      MonitoringRoleArn: !GetAtt RDSEnhancedMonitoringRole.Arn
      Tags:
        - Key: Environment
          Value: !Ref Environment
        - Key: BackupStrategy
          Value: 'automated-daily'

  # Database encryption key
  DatabaseEncryptionKey:
    Type: AWS::KMS::Key
    Properties:
      Description: !Sub 'Database encryption key for ${Environment}-hasivu-postgres'
      KeyPolicy:
        Statement:
          - Sid: Enable IAM User Permissions
            Effect: Allow
            Principal:
              AWS: !Sub 'arn:aws:iam::${AWS::AccountId}:root'
            Action: 'kms:*'
            Resource: '*'
          - Sid: Allow RDS Service
            Effect: Allow
            Principal:
              Service: rds.amazonaws.com
            Action:
              - kms:Decrypt
              - kms:GenerateDataKey
            Resource: '*'

  # Manual snapshot Lambda function
  BackupLambdaFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub '${Environment}-hasivu-backup-manager'
      Runtime: nodejs18.x
      Handler: index.handler
      Timeout: 900 # 15 minutes
      MemorySize: 256
      Role: !GetAtt BackupLambdaRole.Arn
      Environment:
        Variables:
          DB_INSTANCE_IDENTIFIER: !Sub '${Environment}-hasivu-postgres'
          S3_BACKUP_BUCKET: !Ref BackupBucket
          REDIS_CLUSTER_ID: !Sub '${Environment}-hasivu-redis'
          SNS_TOPIC_ARN: !Ref BackupNotificationTopic
      Code:
        ZipFile: |
          const AWS = require('aws-sdk');
          const rds = new AWS.RDS();
          const s3 = new AWS.S3();
          const elasticache = new AWS.ElastiCache();
          const sns = new AWS.SNS();

          exports.handler = async (event) => {
              console.log('Starting backup process...', event);
              
              const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
              const results = [];
              
              try {
                  // 1. Create RDS manual snapshot
                  if (event.backupType === 'database' || event.backupType === 'all') {
                      const dbSnapshotResult = await createDatabaseSnapshot(timestamp);
                      results.push(dbSnapshotResult);
                  }
                  
                  // 2. Create Redis backup
                  if (event.backupType === 'redis' || event.backupType === 'all') {
                      const redisBackupResult = await createRedisSnapshot(timestamp);
                      results.push(redisBackupResult);
                  }
                  
                  // 3. Export configuration backup to S3
                  if (event.backupType === 'config' || event.backupType === 'all') {
                      const configBackupResult = await backupConfiguration(timestamp);
                      results.push(configBackupResult);
                  }
                  
                  // Send success notification
                  await sns.publish({
                      TopicArn: process.env.SNS_TOPIC_ARN,
                      Subject: `Backup Completed - ${timestamp}`,
                      Message: JSON.stringify({
                          status: 'success',
                          timestamp,
                          results,
                          backupType: event.backupType || 'all'
                      }, null, 2)
                  }).promise();
                  
                  return {
                      statusCode: 200,
                      body: JSON.stringify({
                          success: true,
                          timestamp,
                          results
                      })
                  };
                  
              } catch (error) {
                  console.error('Backup failed:', error);
                  
                  // Send failure notification
                  await sns.publish({
                      TopicArn: process.env.SNS_TOPIC_ARN,
                      Subject: `Backup Failed - ${timestamp}`,
                      Message: JSON.stringify({
                          status: 'failed',
                          timestamp,
                          error: error.message,
                          results
                      }, null, 2)
                  }).promise();
                  
                  throw error;
              }
          };

          async function createDatabaseSnapshot(timestamp) {
              const snapshotId = `manual-backup-${timestamp}`;
              
              const result = await rds.createDBSnapshot({
                  DBInstanceIdentifier: process.env.DB_INSTANCE_IDENTIFIER,
                  DBSnapshotIdentifier: snapshotId,
                  Tags: [
                      { Key: 'Type', Value: 'Manual' },
                      { Key: 'CreatedBy', Value: 'AutomatedBackup' },
                      { Key: 'Timestamp', Value: timestamp }
                  ]
              }).promise();
              
              console.log('Database snapshot created:', snapshotId);
              
              return {
                  type: 'database',
                  snapshotId,
                  status: result.DBSnapshot.Status,
                  timestamp
              };
          }

          async function createRedisSnapshot(timestamp) {
              const snapshotName = `manual-backup-${timestamp}`;
              
              const result = await elasticache.createSnapshot({
                  ReplicationGroupId: process.env.REDIS_CLUSTER_ID,
                  SnapshotName: snapshotName
              }).promise();
              
              console.log('Redis snapshot created:', snapshotName);
              
              return {
                  type: 'redis',
                  snapshotName,
                  status: result.Snapshot.SnapshotStatus,
                  timestamp
              };
          }

          async function backupConfiguration(timestamp) {
              // Backup serverless.yml and other config files
              const configData = {
                  timestamp,
                  environment: process.env.NODE_ENV,
                  metadata: {
                      backupType: 'configuration',
                      version: '1.0.0'
                  }
              };
              
              const key = `config-backups/${timestamp}/config-backup.json`;
              
              await s3.putObject({
                  Bucket: process.env.S3_BACKUP_BUCKET,
                  Key: key,
                  Body: JSON.stringify(configData, null, 2),
                  ContentType: 'application/json'
              }).promise();
              
              console.log('Configuration backup created:', key);
              
              return {
                  type: 'configuration',
                  s3Key: key,
                  timestamp
              };
          }

  # Backup S3 bucket
  BackupBucket:
    Type: AWS::S3::Bucket
    Properties:
      BucketName: !Sub '${Environment}-hasivu-backups-${AWS::AccountId}'
      BucketEncryption:
        ServerSideEncryptionConfiguration:
          - ServerSideEncryptionByDefault:
              SSEAlgorithm: AES256
            BucketKeyEnabled: true
      VersioningConfiguration:
        Status: Enabled
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        BlockPublicPolicy: true
        IgnorePublicAcls: true
        RestrictPublicBuckets: true
      LifecycleConfiguration:
        Rules:
          # Transition to IA after 30 days
          - Id: TransitionToIA
            Status: Enabled
            ExpirationInDays: 2555 # 7 years retention
            Transitions:
              - TransitionInDays: 30
                StorageClass: STANDARD_IA
              - TransitionInDays: 90
                StorageClass: GLACIER
              - TransitionInDays: 365
                StorageClass: DEEP_ARCHIVE
          # Delete old versions
          - Id: DeleteOldVersions
            Status: Enabled
            NoncurrentVersionExpirationInDays: 90

  # EventBridge rule for scheduled backups
  DailyBackupSchedule:
    Type: AWS::Events::Rule
    Properties:
      Name: !Sub '${Environment}-hasivu-daily-backup'
      Description: 'Triggers daily backup at 2 AM UTC'
      ScheduleExpression: 'cron(0 2 * * ? *)' # Daily at 2 AM UTC
      State: ENABLED
      Targets:
        - Arn: !GetAtt BackupLambdaFunction.Arn
          Id: 'DailyBackupTarget'
          Input: '{"backupType": "all", "schedule": "daily"}'

  # Weekly full backup schedule
  WeeklyBackupSchedule:
    Type: AWS::Events::Rule
    Properties:
      Name: !Sub '${Environment}-hasivu-weekly-backup'
      Description: 'Triggers weekly full backup on Sundays at 1 AM UTC'
      ScheduleExpression: 'cron(0 1 ? * SUN *)' # Weekly on Sundays at 1 AM UTC
      State: ENABLED
      Targets:
        - Arn: !GetAtt BackupLambdaFunction.Arn
          Id: 'WeeklyBackupTarget'
          Input: '{"backupType": "all", "schedule": "weekly", "fullBackup": true}'

  # Permission for EventBridge to invoke Lambda
  BackupLambdaInvokePermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref BackupLambdaFunction
      Action: lambda:InvokeFunction
      Principal: events.amazonaws.com
      SourceArn: !GetAtt DailyBackupSchedule.Arn

  WeeklyBackupLambdaInvokePermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref BackupLambdaFunction
      Action: lambda:InvokeFunction
      Principal: events.amazonaws.com
      SourceArn: !GetAtt WeeklyBackupSchedule.Arn

  # IAM Role for backup Lambda function
  BackupLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub '${Environment}-hasivu-backup-lambda-role'
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: BackupPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - rds:CreateDBSnapshot
                  - rds:DescribeDBSnapshots
                  - rds:DeleteDBSnapshot
                  - rds:CopyDBSnapshot
                Resource:
                  - !Sub 'arn:aws:rds:${AWS::Region}:${AWS::AccountId}:db:${Environment}-hasivu-postgres'
                  - !Sub 'arn:aws:rds:${AWS::Region}:${AWS::AccountId}:snapshot:manual-backup-*'
              - Effect: Allow
                Action:
                  - elasticache:CreateSnapshot
                  - elasticache:DescribeSnapshots
                  - elasticache:DeleteSnapshot
                Resource:
                  - !Sub 'arn:aws:elasticache:${AWS::Region}:${AWS::AccountId}:replicationgroup:${Environment}-hasivu-redis'
                  - !Sub 'arn:aws:elasticache:${AWS::Region}:${AWS::AccountId}:snapshot:manual-backup-*'
              - Effect: Allow
                Action:
                  - s3:PutObject
                  - s3:GetObject
                  - s3:DeleteObject
                  - s3:ListBucket
                Resource:
                  - !Sub '${BackupBucket}/*'
                  - !Ref BackupBucket
              - Effect: Allow
                Action:
                  - sns:Publish
                Resource: !Ref BackupNotificationTopic

  # Enhanced monitoring role for RDS
  RDSEnhancedMonitoringRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: monitoring.rds.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AmazonRDSEnhancedMonitoringRole

  # SNS topic for backup notifications
  BackupNotificationTopic:
    Type: AWS::SNS::Topic
    Properties:
      TopicName: !Sub '${Environment}-hasivu-backup-notifications'
      DisplayName: 'Hasivu Backup Notifications'

  # CloudWatch Dashboard for backup monitoring
  BackupDashboard:
    Type: AWS::CloudWatch::Dashboard
    Properties:
      DashboardName: !Sub '${Environment}-hasivu-backups'
      DashboardBody: !Sub |
        {
          "widgets": [
            {
              "type": "metric",
              "x": 0,
              "y": 0,
              "width": 12,
              "height": 6,
              "properties": {
                "metrics": [
                  ["AWS/RDS", "DatabaseConnections", "DBInstanceIdentifier", "${Environment}-hasivu-postgres"],
                  [".", "CPUUtilization", ".", "."],
                  [".", "ReadLatency", ".", "."],
                  [".", "WriteLatency", ".", "."]
                ],
                "period": 300,
                "stat": "Average",
                "region": "${AWS::Region}",
                "title": "Database Health for Backup Operations"
              }
            },
            {
              "type": "metric",
              "x": 12,
              "y": 0,
              "width": 12,
              "height": 6,
              "properties": {
                "metrics": [
                  ["AWS/Lambda", "Duration", "FunctionName", "${Environment}-hasivu-backup-manager"],
                  [".", "Errors", ".", "."],
                  [".", "Invocations", ".", "."]
                ],
                "period": 300,
                "stat": "Sum",
                "region": "${AWS::Region}",
                "title": "Backup Lambda Performance"
              }
            }
          ]
        }

  # Backup validation Lambda (checks backup integrity)
  BackupValidationFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub '${Environment}-hasivu-backup-validator'
      Runtime: nodejs18.x
      Handler: index.handler
      Timeout: 300
      MemorySize: 256
      Role: !GetAtt BackupValidationRole.Arn
      Environment:
        Variables:
          BACKUP_BUCKET: !Ref BackupBucket
          SNS_TOPIC_ARN: !Ref BackupNotificationTopic
      Code:
        ZipFile: |
          const AWS = require('aws-sdk');
          const rds = new AWS.RDS();
          const s3 = new AWS.S3();
          const sns = new AWS.SNS();

          exports.handler = async (event) => {
              console.log('Starting backup validation...', event);
              
              try {
                  // Validate recent snapshots exist
                  const validationResults = await validateRecentBackups();
                  
                  // Send validation report
                  await sns.publish({
                      TopicArn: process.env.SNS_TOPIC_ARN,
                      Subject: 'Backup Validation Report',
                      Message: JSON.stringify(validationResults, null, 2)
                  }).promise();
                  
                  return {
                      statusCode: 200,
                      body: JSON.stringify(validationResults)
                  };
                  
              } catch (error) {
                  console.error('Validation failed:', error);
                  throw error;
              }
          };

          async function validateRecentBackups() {
              const now = new Date();
              const oneDayAgo = new Date(now - 24 * 60 * 60 * 1000);
              
              // Check for recent DB snapshots
              const dbSnapshots = await rds.describeDBSnapshots({
                  DBInstanceIdentifier: process.env.DB_INSTANCE_IDENTIFIER,
                  SnapshotType: 'manual'
              }).promise();
              
              const recentDbSnapshots = dbSnapshots.DBSnapshots.filter(
                  snap => new Date(snap.SnapshotCreateTime) > oneDayAgo
              );
              
              return {
                  timestamp: now.toISOString(),
                  validation: {
                      databaseBackups: {
                          recent: recentDbSnapshots.length,
                          total: dbSnapshots.DBSnapshots.length,
                          status: recentDbSnapshots.length > 0 ? 'healthy' : 'warning'
                      }
                  }
              };
          }

  # IAM Role for backup validation
  BackupValidationRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: BackupValidationPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - rds:DescribeDBSnapshots
                  - elasticache:DescribeSnapshots
                  - s3:ListBucket
                  - s3:GetObject
                  - sns:Publish
                Resource: '*'

  # Daily backup validation schedule
  BackupValidationSchedule:
    Type: AWS::Events::Rule
    Properties:
      Name: !Sub '${Environment}-hasivu-backup-validation'
      Description: 'Daily backup validation at 8 AM UTC'
      ScheduleExpression: 'cron(0 8 * * ? *)' # Daily at 8 AM UTC
      State: ENABLED
      Targets:
        - Arn: !GetAtt BackupValidationFunction.Arn
          Id: 'BackupValidationTarget'

  # Permission for EventBridge to invoke validation Lambda
  BackupValidationInvokePermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref BackupValidationFunction
      Action: lambda:InvokeFunction
      Principal: events.amazonaws.com
      SourceArn: !GetAtt BackupValidationSchedule.Arn

Parameters:
  Environment:
    Type: String
    Description: Environment name (production, staging, development)
    Default: production

Outputs:
  BackupBucketName:
    Description: S3 bucket for backups
    Value: !Ref BackupBucket
    Export:
      Name: !Sub '${AWS::StackName}-backup-bucket'

  BackupLambdaArn:
    Description: ARN of the backup Lambda function
    Value: !GetAtt BackupLambdaFunction.Arn
    Export:
      Name: !Sub '${AWS::StackName}-backup-lambda'

  BackupNotificationTopicArn:
    Description: SNS topic for backup notifications
    Value: !Ref BackupNotificationTopic
    Export:
      Name: !Sub '${AWS::StackName}-backup-notifications'

  DatabaseEncryptionKeyId:
    Description: KMS key ID for database encryption
    Value: !Ref DatabaseEncryptionKey
    Export:
      Name: !Sub '${AWS::StackName}-db-encryption-key'
