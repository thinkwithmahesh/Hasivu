# HASIVU Platform - Complete API Integration Guide\n\n## üöÄ Overview\n\nThis guide documents the complete backend API integration for the HASIVU school food platform, featuring all ShadCN components fully connected with real-time updates, optimistic UI patterns, and production-ready error handling.\n\n## üìã Table of Contents\n\n- [Integration Architecture](#integration-architecture)\n- [API Client Features](#api-client-features)\n- [Component Integration](#component-integration)\n- [Real-time Features](#real-time-features)\n- [State Management](#state-management)\n- [Error Handling](#error-handling)\n- [Performance Optimization](#performance-optimization)\n- [Usage Examples](#usage-examples)\n- [Production Deployment](#production-deployment)\n\n## üèóÔ∏è Integration Architecture\n\n### Core Components\n\n```\nsrc/\n‚îú‚îÄ‚îÄ lib/\n‚îÇ   ‚îú‚îÄ‚îÄ api-client.ts              # Base API client with authentication\n‚îÇ   ‚îú‚îÄ‚îÄ enhanced-api-client.ts     # Enhanced client with component integration\n‚îÇ   ‚îî‚îÄ‚îÄ socket-client.ts           # WebSocket client for real-time updates\n‚îú‚îÄ‚îÄ hooks/\n‚îÇ   ‚îî‚îÄ‚îÄ useApiIntegration.ts       # Custom hooks for component integration\n‚îú‚îÄ‚îÄ store/slices/\n‚îÇ   ‚îú‚îÄ‚îÄ orderSlice.ts              # Enhanced Redux slice with API integration\n‚îÇ   ‚îú‚îÄ‚îÄ authSlice.ts               # Authentication state management\n‚îÇ   ‚îî‚îÄ‚îÄ [other slices...]          # Additional domain slices\n‚îú‚îÄ‚îÄ components/enhanced/\n‚îÇ   ‚îú‚îÄ‚îÄ OrderCard.tsx              # Real-time order component\n‚îÇ   ‚îú‚îÄ‚îÄ MealOrderingForm.tsx       # Complete ordering system\n‚îÇ   ‚îú‚îÄ‚îÄ RealTimeDashboard.tsx      # Live analytics dashboard\n‚îÇ   ‚îî‚îÄ‚îÄ RFIDVerificationPanel.tsx  # RFID integration component\n‚îî‚îÄ‚îÄ pages/\n    ‚îî‚îÄ‚îÄ integration-demo.tsx       # Complete integration demonstration\n```\n\n### Integration Flow\n\n1. **Authentication Layer**: JWT-based auth with automatic token refresh\n2. **API Client Layer**: Enhanced HTTP client with retry logic and error handling\n3. **WebSocket Layer**: Real-time updates and event handling\n4. **Component Layer**: ShadCN components with API integration\n5. **State Management**: Redux with optimistic updates and real-time sync\n\n## üîß API Client Features\n\n### Enhanced API Client (`enhanced-api-client.ts`)\n\n```typescript\n// Component integration\nconst response = await apiClient.request({\n  url: process.env.WEB_INTEGRATION_GUIDE_PASSWORD_1,\n  method: 'POST',\n  data: orderData,\n  componentId: 'order_form',\n  optimisticUpdate: {\n    type: 'create',\n    data: optimisticOrder,\n  },\n});\n\n// Real-time subscription\napiClient.subscribeToRealTime(\n  'order_component',\n  'order_status_update',\n  (data) => updateUI(data)\n);\n```\n\n### Key Features\n\n- ‚úÖ **Component State Management**: Automatic loading/error states per component\n- ‚úÖ **Optimistic Updates**: Immediate UI feedback with server reconciliation\n- ‚úÖ **Real-time Integration**: WebSocket sync with component updates\n- ‚úÖ **Offline Support**: Request queuing and automatic sync when online\n- ‚úÖ **Error Recovery**: Automatic retries with exponential backoff\n- ‚úÖ **Caching**: Intelligent caching with TTL and invalidation\n- ‚úÖ **File Uploads**: Progress tracking and component integration\n\n## üéØ Component Integration\n\n### Using the Enhanced Hooks\n\n```typescript\n// Simple API integration\nconst { data, loading, error, refetch } = useApi({\n  componentId: 'meal_list',\n  endpoint: '/meals/items',\n  params: { category: 'main-course' },\n});\n\n// Mutation with optimistic updates\nconst { mutate: createOrder, loading: creating } = useMutation(\n  '/orders/create',\n  'POST',\n  {\n    componentId: 'order_form',\n    optimisticUpdate: {\n      type: 'create',\n      data: orderData,\n    },\n    onSuccess: () => toast.success('Order placed!'),\n  }\n);\n\n// Real-time subscriptions\nuseRealTimeSubscription(\n  'order_tracking',\n  'order_status_update',\n  (update) => {\n    if (update.orderId === orderId) {\n      updateOrderStatus(update.status);\n    }\n  }\n);\n```\n\n### Component Examples\n\n#### Order Card with Real-time Updates\n\n```typescript\nexport function OrderCard({ order, onOrderUpdate }) {\n  const [localOrder, setLocalOrder] = useState(order);\n  \n  // Real-time updates\n  useRealTimeSubscription(\n    `order_${order.id}`,\n    'order_status_update',\n    (updateData) => {\n      if (updateData.orderId === order.id) {\n        const updatedOrder = { ...localOrder, ...updateData };\n        setLocalOrder(updatedOrder);\n        onOrderUpdate?.(updatedOrder);\n        \n        toast.success(`Order status: ${updateData.status}`);\n      }\n    }\n  );\n  \n  return (\n    <Card>\n      {/* Component implementation */}\n    </Card>\n  );\n}\n```\n\n#### Meal Ordering with Cart Management\n\n```typescript\nexport function MealOrderingForm({ onOrderComplete }) {\n  const [cart, setCart] = useState([]);\n  const { createOrder, creatingOrder } = useOrders();\n  \n  const handlePlaceOrder = async () => {\n    try {\n      const response = await createOrder({\n        items: cart.map(item => ({\n          id: item.id,\n          quantity: item.quantity,\n          customizations: item.selectedCustomizations,\n        })),\n        deliveryType: 'pickup',\n        paymentMethod: 'razorpay',\n      });\n      \n      clearCart();\n      onOrderComplete(response.data.id);\n    } catch (error) {\n      toast.error('Failed to place order');\n    }\n  };\n  \n  return (\n    <div>\n      {/* Meal selection and cart UI */}\n      <Button onClick={handlePlaceOrder} disabled={creatingOrder}>\n        {creatingOrder ? 'Placing Order...' : 'Place Order'}\n      </Button>\n    </div>\n  );\n}\n```\n\n## üì° Real-time Features\n\n### WebSocket Integration\n\n```typescript\n// Socket client setup\nconst socketClient = new SocketClient({\n  url: process.env.NEXT_PUBLIC_SOCKET_URL,\n  reconnectInterval: 3000,\n  maxReconnectAttempts: 10,\n});\n\n// Event subscriptions\nsocketClient.subscribe('order_status_update', (data) => {\n  store.dispatch(updateOrderStatus(data));\n});\n\nsocketClient.subscribe('payment_success', (data) => {\n  store.dispatch(addTransaction(data));\n});\n```\n\n### Real-time Events\n\n- **Order Updates**: `order_status_update`, `order_created`, `order_cancelled`\n- **Payment Events**: `payment_success`, `payment_failed`\n- **Delivery Tracking**: `delivery_started`, `delivery_completed`\n- **RFID Events**: `rfid_scan`, `card_verified`\n- **Notifications**: `notification`, `system_alert`\n- **Analytics**: `analytics_update`, `user_activity`\n\n## üóÉÔ∏è State Management\n\n### Enhanced Redux Integration\n\n```typescript\n// orderSlice.ts - Enhanced with API integration\nexport const fetchOrders = createAsyncThunk(\n  'orders/fetchOrders',\n  async (params) => {\n    const response = await api.orders.getHistory(params, 'orders_slice');\n    return response.data;\n  }\n);\n\nexport const createOrder = createAsyncThunk(\n  'orders/createOrder',\n  async (orderData) => {\n    const response = await api.orders.create(orderData, 'orders_slice');\n    return response.data;\n  }\n);\n\n// Real-time status updates\nconst orderSlice = createSlice({\n  name: 'orders',\n  initialState,\n  reducers: {\n    updateOrderStatus: (state, action) => {\n      const { orderId, status, timestamp } = action.payload;\n      \n      // Update in all relevant arrays\n      const orderIndex = state.orders.findIndex(order => order.id === orderId);\n      if (orderIndex >= 0) {\n        state.orders[orderIndex] = {\n          ...state.orders[orderIndex],\n          status,\n          updatedAt: timestamp,\n        };\n      }\n      \n      state.lastUpdated = timestamp;\n    },\n  },\n  extraReducers: (builder) => {\n    // Handle async thunks\n  },\n});\n```\n\n## üõ°Ô∏è Error Handling\n\n### Comprehensive Error Management\n\n```typescript\n// API Client Error Handling\nclass EnhancedApiClient {\n  private async handleRequest(config) {\n    try {\n      const response = await this.client(config);\n      return response.data;\n    } catch (error) {\n      // Network errors\n      if (!error.response) {\n        this.handleNetworkError(error, config);\n      }\n      \n      // Authentication errors\n      if (error.response.status === 401) {\n        return this.handleAuthError(error, config);\n      }\n      \n      // Retry for server errors\n      if (this.shouldRetry(error.response.status)) {\n        return this.handleRetry(config, error);\n      }\n      \n      // Component-specific error handling\n      if (config.componentId) {\n        this.updateComponentState(config.componentId, {\n          error: error.message,\n          loading: false,\n        });\n      }\n      \n      throw this.formatError(error);\n    }\n  }\n}\n```\n\n### Error Recovery Strategies\n\n- **Network Errors**: Queue requests for retry when connection restored\n- **Authentication**: Automatic token refresh with request replay\n- **Server Errors**: Exponential backoff retry with circuit breaker\n- **Validation Errors**: User-friendly field-specific error messages\n- **Optimistic Rollback**: Automatic UI rollback on operation failure\n\n## ‚ö° Performance Optimization\n\n### Optimization Features\n\n```typescript\n// Request batching\nconst batchedData = await apiClient.batch([\n  { url: '/meals/items', method: 'GET' },\n  { url: '/orders/active', method: 'GET' },\n  { url: '/notifications', method: 'GET' },\n]);\n\n// Data prefetching\nawait apiClient.prefetch('/meals/popular', { silent: true });\n\n// Intelligent caching\nconst cachedData = apiClient.getCachedData('meals_list');\nif (cachedData) {\n  return cachedData;\n}\n\n// Connection pooling and keep-alive\nconst client = axios.create({\n  keepAlive: true,\n  maxSockets: 10,\n});\n```\n\n### Performance Metrics\n\n- **API Response Times**: < 200ms for cached data, < 500ms for fresh data\n- **WebSocket Latency**: < 50ms for real-time updates\n- **Bundle Size**: Optimized with code splitting and lazy loading\n- **Memory Usage**: Efficient state management with cleanup\n- **Offline Capability**: Full functionality with background sync\n\n## üìù Usage Examples\n\n### Complete Integration Example\n\n```typescript\n// pages/orders.tsx\nfunction OrdersPage() {\n  const { orders, loading, error, refetch } = useOrders();\n  const { createOrder } = useOrders();\n  \n  // Real-time updates\n  useRealTimeSubscription(\n    'orders_page',\n    'order_status_update',\n    () => refetch()\n  );\n  \n  if (loading) return <LoadingSpinner />;\n  if (error) return <ErrorMessage error={error} retry={refetch} />;\n  \n  return (\n    <div>\n      {orders.map(order => (\n        <OrderCard \n          key={order.id} \n          order={order}\n          onOrderUpdate={(updated) => {\n            // Handle real-time updates\n          }}\n        />\n      ))}\n    </div>\n  );\n}\n```\n\n### Custom Hook Example\n\n```typescript\n// Custom domain-specific hook\nfunction useRestaurantMenu(restaurantId: string) {\n  const {\n    data: menu,\n    loading,\n    error,\n    refetch\n  } = useApi({\n    componentId: `menu_${restaurantId}`,\n    endpoint: `/restaurants/${restaurantId}/menu`,\n    enabled: !!restaurantId,\n    staleTime: 600000, // 10 minutes\n  });\n  \n  // Real-time menu updates\n  useRealTimeSubscription(\n    `menu_${restaurantId}`,\n    'menu_item_availability',\n    (update) => {\n      if (update.restaurantId === restaurantId) {\n        refetch();\n      }\n    }\n  );\n  \n  return { menu, loading, error, refetch };\n}\n```\n\n## üöÄ Production Deployment\n\n### Environment Configuration\n\n```bash\n# .env.production\nNEXT_PUBLIC_API_URL=https://api.hasivu.com/v1\nNEXT_PUBLIC_SOCKET_URL=https://ws.hasivu.com\nNEXT_PUBLIC_APP_VERSION=2.0.0\n\n# Performance settings\nAPI_TIMEOUT=30000\nMAX_RETRIES=3\nCACHE_TTL=300000\n\n# Feature flags\nENABLE_OPTIMISTIC_UPDATES=true\nENABLE_OFFLINE_MODE=true\nENABLE_REAL_TIME_SYNC=true\n```\n\n### Build Optimization\n\n```javascript\n// next.config.js\nmodule.exports = {\n  // Bundle analysis\n  webpack: (config, { dev, isServer }) => {\n    if (!dev && !isServer) {\n      config.optimization.splitChunks.chunks = 'all';\n    }\n    return config;\n  },\n  \n  // Performance optimizations\n  experimental: {\n    modernMode: true,\n    polyfillsOptimization: true,\n  },\n  \n  // PWA configuration\n  pwa: {\n    dest: 'public',\n    disable: process.env.NODE_ENV === 'development',\n  },\n};\n```\n\n### Monitoring & Analytics\n\n```typescript\n// Performance monitoring\nconst performanceMonitor = {\n  trackApiCall: (endpoint: string, duration: number) => {\n    // Send to analytics service\n  },\n  \n  trackError: (error: Error, context: any) => {\n    // Error tracking\n  },\n  \n  trackUserAction: (action: string, metadata: any) => {\n    // User analytics\n  },\n};\n```\n\n## üîç Testing\n\n### API Integration Tests\n\n```typescript\n// __tests__/api-integration.test.ts\ndescribe('API Integration', () => {\n  test('should handle optimistic updates', async () => {\n    const mockOrder = { id: '123', status: 'pending' };\n    \n    const optimisticId = apiClient.performOptimisticUpdate(\n      'test_component',\n      'create',\n      mockOrder\n    );\n    \n    expect(optimisticId).toBeTruthy();\n    expect(apiClient.getComponentState('test_component').data).toEqual(mockOrder);\n  });\n  \n  test('should handle real-time updates', async () => {\n    const callback = jest.fn();\n    \n    const unsubscribe = apiClient.subscribeToRealTime(\n      'test_component',\n      'order_update',\n      callback\n    );\n    \n    // Simulate real-time event\n    socketClient.emit('order_update', { orderId: '123', status: 'completed' });\n    \n    expect(callback).toHaveBeenCalled();\n    unsubscribe();\n  });\n});\n```\n\n## üìö API Reference\n\n### Enhanced API Client Methods\n\n- `registerComponent(id, initialState)` - Register component for state management\n- `subscribeToRealTime(id, event, callback, filter)` - Subscribe to real-time events\n- `performOptimisticUpdate(id, type, data, rollback)` - Perform optimistic UI updates\n- `request(config)` - Enhanced request with component integration\n- `batch(requests)` - Batch multiple requests\n- `upload(endpoint, file, onProgress, config)` - File upload with progress\n- `prefetch(endpoint, params)` - Data prefetching\n- `getCachedData(key)` - Retrieve cached data\n\n### Custom Hooks\n\n- `useApi(options)` - Generic API hook with real-time updates\n- `useMutation(endpoint, method, options)` - Mutation hook with optimistic updates\n- `useAuth()` - Authentication state and methods\n- `useOrders(params)` - Order management hook\n- `useMeals(params)` - Meal data hook\n- `useNotifications()` - Notification management hook\n- `useRFID()` - RFID verification hook\n- `useAnalytics(params)` - Analytics data hook\n- `useFileUpload()` - File upload hook\n- `useConnectionStatus()` - WebSocket connection status\n\n## üéØ Next Steps\n\n1. **Integration Testing**: Comprehensive E2E tests for all components\n2. **Performance Monitoring**: Real-time performance metrics and alerting\n3. **Feature Flags**: A/B testing and gradual feature rollouts\n4. **Mobile App Integration**: React Native components with shared API layer\n5. **Advanced Caching**: Redis integration for server-side caching\n6. **Microservices**: Breaking down monolithic API into domain services\n\n## ü§ù Support\n\nFor questions or issues with the API integration:\n\n- üìß **Email**: dev@hasivu.com\n- üìö **Documentation**: [https://docs.hasivu.com](https://docs.hasivu.com)\n- üêõ **Bug Reports**: [GitHub Issues](https://github.com/hasivu/platform/issues)\n- üí¨ **Community**: [Discord Server](https://discord.gg/hasivu)\n\n---\n\n**Built with ‚ù§Ô∏è for HASIVU Platform**\n\n*Complete ShadCN + API Integration ‚Ä¢ Real-time Updates ‚Ä¢ Production Ready*"