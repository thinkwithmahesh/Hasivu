/**
 * HASIVU Platform - Progress Bar Component
 * Top page progress bar for navigation transitions with smooth animations
 * Generated by SuperClaude Frontend Implementation
 */

import React, { useState, useEffect, useRef } from 'react';
import { Box, LinearProgress, useTheme, alpha, Portal, Fade } from '@mui/material';
import { keyframes } from '@mui/system';

// Custom animations for progress bar
const progressGlow = keyframes`
  0% {
    box-shadow: 0 0 5px rgba(76, 175, 80, 0.4);
  }
  50% {
    box-shadow: 0 0 15px rgba(76, 175, 80, 0.8);
  }
  100% {
    box-shadow: 0 0 5px rgba(76, 175, 80, 0.4);
  }
`;

const shimmerAnimation = keyframes`
  0% {
    transform: translateX(-100%);
  }
  100% {
    transform: translateX(100%);
  }
`;

const pulseAnimation = keyframes`
  0%, 100% {
    opacity: 1;
  }
  50% {
    opacity: 0.7;
  }
`;

/**
 * Progress Bar Props Interface
 */
export interface ProgressBarProps {
  /** Show/hide the progress bar */
  visible?: boolean;
  /** Progress value (0-100) */
  progress?: number;
  /** Animation duration in milliseconds */
  duration?: number;
  /** Color theme */
  color?: 'primary' | 'secondary' | 'success' | 'warning' | 'error';
  /** Height of the progress bar */
  height?: number;
  /** Show glow effect */
  showGlow?: boolean;
  /** Show shimmer effect */
  showShimmer?: boolean;
  /** Enable pulsing animation */
  showPulse?: boolean;
  /** Custom z-index */
  zIndex?: number;
  /** Position from top */
  top?: number;
  /** Enable smooth transitions */
  smooth?: boolean;
  /** Minimum progress to show */
  minimum?: number;
  /** Maximum progress to show */
  maximum?: number;
}

/**
 * Progress Bar Context for managing global progress state
 */
export interface ProgressBarContextType {
  start: (duration?: number) => void;
  finish: () => void;
  set: (progress: number) => void;
  increment: (amount?: number) => void;
  isVisible: boolean;
  progress: number;
}

const ProgressBarContext = React.createContext<ProgressBarContextType | null>(null);

/**
 * Hook to use progress bar context
 */
export const useProgressBar = (): ProgressBarContextType => {
  const context = React.useContext(ProgressBarContext);
  if (!context) {
    throw new Error('useProgressBar must be used within a ProgressBarProvider');
  }
  return context;
};

/**
 * Progress Bar Provider Component
 */
export interface ProgressBarProviderProps {
  children: React.ReactNode;
  config?: Partial<ProgressBarProps>;
}

export const ProgressBarProvider: React.FC<ProgressBarProviderProps> = ({
  children,
  config = {},
}) => {
  const [isVisible, setIsVisible] = useState(false);
  const [progress, setProgress] = useState(0);
  const [isAnimating, setIsAnimating] = useState(false);
  const timerRef = useRef<NodeJS.Timeout | null>(null);
  const incrementTimerRef = useRef<NodeJS.Timeout | null>(null);

  const start = (duration: number = 2000) => {
    if (timerRef.current) {
      clearTimeout(timerRef.current);
    }
    if (incrementTimerRef.current) {
      clearInterval(incrementTimerRef.current);
    }

    setProgress(0);
    setIsVisible(true);
    setIsAnimating(true);

    // Simulate gradual progress
    let currentProgress = 0;
    const increment = Math.random() * 5 + 5; // 5-10% increments
    const intervalDuration = duration / 20; // 20 updates total

    incrementTimerRef.current = setInterval(() => {
      currentProgress += increment;
      if (currentProgress >= 90) {
        currentProgress = 90; // Stop at 90% until finish is called
        if (incrementTimerRef.current) {
          clearInterval(incrementTimerRef.current);
        }
      }
      setProgress(currentProgress);
    }, intervalDuration);
  };

  const finish = () => {
    if (incrementTimerRef.current) {
      clearInterval(incrementTimerRef.current);
    }

    setProgress(100);
    setIsAnimating(false);

    // Hide after completion animation
    timerRef.current = setTimeout(() => {
      setIsVisible(false);
      setProgress(0);
    }, 400);
  };

  const set = (newProgress: number) => {
    const clampedProgress = Math.min(Math.max(newProgress, 0), 100);
    setProgress(clampedProgress);
    if (!isVisible && clampedProgress > 0) {
      setIsVisible(true);
    }
  };

  const increment = (amount: number = 5) => {
    setProgress(prev => Math.min(prev + amount, 90));
  };

  // Cleanup timers on unmount
  useEffect(() => {
    return () => {
      if (timerRef.current) {
        clearTimeout(timerRef.current);
      }
      if (incrementTimerRef.current) {
        clearInterval(incrementTimerRef.current);
      }
    };
  }, []);

  const contextValue: ProgressBarContextType = {
    start,
    finish,
    set,
    increment,
    isVisible,
    progress,
  };

  return (
    <ProgressBarContext.Provider value={contextValue}>
      {children}
      <ProgressBar
        visible={isVisible}
        progress={progress}
        showGlow={isAnimating}
        showShimmer={isAnimating}
        showPulse={progress >= 90 && isAnimating}
        {...config}
      />
    </ProgressBarContext.Provider>
  );
};

/**
 * HASIVU Progress Bar Component
 *
 * Features:
 * - NProgress-style top progress bar
 * - Smooth animations and transitions
 * - Customizable colors and effects
 * - Mobile-responsive design
 * - Accessibility compliant
 * - School-friendly HASIVU theming
 * - Multiple animation effects (glow, shimmer, pulse)
 */
export const ProgressBar: React.FC<ProgressBarProps> = ({
  visible = false,
  progress = 0,
  duration = 300,
  color = 'primary',
  height = 3,
  showGlow = false,
  showShimmer = false,
  showPulse = false,
  zIndex = 2000,
  top = 0,
  smooth = true,
  minimum = 5,
  maximum = 100,
}) => {
  const theme = useTheme();

  // Clamp progress between minimum and maximum values
  const clampedProgress = Math.min(Math.max(progress, minimum), maximum);
  const displayProgress = visible && progress > 0 ? clampedProgress : 0;

  // Get color from theme
  const getColor = () => {
    switch (color) {
      case 'secondary':
        return theme.palette.secondary.main;
      case 'success':
        return theme.palette.success.main;
      case 'warning':
        return theme.palette.warning.main;
      case 'error':
        return theme.palette.error.main;
      default:
        return theme.palette.primary.main;
    }
  };

  const progressColor = getColor();
  const glowColor = alpha(progressColor, 0.6);

  if (!visible && displayProgress === 0) {
    return null;
  }

  return (
    <Portal>
      <Fade in={visible} timeout={200}>
        <Box
          sx={{
            position: 'fixed',
            top,
            left: 0,
            right: 0,
            height,
            zIndex,
            backgroundColor: alpha(progressColor, 0.1),
            overflow: 'hidden',
          }}
          role="progressbar"
          aria-valuenow={Math.round(displayProgress)}
          aria-valuemin={0}
          aria-valuemax={100}
          aria-label="Page loading progress"
        >
          {/* Main progress bar */}
          <Box
            sx={{
              height: '100%',
              width: `${displayProgress}%`,
              backgroundColor: progressColor,
              position: 'relative',
              transition: smooth ? `width ${duration}ms cubic-bezier(0.4, 0, 0.2, 1)` : 'none',
              ...(showGlow && {
                animation: `${progressGlow} 2s ease-in-out infinite`,
              }),
              ...(showPulse && {
                animation: `${pulseAnimation} 1s ease-in-out infinite`,
              }),
            }}
          >
            {/* Shimmer effect overlay */}
            {showShimmer && (
              <Box
                sx={{
                  position: 'absolute',
                  top: 0,
                  left: 0,
                  bottom: 0,
                  width: '100px',
                  background: `linear-gradient(90deg, transparent, ${alpha(
                    theme.palette.common.white,
                    0.4
                  )}, transparent)`,
                  animation: `${shimmerAnimation} 2s infinite`,
                }}
              />
            )}

            {/* Glow effect */}
            {showGlow && (
              <Box
                sx={{
                  position: 'absolute',
                  top: -2,
                  left: 0,
                  right: 0,
                  bottom: -2,
                  background: `linear-gradient(90deg, ${alpha(
                    progressColor,
                    0.8
                  )}, ${alpha(progressColor, 0.4)})`,
                  filter: 'blur(4px)',
                  opacity: 0.7,
                  zIndex: -1,
                }}
              />
            )}

            {/* End cap for visual appeal */}
            <Box
              sx={{
                position: 'absolute',
                top: 0,
                right: 0,
                bottom: 0,
                width: 8,
                background: `linear-gradient(90deg, ${progressColor}, ${alpha(
                  progressColor,
                  0.8
                )})`,
                borderTopRightRadius: height / 2,
                borderBottomRightRadius: height / 2,
                ...(showGlow && {
                  boxShadow: `0 0 8px ${glowColor}`,
                }),
              }}
            />
          </Box>

          {/* Background loading indicator for indeterminate progress */}
          {displayProgress === 0 && visible && (
            <LinearProgress
              sx={{
                height: '100%',
                backgroundColor: 'transparent',
                '& .MuiLinearProgress-bar': {
                  backgroundColor: progressColor,
                  ...(showGlow && {
                    boxShadow: `0 0 8px ${glowColor}`,
                  }),
                },
                '& .MuiLinearProgress-bar1Indeterminate': {
                  animation:
                    'MuiLinearProgress-keyframes-indeterminate1 2.1s cubic-bezier(0.65, 0.815, 0.735, 0.395) infinite',
                },
                '& .MuiLinearProgress-bar2Indeterminate': {
                  animation:
                    'MuiLinearProgress-keyframes-indeterminate2 2.1s cubic-bezier(0.165, 0.84, 0.44, 1) 1.15s infinite',
                },
              }}
            />
          )}
        </Box>
      </Fade>
    </Portal>
  );
};

/**
 * Router Integration Hook
 * For automatic progress bar on route changes
 */
export const useRouterProgress = () => {
  const progressBar = useProgressBar();

  useEffect(() => {
    const handleRouteChangeStart = () => {
      progressBar.start();
    };

    const handleRouteChangeComplete = () => {
      progressBar.finish();
    };

    const handleRouteChangeError = () => {
      progressBar.finish();
    };

    // For Next.js router events
    if (typeof window !== 'undefined' && window.next?.router) {
      const { router } = window.next;
      router.events.on('routeChangeStart', handleRouteChangeStart);
      router.events.on('routeChangeComplete', handleRouteChangeComplete);
      router.events.on('routeChangeError', handleRouteChangeError);

      return () => {
        router.events.off('routeChangeStart', handleRouteChangeStart);
        router.events.off('routeChangeComplete', handleRouteChangeComplete);
        router.events.off('routeChangeError', handleRouteChangeError);
      };
    }

    // For React Router or manual navigation
    const handlePopState = () => {
      progressBar.start();
      setTimeout(() => progressBar.finish(), 500);
    };

    window.addEventListener('popstate', handlePopState);
    return () => window.removeEventListener('popstate', handlePopState);
  }, [progressBar]);

  return progressBar;
};

export default ProgressBar;

// Type augmentation for Next.js router events
declare global {
  interface Window {
    next?: {
      router?: {
        events: {
          on: (event: string, handler: () => void) => void;
          off: (event: string, handler: () => void) => void;
        };
      };
    };
  }
}
