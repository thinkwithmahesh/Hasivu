"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.logDebug = exports.logInfo = exports.logWarning = exports.logError = exports.createTimer = exports.PerformanceTimer = exports.createRequestLogger = exports.log = exports.logger = exports.Logger = void 0;
/**
 * HASIVU Platform - Logging Service
 * Production-ready Winston logger with structured logging
 * Implements comprehensive logging with performance tracking
 * Generated by SuperClaude Wave 3: Epic 3 Implementation - UTILITIES
 */
const winston = require("winston");
// Environment detection
const NODE_ENV = process.env.NODE_ENV || 'development';
const LOG_LEVEL = process.env.LOG_LEVEL || (NODE_ENV === 'production' ? 'info' : 'debug');
/**
 * Custom log format for structured logging
 */
const logFormat = winston.format.combine(winston.format.timestamp({
    format: 'YYYY-MM-DD HH:mm:ss'
}), winston.format.errors({ stack: true }), winston.format.json(), winston.format.printf(({ timestamp, level, message, service, ...meta }) => {
    const logEntry = {
        timestamp,
        level: level.toUpperCase(),
        message,
        service: service || 'hasivu-platform',
        environment: NODE_ENV,
        ...meta
    };
    return JSON.stringify(logEntry);
}));
/**
 * Console format for development
 */
const consoleFormat = winston.format.combine(winston.format.timestamp({
    format: 'YYYY-MM-DD HH:mm:ss'
}), winston.format.errors({ stack: true }), winston.format.colorize({ all: true }), winston.format.printf(({ timestamp, level, message, service, ...meta }) => {
    let logMessage = `[${timestamp}] ${level}: ${message}`;
    if (service) {
        logMessage = `[${timestamp}] [${service}] ${level}: ${message}`;
    }
    if (Object.keys(meta).length > 0) {
        logMessage += `\n${JSON.stringify(meta, null, 2)}`;
    }
    return logMessage;
}));
/**
 * Create transports based on environment
 */
const transports = [
    new winston.transports.Console({
        format: NODE_ENV === 'production' ? logFormat : consoleFormat,
        level: LOG_LEVEL
    })
];
// Add file transport in production
if (NODE_ENV === 'production') {
    transports.push(new winston.transports.File({
        filename: 'logs/error.log',
        level: 'error',
        format: logFormat,
        maxsize: 10485760, // 10MB
        maxFiles: 5
    }), new winston.transports.File({
        filename: 'logs/combined.log',
        format: logFormat,
        maxsize: 10485760, // 10MB
        maxFiles: 10
    }));
}
/**
 * Create Winston logger instance
 */
const logger = winston.createLogger({
    level: LOG_LEVEL,
    format: logFormat,
    defaultMeta: {
        service: 'hasivu-platform',
        environment: NODE_ENV
    },
    transports,
    exitOnError: false,
    silent: NODE_ENV === 'test'
});
/**
 * Enhanced logger with additional methods
 */
class Logger {
    static instance;
    logger;
    constructor(logger) {
        this.logger = logger;
    }
    /**
     * Get singleton instance of Logger
     */
    static getInstance() {
        if (!Logger.instance) {
            Logger.instance = new Logger(logger);
        }
        return Logger.instance;
    }
    /**
     * Debug level logging
     */
    debug(message, context) {
        this.logger.debug(message, context);
    }
    /**
     * Info level logging
     */
    info(message, context) {
        this.logger.info(message, context);
    }
    /**
     * Warning level logging
     */
    warn(message, context) {
        this.logger.warn(message, context);
    }
    /**
     * Error level logging
     */
    error(message, error, context) {
        const errorContext = {
            ...context,
            ...(error && {
                error: {
                    name: error.name,
                    message: error.message,
                    stack: error.stack,
                    ...error
                }
            })
        };
        this.logger.error(message, errorContext);
    }
    /**
     * Performance logging with timing
     */
    performance(message, duration, context) {
        this.logger.info(message, {
            ...context,
            duration: `${duration}ms`,
            type: 'performance'
        });
    }
    /**
     * Security event logging
     */
    security(message, context) {
        this.logger.warn(message, {
            ...context,
            type: 'security',
            severity: 'high'
        });
    }
    /**
     * Audit logging
     */
    audit(message, context) {
        this.logger.info(message, {
            ...context,
            type: 'audit'
        });
    }
    /**
     * Database operation logging
     */
    database(message, context) {
        this.logger.debug(message, {
            ...context,
            type: 'database'
        });
    }
    /**
     * API request logging
     */
    request(message, context) {
        this.logger.info(message, {
            ...context,
            type: 'request'
        });
    }
    /**
     * Business logic logging
     */
    business(message, context) {
        this.logger.info(message, {
            ...context,
            type: 'business'
        });
    }
    /**
     * Integration logging (external services)
     */
    integration(message, context) {
        this.logger.info(message, {
            ...context,
            type: 'integration'
        });
    }
    /**
     * Function start logging (legacy compatibility)
     */
    logFunctionStart(functionName, context) {
        this.logger.info(`Function started: ${functionName}`, {
            ...context,
            type: 'function',
            event: 'start'
        });
    }
    /**
     * Function end logging (legacy compatibility)
     */
    logFunctionEnd(functionName, context) {
        this.logger.info(`Function completed: ${functionName}`, {
            ...context,
            type: 'function',
            event: 'end'
        });
    }
    /**
     * Create child logger with additional context
     */
    child(defaultContext) {
        const childLogger = this.logger.child(defaultContext);
        return new Logger(childLogger);
    }
    /**
     * Get the underlying Winston logger
     */
    getWinstonLogger() {
        return this.logger;
    }
}
exports.Logger = Logger;
// Create and export enhanced logger instance
const enhancedLogger = new Logger(logger);
exports.logger = enhancedLogger;
exports.default = enhancedLogger;
// Legacy export for backward compatibility
exports.log = enhancedLogger;
/**
 * Request logging middleware helper
 */
const createRequestLogger = (requestId, userId) => {
    return enhancedLogger.child({
        requestId,
        userId,
        type: 'request'
    });
};
exports.createRequestLogger = createRequestLogger;
/**
 * Performance timer utility
 */
class PerformanceTimer {
    startTime;
    label;
    logger;
    constructor(label, logger = enhancedLogger) {
        this.label = label;
        this.logger = logger;
        this.startTime = Date.now();
    }
    /**
     * End timing and log performance
     */
    end(context) {
        const duration = Date.now() - this.startTime;
        this.logger.performance(`${this.label} completed`, duration, context);
        return duration;
    }
    /**
     * Get current duration without logging
     */
    getDuration() {
        return Date.now() - this.startTime;
    }
}
exports.PerformanceTimer = PerformanceTimer;
/**
 * Create performance timer
 */
const createTimer = (label) => {
    return new PerformanceTimer(label);
};
exports.createTimer = createTimer;
/**
 * Log structured errors
 */
const logError = (error, context) => {
    enhancedLogger.error('Unhandled error occurred', error, context);
};
exports.logError = logError;
/**
 * Log structured warnings
 */
const logWarning = (message, context) => {
    enhancedLogger.warn(message, context);
};
exports.logWarning = logWarning;
/**
 * Log structured info
 */
const logInfo = (message, context) => {
    enhancedLogger.info(message, context);
};
exports.logInfo = logInfo;
/**
 * Log structured debug
 */
const logDebug = (message, context) => {
    enhancedLogger.debug(message, context);
};
exports.logDebug = logDebug;
