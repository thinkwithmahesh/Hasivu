"use strict";
/**
 * HASIVU Platform - Payment Routes
 * Razorpay payment gateway API endpoints
 * Generated by SuperClaude Wave 4: Payment Integration
 */
Object.defineProperty(exports, "__esModule", { value: true });
const express_1 = require("express");
const express_validator_1 = require("express-validator");
const payment_service_1 = require("@/services/payment.service");
const auth_middleware_1 = require("@/middleware/auth.middleware");
const request_logger_middleware_1 = require("@/middleware/request-logger.middleware");
const rateLimiter_middleware_1 = require("@/middleware/rateLimiter.middleware");
const logger_1 = require("@/utils/logger");
const router = (0, express_1.Router)();
/**
 * Validation middleware
 */
const handleValidationErrors = (req, res, next) => {
    const errors = (0, express_validator_1.validationResult)(req);
    if (!errors.isEmpty()) {
        res.status(400).json({
            success: false,
            message: 'Validation failed',
            error: {
                code: 'VALIDATION_ERROR',
                message: 'Validation failed',
                details: errors.array(),
                timestamp: new Date().toISOString()
            },
            timestamp: new Date().toISOString(),
            version: '1.0'
        });
        return;
    }
    next();
};
/**
 * Apply middleware to all routes
 */
router.use(request_logger_middleware_1.default);
// Use the default rate limiter for payments
router.use(rateLimiter_middleware_1.generalRateLimit);
/**
 * Create payment order
 * POST /api/v1/payments/orders
 */
router.post('/orders', auth_middleware_1.authMiddleware, [
    (0, express_validator_1.body)('amount')
        .isFloat({ min: 1 })
        .withMessage('Amount must be a positive number'),
    (0, express_validator_1.body)('currency')
        .isIn(['INR', 'USD'])
        .withMessage('Currency must be INR or USD'),
    (0, express_validator_1.body)('orderId')
        .optional()
        .isUUID()
        .withMessage('Order ID must be a valid UUID'),
    (0, express_validator_1.body)('subscriptionId')
        .optional()
        .isUUID()
        .withMessage('Subscription ID must be a valid UUID'),
    (0, express_validator_1.body)('description')
        .isString()
        .isLength({ min: 1, max: 255 })
        .withMessage('Description is required and must be less than 255 characters'),
    (0, express_validator_1.body)('notes')
        .optional()
        .isObject()
        .withMessage('Notes must be an object'),
    (0, express_validator_1.body)('receipt')
        .optional()
        .isString()
        .isLength({ max: 40 })
        .withMessage('Receipt must be less than 40 characters')
], handleValidationErrors, async (req, res, next) => {
    try {
        const { amount, currency, orderId, subscriptionId, description, notes, receipt } = req.body;
        const paymentOrder = await payment_service_1.paymentService.createPaymentOrder({
            userId: req.user.id,
            amount,
            currency,
            notes,
            receipt
        });
        const razorpayConfig = {
            key: process.env.RAZORPAY_KEY_ID,
            order_id: paymentOrder.razorpayOrderId,
            amount: paymentOrder.amount,
            currency: paymentOrder.currency,
            name: 'HASIVU Platform',
            description: description || 'HASIVU Platform Payment',
            prefill: {
                email: req.user.email,
                contact: ''
            },
            theme: {
                color: '#3B82F6'
            }
        };
        res.status(201).json({
            success: true,
            data: {
                paymentOrder,
                razorpayConfig
            },
            message: 'Payment order created successfully',
            timestamp: new Date().toISOString(),
            version: '1.0'
        });
    }
    catch (error) {
        logger_1.logger.error('Create payment order error:', error);
        next(error);
    }
});
/**
 * Verify and complete payment
 * POST /api/v1/payments/verify
 */
router.post('/verify', auth_middleware_1.authMiddleware, [
    (0, express_validator_1.body)('razorpay_payment_id')
        .isString()
        .notEmpty()
        .withMessage('Razorpay payment ID is required'),
    (0, express_validator_1.body)('razorpay_order_id')
        .isString()
        .notEmpty()
        .withMessage('Razorpay order ID is required'),
    (0, express_validator_1.body)('razorpay_signature')
        .isString()
        .notEmpty()
        .withMessage('Razorpay signature is required')
], handleValidationErrors, async (req, res, next) => {
    try {
        const { razorpay_payment_id, razorpay_order_id, razorpay_signature } = req.body;
        const transaction = await payment_service_1.paymentService.capturePayment(razorpay_order_id, razorpay_payment_id, razorpay_signature);
        res.json({
            success: true,
            data: transaction,
            message: 'Payment verified and completed successfully',
            timestamp: new Date().toISOString(),
            version: '1.0'
        });
    }
    catch (error) {
        logger_1.logger.error('Payment verification error:', error);
        next(error);
    }
});
/**
 * Create refund
 * POST /api/v1/payments/refunds
 */
router.post('/refunds', auth_middleware_1.authMiddleware, [
    (0, express_validator_1.body)('paymentId')
        .isString()
        .notEmpty()
        .withMessage('Payment ID is required'),
    (0, express_validator_1.body)('amount')
        .optional()
        .isFloat({ min: 1 })
        .withMessage('Amount must be a positive number'),
    (0, express_validator_1.body)('reason')
        .isString()
        .isLength({ min: 1, max: 255 })
        .withMessage('Reason is required and must be less than 255 characters'),
    (0, express_validator_1.body)('notes')
        .optional()
        .isObject()
        .withMessage('Notes must be an object')
], handleValidationErrors, async (req, res, next) => {
    try {
        const { paymentId, amount, reason, notes } = req.body;
        const refund = await payment_service_1.paymentService.createRefund(paymentId, amount, reason);
        res.status(201).json({
            success: true,
            data: refund,
            message: 'Refund initiated successfully',
            timestamp: new Date().toISOString(),
            version: '1.0'
        });
    }
    catch (error) {
        logger_1.logger.error('Create refund error:', error);
        next(error);
    }
});
/**
 * Create subscription
 * POST /api/v1/payments/subscriptions
 */
router.post('/subscriptions', auth_middleware_1.authMiddleware, [
    (0, express_validator_1.body)('planId')
        .isString()
        .notEmpty()
        .withMessage('Plan ID is required'),
    (0, express_validator_1.body)('totalCount')
        .optional()
        .isInt({ min: 1 })
        .withMessage('Total count must be a positive integer'),
    (0, express_validator_1.body)('startAt')
        .optional()
        .isISO8601()
        .withMessage('Start date must be a valid ISO 8601 date'),
    (0, express_validator_1.body)('addons')
        .optional()
        .isArray()
        .withMessage('Addons must be an array'),
    (0, express_validator_1.body)('notes')
        .optional()
        .isObject()
        .withMessage('Notes must be an object')
], handleValidationErrors, async (req, res, next) => {
    try {
        const { planId, totalCount, startAt, addons, notes } = req.body;
        const subscription = await payment_service_1.paymentService.createSubscription({
            userId: req.user.id,
            planId,
            notes
        });
        res.status(201).json({
            success: true,
            data: subscription,
            message: 'Subscription created successfully',
            timestamp: new Date().toISOString(),
            version: '1.0'
        });
    }
    catch (error) {
        logger_1.logger.error('Create subscription error:', error);
        next(error);
    }
});
/**
 * Get transaction history
 * GET /api/v1/payments/transactions
 */
router.get('/transactions', auth_middleware_1.authMiddleware, [
    (0, express_validator_1.query)('status')
        .optional()
        .isIn(['created', 'authorized', 'captured', 'refunded', 'failed'])
        .withMessage('Invalid status'),
    (0, express_validator_1.query)('startDate')
        .optional()
        .isISO8601()
        .toDate()
        .withMessage('Start date must be a valid ISO 8601 date'),
    (0, express_validator_1.query)('endDate')
        .optional()
        .isISO8601()
        .toDate()
        .withMessage('End date must be a valid ISO 8601 date'),
    (0, express_validator_1.query)('limit')
        .optional()
        .isInt({ min: 1, max: 100 })
        .toInt()
        .withMessage('Limit must be between 1 and 100'),
    (0, express_validator_1.query)('offset')
        .optional()
        .isInt({ min: 0 })
        .toInt()
        .withMessage('Offset must be a non-negative integer')
], handleValidationErrors, async (req, res, next) => {
    try {
        const { status, startDate, endDate, limit = 20, offset = 0 } = req.query;
        const result = await payment_service_1.paymentService.viewAllPayments({
            userId: req.user.id,
            status: status,
            startDate: startDate ? new Date(startDate) : undefined,
            endDate: endDate ? new Date(endDate) : undefined,
            limit: limit,
            offset: offset
        });
        res.json({
            success: true,
            data: {
                transactions: result.data || [],
                pagination: {
                    limit,
                    offset,
                    total: result.data?.length || 0,
                    hasMore: false
                }
            },
            message: 'Transaction history retrieved successfully',
            timestamp: new Date().toISOString(),
            version: '1.0'
        });
    }
    catch (error) {
        logger_1.logger.error('Get transaction history error:', error);
        next(error);
    }
});
/**
 * Get payment order details
 * GET /api/v1/payments/orders/:orderId
 */
router.get('/orders/:orderId', auth_middleware_1.authMiddleware, [
    (0, express_validator_1.param)('orderId')
        .isString()
        .notEmpty()
        .withMessage('Order ID is required')
], handleValidationErrors, async (req, res, next) => {
    try {
        const { orderId } = req.params;
        const paymentOrder = await payment_service_1.paymentService.getPaymentOrder(orderId);
        if (!paymentOrder) {
            return res.status(404).json({
                success: false,
                message: 'Payment order not found',
                timestamp: new Date().toISOString(),
                version: '1.0'
            });
        }
        // Verify user ownership
        if (paymentOrder.userId !== req.user.id) {
            return res.status(403).json({
                success: false,
                message: 'Access denied',
                timestamp: new Date().toISOString(),
                version: '1.0'
            });
        }
        return res.json({
            success: true,
            data: paymentOrder,
            message: 'Payment order details retrieved successfully',
            timestamp: new Date().toISOString(),
            version: '1.0'
        });
    }
    catch (error) {
        logger_1.logger.error('Get payment order error:', error);
        next(error);
    }
});
/**
 * Webhook endpoint for Razorpay
 * POST /api/v1/payments/webhook
 */
router.post('/webhook', 
// No auth middleware for webhooks
async (req, res, next) => {
    try {
        const payload = req.body;
        const signature = req.get('X-Razorpay-Signature');
        if (!signature) {
            return res.status(400).json({
                success: false,
                message: 'Missing webhook signature',
                timestamp: new Date().toISOString(),
                version: '1.0'
            });
        }
        await payment_service_1.paymentService.handleWebhook(payload, signature);
        return res.json({
            success: true,
            message: 'Webhook processed successfully',
            timestamp: new Date().toISOString(),
            version: '1.0'
        });
    }
    catch (error) {
        logger_1.logger.error('Payment webhook error:', error);
        // Still return success to prevent Razorpay retries
        return res.status(200).json({
            success: false,
            message: 'Webhook processing failed',
            timestamp: new Date().toISOString(),
            version: '1.0'
        });
    }
});
/**
 * Get subscription details
 * GET /api/v1/payments/subscriptions/:subscriptionId
 */
router.get('/subscriptions/:subscriptionId', auth_middleware_1.authMiddleware, [
    (0, express_validator_1.param)('subscriptionId')
        .isString()
        .notEmpty()
        .withMessage('Subscription ID is required')
], handleValidationErrors, async (req, res, next) => {
    try {
        const { subscriptionId } = req.params;
        const subscription = await payment_service_1.paymentService.getSubscriptionById(subscriptionId);
        if (!subscription) {
            return res.status(404).json({
                success: false,
                message: 'Subscription not found',
                timestamp: new Date().toISOString(),
                version: '1.0'
            });
        }
        // Verify user ownership
        if (subscription.userId !== req.user.id) {
            return res.status(403).json({
                success: false,
                message: 'Access denied',
                timestamp: new Date().toISOString(),
                version: '1.0'
            });
        }
        res.json({
            success: true,
            data: subscription,
            message: 'Subscription details retrieved successfully',
            timestamp: new Date().toISOString(),
            version: '1.0'
        });
    }
    catch (error) {
        logger_1.logger.error('Get subscription error:', error);
        next(error);
    }
});
/**
 * Cancel subscription
 * POST /api/v1/payments/subscriptions/:subscriptionId/cancel
 */
router.post('/subscriptions/:subscriptionId/cancel', auth_middleware_1.authMiddleware, [
    (0, express_validator_1.param)('subscriptionId')
        .isString()
        .notEmpty()
        .withMessage('Subscription ID is required'),
    (0, express_validator_1.body)('cancelAtCycleEnd')
        .optional()
        .isBoolean()
        .withMessage('Cancel at cycle end must be a boolean')
], handleValidationErrors, async (req, res, next) => {
    try {
        const { subscriptionId } = req.params;
        const { cancelAtCycleEnd = true } = req.body;
        const cancelledSubscription = await payment_service_1.paymentService.cancelSubscription({
            userId: req.user.id,
            subscriptionId,
            cancelAtCycleEnd
        });
        res.json({
            success: true,
            data: cancelledSubscription,
            message: 'Subscription cancelled successfully',
            timestamp: new Date().toISOString(),
            version: '1.0'
        });
    }
    catch (error) {
        logger_1.logger.error('Cancel subscription error:', error);
        next(error);
    }
});
/**
 * Get payment analytics
 * GET /api/v1/payments/analytics
 */
router.get('/analytics', auth_middleware_1.authMiddleware, [
    (0, express_validator_1.query)('period')
        .optional()
        .isIn(['7d', '30d', '90d', '1y'])
        .withMessage('Period must be one of: 7d, 30d, 90d, 1y'),
    (0, express_validator_1.query)('type')
        .optional()
        .isIn(['revenue', 'transactions', 'subscriptions'])
        .withMessage('Type must be one of: revenue, transactions, subscriptions')
], handleValidationErrors, async (req, res, next) => {
    try {
        const { period = '30d', type = 'revenue' } = req.query;
        const analytics = await payment_service_1.paymentService.getPaymentAnalytics({
            userId: req.user.id,
            period: period,
            type: type
        });
        res.json({
            success: true,
            data: analytics,
            message: 'Payment analytics retrieved successfully',
            timestamp: new Date().toISOString(),
            version: '1.0'
        });
    }
    catch (error) {
        logger_1.logger.error('Get payment analytics error:', error);
        next(error);
    }
});
exports.default = router;
