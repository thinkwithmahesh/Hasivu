"use strict";
/**
 * HASIVU Platform - Performance Monitoring Routes
 * API endpoints for performance metrics and monitoring
 * Generated by SuperClaude - Performance Optimization Suite
 */
Object.defineProperty(exports, "__esModule", { value: true });
const express_1 = require("express");
const express_validator_1 = require("express-validator");
const performance_service_1 = require("@/services/performance.service");
const auth_middleware_1 = require("@/middleware/auth.middleware");
const logging_middleware_1 = require("@/middleware/logging.middleware");
const rateLimiter_middleware_1 = require("@/middleware/rateLimiter.middleware");
const logger_1 = require("@/utils/logger");
const router = (0, express_1.Router)();
/**
 * Validation error handler middleware
 */
const handleValidationErrors = (req, res, next) => {
    const errors = (0, express_validator_1.validationResult)(req);
    if (!errors.isEmpty()) {
        res.status(400).json({
            success: false,
            message: 'Validation failed',
            errors: errors.array(),
            timestamp: new Date().toISOString(),
            version: '1.0'
        });
        return;
    }
    next();
};
// Apply middleware to all routes
router.use(logging_middleware_1.requestLogger);
router.use(rateLimiter_middleware_1.generalRateLimit);
/**
 * GET /api/v1/performance/metrics
 * Get current performance metrics
 */
router.get('/metrics', auth_middleware_1.authMiddleware, async (req, res, next) => {
    try {
        const metrics = await performance_service_1.performanceService.getCurrentMetrics();
        res.json({
            success: true,
            data: metrics,
            message: 'Performance metrics retrieved successfully'
        });
    }
    catch (error) {
        logger_1.logger.error('Failed to get performance metrics:', error);
        next(error);
    }
});
/**
 * GET /api/v1/performance/dashboard
 * Get performance dashboard data
 */
router.get('/dashboard', auth_middleware_1.authMiddleware, [
    (0, express_validator_1.query)('timeRange')
        .optional()
        .isIn(['1h', '24h', '7d', '30d'])
        .withMessage('Time range must be 1h, 24h, 7d, or 30d'),
    (0, express_validator_1.query)('metric')
        .optional()
        .isIn(['response_time', 'throughput', 'error_rate', 'cpu_usage', 'memory_usage'])
        .withMessage('Invalid metric type')
], handleValidationErrors, async (req, res, next) => {
    try {
        const dashboard = await performance_service_1.performanceService.getDashboardData({
            schoolId: req.user.id,
            timeRange: req.query.timeRange || '24h',
            metric: req.query.metric
        });
        res.json({
            success: true,
            data: dashboard,
            message: 'Performance dashboard data retrieved successfully'
        });
    }
    catch (error) {
        logger_1.logger.error('Failed to get dashboard data:', error);
        next(error);
    }
});
/**
 * GET /api/v1/performance/history
 * Get historical performance data
 */
router.get('/history', auth_middleware_1.authMiddleware, [
    (0, express_validator_1.query)('startDate')
        .optional()
        .isISO8601()
        .toDate()
        .withMessage('Start date must be a valid ISO 8601 date'),
    (0, express_validator_1.query)('endDate')
        .optional()
        .isISO8601()
        .toDate()
        .withMessage('End date must be a valid ISO 8601 date'),
    (0, express_validator_1.query)('granularity')
        .optional()
        .isIn(['minute', 'hour', 'day'])
        .withMessage('Granularity must be minute, hour, or day'),
    (0, express_validator_1.query)('metrics')
        .optional()
        .withMessage('Metrics must be a comma-separated list')
], handleValidationErrors, async (req, res, next) => {
    try {
        const history = await performance_service_1.performanceService.getHistoricalData({
            startDate: new Date(req.query.startDate),
            endDate: new Date(req.query.endDate),
            metrics: req.query.metrics ? req.query.metrics.split(',') : undefined
            // Note: granularity parameter removed as it's not supported by service method
        });
        res.json({
            success: true,
            data: history,
            message: 'Performance history retrieved successfully'
        });
    }
    catch (error) {
        logger_1.logger.error('Failed to get performance history:', error);
        next(error);
    }
});
/**
 * GET /api/v1/performance/alerts
 * Get performance alerts and thresholds
 */
router.get('/alerts', auth_middleware_1.authMiddleware, [
    (0, express_validator_1.query)('status')
        .optional()
        .isIn(['active', 'resolved', 'muted'])
        .withMessage('Status must be active, resolved, or muted'),
    (0, express_validator_1.query)('severity')
        .optional()
        .isIn(['low', 'medium', 'high', 'critical'])
        .withMessage('Severity must be low, medium, high, or critical')
], handleValidationErrors, async (req, res, next) => {
    try {
        const alerts = await performance_service_1.performanceService.getAlerts({
            schoolId: req.user.id,
            status: req.query.status,
            severity: req.query.severity
        });
        res.json({
            success: true,
            data: alerts,
            message: 'Performance alerts retrieved successfully'
        });
    }
    catch (error) {
        logger_1.logger.error('Failed to get performance alerts:', error);
        next(error);
    }
});
/**
 * GET /api/v1/performance/bottlenecks
 * Identify current performance bottlenecks
 */
router.get('/bottlenecks', auth_middleware_1.authMiddleware, [
    (0, express_validator_1.query)('threshold')
        .optional()
        .isFloat({ min: 0, max: 100 })
        .toFloat()
        .withMessage('Threshold must be a number between 0 and 100'),
    (0, express_validator_1.query)('component')
        .optional()
        .isIn(['database', 'api', 'cache', 'external'])
        .withMessage('Component must be database, api, cache, or external')
], handleValidationErrors, async (req, res, next) => {
    try {
        const bottlenecks = await performance_service_1.performanceService.identifyBottlenecks({
            threshold: Number(req.query.threshold) || 80,
            timeWindow: req.query.timeWindow || '1h'
            // Note: component parameter removed, using timeWindow instead per service interface
        });
        res.json({
            success: true,
            data: bottlenecks,
            message: 'Performance bottlenecks identified successfully'
        });
    }
    catch (error) {
        logger_1.logger.error('Failed to identify bottlenecks:', error);
        next(error);
    }
});
/**
 * POST /api/v1/performance/record
 * Record a custom performance metric
 */
router.post('/record', auth_middleware_1.authMiddleware, [
    (0, express_validator_1.query)('metric')
        .notEmpty()
        .withMessage('Metric name is required'),
    (0, express_validator_1.query)('value')
        .isNumeric()
        .toFloat()
        .withMessage('Value must be a number'),
    (0, express_validator_1.query)('tags')
        .optional()
        .withMessage('Tags should be key-value pairs')
], handleValidationErrors, async (req, res, next) => {
    try {
        await performance_service_1.performanceService.recordMetric({
            name: req.query.metric,
            value: Number(req.query.value),
            tags: {}
        });
        res.status(201).json({
            success: true,
            message: 'Metric recorded successfully'
        });
    }
    catch (error) {
        logger_1.logger.error('Failed to record metric:', error);
        next(error);
    }
});
/**
 * GET /api/v1/performance/optimization-suggestions
 * Get AI-powered optimization suggestions
 */
router.get('/optimization-suggestions', auth_middleware_1.authMiddleware, [
    (0, express_validator_1.query)('category')
        .optional()
        .isIn(['database', 'api', 'frontend', 'infrastructure'])
        .withMessage('Category must be database, api, frontend, or infrastructure'),
    (0, express_validator_1.query)('priority')
        .optional()
        .isIn(['low', 'medium', 'high'])
        .withMessage('Priority must be low, medium, or high')
], handleValidationErrors, async (req, res, next) => {
    try {
        const suggestions = await performance_service_1.performanceService.getOptimizationSuggestions({
            schoolId: req.user.id,
            category: req.query.category,
            priority: req.query.priority
        });
        res.json({
            success: true,
            data: suggestions,
            message: 'Optimization suggestions retrieved successfully'
        });
    }
    catch (error) {
        logger_1.logger.error('Failed to get optimization suggestions:', error);
        next(error);
    }
});
/**
 * GET /api/v1/performance/health
 * Get overall system health status
 */
router.get('/health', auth_middleware_1.authMiddleware, async (req, res, next) => {
    try {
        const health = await performance_service_1.performanceService.getSystemHealth(req.user.id);
        res.json({
            success: true,
            data: health,
            message: 'System health retrieved successfully'
        });
    }
    catch (error) {
        logger_1.logger.error('Failed to get system health:', error);
        next(error);
    }
});
exports.default = router;
