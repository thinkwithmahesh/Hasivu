"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.menuItemService = exports.MenuItemService = exports.MenuCategory = void 0;
/**
 * HASIVU Platform - Menu Item Service
 * Business logic layer for product catalog management
 * Implements Story 2.1: Product Catalog Foundation
 * Generated by SuperClaude Wave 2: Backend Implementation - FIXED
 */
const client_1 = require("@prisma/client");
// Local enum to match schema comments
var MenuCategory;
(function (MenuCategory) {
    MenuCategory["BREAKFAST"] = "BREAKFAST";
    MenuCategory["LUNCH"] = "LUNCH";
    MenuCategory["SNACKS"] = "SNACKS";
    MenuCategory["DINNER"] = "DINNER";
})(MenuCategory || (exports.MenuCategory = MenuCategory = {}));
const menuItem_repository_1 = require("../repositories/menuItem.repository");
const logger_1 = require("../utils/logger");
const cache_1 = require("../utils/cache");
const uuid_1 = require("uuid");
/**
 * Menu Item Service class
 */
class MenuItemService {
    static CACHE_TTL = 300; // 5 minutes
    static MAX_BATCH_SIZE = 100;
    /**
     * Create new menu item
     */
    static async createMenuItem(input) {
        try {
            logger_1.logger.info('Creating menu item', { name: input.name, category: input.category });
            // Validate business rules
            await this.validateCreateInput(input);
            // Check for duplicate names within school context
            if (input.schoolId) {
                const existingItem = await menuItem_repository_1.MenuItemRepository.findByNameAndSchool(input.name.trim(), input.schoolId);
                if (existingItem) {
                    throw new Error(`Menu item with name "${input.name}" already exists for this school`);
                }
            }
            // Prepare data for creation
            const createData = {
                id: (0, uuid_1.v4)(),
                name: input.name.trim(),
                description: input.description?.trim(),
                category: input.category,
                price: new client_1.Prisma.Decimal(input.price),
                originalPrice: input.originalPrice ? new client_1.Prisma.Decimal(input.originalPrice) : undefined,
                currency: input.currency,
                available: input.available ?? true,
                featured: input.featured ?? false,
                imageUrl: input.imageUrl,
                nutritionalInfo: input.nutritionalInfo ? JSON.stringify(input.nutritionalInfo) : null,
                allergens: input.allergens ? JSON.stringify(input.allergens) : null,
                tags: input.tags ? JSON.stringify(input.tags) : null,
                preparationTime: input.preparationTime,
                portionSize: input.portionSize,
                calories: input.calories,
                sortOrder: input.sortOrder ?? 0,
                metadata: JSON.stringify(input.metadata || {}),
                ...(input.schoolId && {
                    school: { connect: { id: input.schoolId } }
                })
            };
            const menuItem = await menuItem_repository_1.MenuItemRepository.create(createData);
            // Clear relevant caches
            await this.clearRelatedCaches(menuItem.schoolId, menuItem.category);
            logger_1.logger.info('Menu item created successfully', { menuItemId: menuItem.id });
            return this.transformMenuItem(menuItem);
        }
        catch (error) {
            logger_1.logger.error('Failed to create menu item', error, { input });
            throw error;
        }
    }
    /**
     * Get menu item by ID
     */
    static async getMenuItemById(id, includeSchool = true) {
        try {
            const cacheKey = `menu_item:${id}:${includeSchool}`;
            const cached = await cache_1.cache.get(cacheKey);
            if (cached) {
                return JSON.parse(cached);
            }
            const menuItem = await menuItem_repository_1.MenuItemRepository.findById(id, includeSchool);
            if (!menuItem) {
                logger_1.logger.warn('Menu item not found', { menuItemId: id });
                return null;
            }
            const transformedItem = this.transformMenuItem(menuItem);
            await cache_1.cache.setex(cacheKey, this.CACHE_TTL, JSON.stringify(transformedItem));
            return transformedItem;
        }
        catch (error) {
            logger_1.logger.error('Failed to get menu item by ID', error, { menuItemId: id });
            throw error;
        }
    }
    /**
     * Get menu items with filtering and pagination
     */
    static async getMenuItems(filters = {}, pagination = {}) {
        try {
            const page = pagination.page || 1;
            const limit = Math.min(pagination.limit || 20, 100);
            const skip = (page - 1) * limit;
            const options = {
                filters,
                skip,
                take: limit,
                sortBy: pagination.sortBy || 'sortOrder',
                sortOrder: pagination.sortOrder || 'asc'
            };
            const result = await menuItem_repository_1.MenuItemRepository.findMany(options);
            const totalPages = Math.ceil(result.total / limit);
            // Transform all items
            const transformedItems = result.items.map(item => this.transformMenuItem(item));
            logger_1.logger.info('Retrieved menu items', {
                count: transformedItems.length,
                total: result.total,
                page,
                filters
            });
            return {
                items: transformedItems,
                total: result.total,
                page,
                limit,
                totalPages
            };
        }
        catch (error) {
            logger_1.logger.error('Failed to get menu items', error, { filters, pagination });
            throw error;
        }
    }
    /**
     * Get menu items by category
     */
    static async getMenuItemsByCategory(category, options = {}) {
        try {
            const filters = {
                category,
                ...(options.schoolId && { schoolId: options.schoolId }),
                ...(options.available !== undefined && { available: options.available })
            };
            const pagination = {
                limit: options.limit || 50,
                sortBy: 'sortOrder',
                sortOrder: 'asc'
            };
            const result = await this.getMenuItems(filters, pagination);
            const items = result.items; // Already transformed by getMenuItems
            logger_1.logger.info('Retrieved menu items by category', {
                category,
                count: items.length,
                options
            });
            return items;
        }
        catch (error) {
            logger_1.logger.error('Failed to get menu items by category', error, { category, options });
            throw error;
        }
    }
    /**
     * Get featured menu items
     */
    static async getFeaturedItems(options = {}) {
        try {
            const filters = {
                featured: true,
                available: true,
                ...(options.schoolId && { schoolId: options.schoolId }),
                ...(options.category && { category: options.category })
            };
            const pagination = {
                limit: options.limit || 10,
                sortBy: 'sortOrder',
                sortOrder: 'asc'
            };
            const result = await this.getMenuItems(filters, pagination);
            const items = result.items; // Already transformed by getMenuItems
            logger_1.logger.info('Retrieved featured menu items', {
                count: items.length,
                options
            });
            return items;
        }
        catch (error) {
            logger_1.logger.error('Failed to get featured menu items', error, { options });
            throw error;
        }
    }
    /**
     * Search menu items
     */
    static async searchMenuItems(searchTerm, filters = {}, pagination = {}) {
        try {
            if (!searchTerm.trim()) {
                const result = await this.getMenuItems(filters, pagination);
                return { items: result.items, total: result.total };
            }
            const result = await menuItem_repository_1.MenuItemRepository.search(searchTerm.trim(), filters, pagination);
            // Transform items
            const transformedItems = result.items.map(item => this.transformMenuItem(item));
            return { items: transformedItems, total: result.total };
            logger_1.logger.info('Searched menu items', {
                searchTerm,
                count: transformedItems.length,
                total: result.total,
                filters
            });
        }
        catch (error) {
            logger_1.logger.error('Failed to search menu items', error, { searchTerm, filters });
            throw error;
        }
    }
    /**
     * Update menu item
     */
    static async updateMenuItem(id, input) {
        try {
            logger_1.logger.info('Updating menu item', { menuItemId: id });
            // Check if menu item exists
            const existing = await menuItem_repository_1.MenuItemRepository.findById(id);
            if (!existing) {
                throw new Error(`Menu item with ID ${id} not found`);
            }
            // Validate business rules if updating critical fields
            if (input.price !== undefined || input.category !== undefined) {
                await this.validateUpdateInput(input);
            }
            // Check for duplicate names if name is being changed
            if (input.name && input.name !== existing.name) {
                if (existing.schoolId) {
                    const duplicateItem = await menuItem_repository_1.MenuItemRepository.findByNameAndSchool(input.name.trim(), existing.schoolId);
                    if (duplicateItem && duplicateItem.id !== id) {
                        throw new Error(`Menu item with name "${input.name}" already exists for this school`);
                    }
                }
            }
            // Prepare update data
            const updateData = {};
            if (input.name !== undefined)
                updateData.name = input.name.trim();
            if (input.description !== undefined)
                updateData.description = input.description?.trim();
            if (input.category !== undefined)
                updateData.category = input.category;
            if (input.price !== undefined)
                updateData.price = new client_1.Prisma.Decimal(input.price);
            if (input.originalPrice !== undefined) {
                updateData.originalPrice = input.originalPrice ? new client_1.Prisma.Decimal(input.originalPrice) : null;
            }
            if (input.currency !== undefined)
                updateData.currency = input.currency;
            if (input.available !== undefined)
                updateData.available = input.available;
            if (input.featured !== undefined)
                updateData.featured = input.featured;
            if (input.imageUrl !== undefined)
                updateData.imageUrl = input.imageUrl;
            if (input.nutritionalInfo !== undefined) {
                updateData.nutritionalInfo = input.nutritionalInfo ? JSON.stringify(input.nutritionalInfo) : null;
            }
            if (input.allergens !== undefined)
                updateData.allergens = JSON.stringify(input.allergens);
            if (input.tags !== undefined)
                updateData.tags = JSON.stringify(input.tags);
            if (input.preparationTime !== undefined)
                updateData.preparationTime = input.preparationTime;
            if (input.portionSize !== undefined)
                updateData.portionSize = input.portionSize;
            if (input.calories !== undefined)
                updateData.calories = input.calories;
            if (input.sortOrder !== undefined)
                updateData.sortOrder = input.sortOrder;
            if (input.metadata !== undefined)
                updateData.metadata = JSON.stringify(input.metadata);
            const menuItem = await menuItem_repository_1.MenuItemRepository.update(id, updateData);
            // Clear relevant caches
            await this.clearRelatedCaches(menuItem.schoolId, menuItem.category);
            await cache_1.cache.del(`menu_item:${id}:true`);
            await cache_1.cache.del(`menu_item:${id}:false`);
            logger_1.logger.info('Menu item updated successfully', { menuItemId: menuItem.id });
            return this.transformMenuItem(menuItem);
        }
        catch (error) {
            logger_1.logger.error('Failed to update menu item', error, { menuItemId: id, input });
            throw error;
        }
    }
    /**
     * Delete menu item (soft delete - mark as unavailable)
     */
    static async deleteMenuItem(id, hard = false) {
        try {
            logger_1.logger.info('Deleting menu item', { menuItemId: id, hard });
            const existing = await menuItem_repository_1.MenuItemRepository.findById(id);
            if (!existing) {
                throw new Error(`Menu item with ID ${id} not found`);
            }
            let menuItem;
            if (hard) {
                menuItem = await menuItem_repository_1.MenuItemRepository.delete(id);
            }
            else {
                // Soft delete - mark as unavailable
                menuItem = await menuItem_repository_1.MenuItemRepository.update(id, { available: false });
            }
            // Clear relevant caches
            await this.clearRelatedCaches(menuItem.schoolId, menuItem.category);
            await cache_1.cache.del(`menu_item:${id}:true`);
            await cache_1.cache.del(`menu_item:${id}:false`);
            logger_1.logger.info('Menu item deleted successfully', {
                menuItemId: menuItem.id,
                hard
            });
            return this.transformMenuItem(menuItem);
        }
        catch (error) {
            logger_1.logger.error('Failed to delete menu item', error, { menuItemId: id });
            throw error;
        }
    }
    /**
     * Update sort orders for multiple menu items
     */
    static async updateSortOrders(updates) {
        try {
            if (updates.length === 0) {
                return;
            }
            if (updates.length > this.MAX_BATCH_SIZE) {
                throw new Error(`Cannot update more than ${this.MAX_BATCH_SIZE} items at once`);
            }
            logger_1.logger.info('Updating menu item sort orders', { count: updates.length });
            // Validate all IDs exist
            const ids = updates.map(u => u.id);
            const existingItems = await Promise.all(ids.map(id => menuItem_repository_1.MenuItemRepository.findById(id)));
            const missingItems = existingItems
                .map((item, index) => item ? null : ids[index])
                .filter(Boolean);
            if (missingItems.length > 0) {
                throw new Error(`Menu items not found: ${missingItems.join(', ')}`);
            }
            // Execute batch update
            await menuItem_repository_1.MenuItemRepository.batchUpdateSortOrders(updates);
            // Clear caches for affected schools and categories
            const schoolCategories = new Set();
            existingItems.forEach(item => {
                if (item?.schoolId && item?.category) {
                    schoolCategories.add(`${item.schoolId}:${item.category}`);
                }
            });
            await Promise.all(Array.from(schoolCategories).map(key => {
                const [schoolId, category] = key.split(':');
                return this.clearRelatedCaches(schoolId, category);
            }));
            logger_1.logger.info('Menu item sort orders updated successfully', {
                count: updates.length
            });
        }
        catch (error) {
            logger_1.logger.error('Failed to update sort orders', error, { updates });
            throw error;
        }
    }
    /**
     * Toggle featured status for menu item
     */
    static async toggleFeatured(id) {
        try {
            const existing = await this.getMenuItemById(id);
            if (!existing) {
                throw new Error(`Menu item with ID ${id} not found`);
            }
            return await this.updateMenuItem(id, { featured: !existing.featured });
        }
        catch (error) {
            logger_1.logger.error('Failed to toggle featured status', error, { menuItemId: id });
            throw error;
        }
    }
    /**
     * Toggle availability for menu item
     */
    static async toggleAvailability(id) {
        try {
            const existing = await this.getMenuItemById(id);
            if (!existing) {
                throw new Error(`Menu item with ID ${id} not found`);
            }
            return await this.updateMenuItem(id, { available: !existing.available });
        }
        catch (error) {
            logger_1.logger.error('Failed to toggle availability', error, { menuItemId: id });
            throw error;
        }
    }
    /**
     * Get menu items by allergen restrictions
     */
    static async getMenuItemsByAllergens(excludeAllergens, options = {}) {
        try {
            const filters = {
                available: true,
                ...(options.schoolId && { schoolId: options.schoolId }),
                ...(options.category && { category: options.category })
            };
            const result = await this.getMenuItems(filters);
            // Filter out items that contain excluded allergens
            const filteredItems = result.items.filter(item => {
                if (!item.allergens)
                    return true;
                try {
                    const itemAllergens = Array.isArray(item.allergens)
                        ? item.allergens
                        : JSON.parse(item.allergens);
                    return !excludeAllergens.some(allergen => itemAllergens.includes(allergen));
                }
                catch {
                    return true; // If allergens parsing fails, include the item
                }
            });
            logger_1.logger.info('Retrieved menu items by allergen restrictions', {
                excludeAllergens,
                totalItems: result.items.length,
                filteredItems: filteredItems.length,
                options
            });
            return filteredItems;
        }
        catch (error) {
            logger_1.logger.error('Failed to get menu items by allergens', error, {
                excludeAllergens,
                options
            });
            throw error;
        }
    }
    /**
     * Get nutritional summary for multiple menu items
     */
    static async getNutritionalSummary(itemIds) {
        try {
            const items = await Promise.all(itemIds.map(id => this.getMenuItemById(id)));
            const validItems = items.filter(Boolean);
            let totalCalories = 0;
            const allAllergens = new Set();
            const nutritionalInfo = {};
            validItems.forEach(item => {
                if (item.calories) {
                    totalCalories += item.calories;
                }
                if (item.allergens) {
                    try {
                        const itemAllergens = Array.isArray(item.allergens)
                            ? item.allergens
                            : JSON.parse(item.allergens);
                        itemAllergens.forEach(allergen => allAllergens.add(allergen));
                    }
                    catch {
                        // Skip invalid allergen data
                    }
                }
                if (item.nutritionalInfo) {
                    try {
                        const itemNutrition = typeof item.nutritionalInfo === 'string'
                            ? JSON.parse(item.nutritionalInfo)
                            : item.nutritionalInfo;
                        Object.keys(itemNutrition).forEach(key => {
                            if (typeof itemNutrition[key] === 'number') {
                                nutritionalInfo[key] = (nutritionalInfo[key] || 0) + itemNutrition[key];
                            }
                        });
                    }
                    catch {
                        // Skip invalid nutritional data
                    }
                }
            });
            return {
                totalCalories,
                allergens: Array.from(allAllergens),
                nutritionalInfo
            };
        }
        catch (error) {
            logger_1.logger.error('Failed to get nutritional summary', error, { itemIds });
            throw error;
        }
    }
    /**
     * Validate create input
     */
    static async validateCreateInput(input) {
        if (!input.name?.trim()) {
            throw new Error('Menu item name is required');
        }
        if (input.name.length > 200) {
            throw new Error('Menu item name cannot exceed 200 characters');
        }
        if (input.description && input.description.length > 1000) {
            throw new Error('Menu item description cannot exceed 1000 characters');
        }
        if (input.price <= 0) {
            throw new Error('Menu item price must be greater than 0');
        }
        if (input.originalPrice && input.originalPrice <= 0) {
            throw new Error('Original price must be greater than 0');
        }
        if (input.originalPrice && input.originalPrice <= input.price) {
            throw new Error('Original price must be greater than current price');
        }
        if (input.preparationTime && input.preparationTime < 0) {
            throw new Error('Preparation time cannot be negative');
        }
        if (input.calories && input.calories < 0) {
            throw new Error('Calories cannot be negative');
        }
    }
    /**
     * Validate update input
     */
    static async validateUpdateInput(input) {
        if (input.name !== undefined && !input.name?.trim()) {
            throw new Error('Menu item name cannot be empty');
        }
        if (input.name && input.name.length > 200) {
            throw new Error('Menu item name cannot exceed 200 characters');
        }
        if (input.description && input.description.length > 1000) {
            throw new Error('Menu item description cannot exceed 1000 characters');
        }
        if (input.price !== undefined && input.price <= 0) {
            throw new Error('Menu item price must be greater than 0');
        }
        if (input.originalPrice !== undefined && input.originalPrice !== null && input.originalPrice <= 0) {
            throw new Error('Original price must be greater than 0');
        }
        if (input.preparationTime !== undefined && input.preparationTime < 0) {
            throw new Error('Preparation time cannot be negative');
        }
        if (input.calories !== undefined && input.calories < 0) {
            throw new Error('Calories cannot be negative');
        }
    }
    /**
     * Transform raw MenuItem from database to include parsed JSON fields and computed properties
     */
    static transformMenuItem(rawItem) {
        if (!rawItem)
            return null;
        try {
            // Parse JSON fields
            let nutritionalInfo = null;
            let allergens = [];
            let tags = [];
            let metadata = {};
            if (rawItem.nutritionalInfo) {
                try {
                    nutritionalInfo = typeof rawItem.nutritionalInfo === 'string'
                        ? JSON.parse(rawItem.nutritionalInfo)
                        : rawItem.nutritionalInfo;
                }
                catch (e) {
                    logger_1.logger.warn('Failed to parse nutritional info JSON', { itemId: rawItem.id });
                }
            }
            if (rawItem.allergens) {
                try {
                    allergens = typeof rawItem.allergens === 'string'
                        ? JSON.parse(rawItem.allergens)
                        : rawItem.allergens;
                }
                catch (e) {
                    logger_1.logger.warn('Failed to parse allergens JSON', { itemId: rawItem.id });
                }
            }
            if (rawItem.tags) {
                try {
                    tags = typeof rawItem.tags === 'string'
                        ? JSON.parse(rawItem.tags)
                        : rawItem.tags;
                }
                catch (e) {
                    logger_1.logger.warn('Failed to parse tags JSON', { itemId: rawItem.id });
                }
            }
            if (rawItem.metadata) {
                try {
                    metadata = typeof rawItem.metadata === 'string'
                        ? JSON.parse(rawItem.metadata)
                        : rawItem.metadata;
                }
                catch (e) {
                    logger_1.logger.warn('Failed to parse metadata JSON', { itemId: rawItem.id });
                }
            }
            // Extract ingredients from nutritional info or metadata
            let ingredients = [];
            if (nutritionalInfo && typeof nutritionalInfo === 'object' && nutritionalInfo.ingredients) {
                ingredients = Array.isArray(nutritionalInfo.ingredients) ? nutritionalInfo.ingredients : [];
            }
            else if (metadata && typeof metadata === 'object' && metadata.ingredients) {
                ingredients = Array.isArray(metadata.ingredients) ? metadata.ingredients : [];
            }
            return {
                ...rawItem,
                nutritionalInfo,
                allergens,
                tags,
                metadata,
                ingredients,
                isActive: rawItem.available === true, // Computed property for tests
            };
        }
        catch (error) {
            logger_1.logger.warn('Failed to transform menu item', { error: error.message, itemId: rawItem?.id });
            return rawItem;
        }
    }
    /**
     * Bulk create menu items
     */
    static async bulkCreateMenuItems(items) {
        try {
            if (items.length === 0)
                return [];
            if (items.length > this.MAX_BATCH_SIZE) {
                throw new Error(`Cannot create more than ${this.MAX_BATCH_SIZE} items at once`);
            }
            logger_1.logger.info('Bulk creating menu items', { count: items.length });
            // Validate all inputs
            await Promise.all(items.map(item => this.validateCreateInput(item)));
            // Create all items
            const results = await Promise.all(items.map(item => this.createMenuItem(item)));
            logger_1.logger.info('Bulk menu items created successfully', { count: results.length });
            return results;
        }
        catch (error) {
            logger_1.logger.error('Failed to bulk create menu items', error, { count: items.length });
            throw error;
        }
    }
    /**
     * Bulk update menu availability
     */
    static async bulkUpdateAvailability(updates) {
        try {
            if (updates.length === 0)
                return [];
            if (updates.length > this.MAX_BATCH_SIZE) {
                throw new Error(`Cannot update more than ${this.MAX_BATCH_SIZE} items at once`);
            }
            logger_1.logger.info('Bulk updating menu item availability', { count: updates.length });
            // Update all items
            const results = await Promise.all(updates.map(update => this.updateMenuItem(update.id, { available: update.available })));
            logger_1.logger.info('Bulk availability updates completed', { count: results.length });
            return results;
        }
        catch (error) {
            logger_1.logger.error('Failed to bulk update availability', error, { count: updates.length });
            throw error;
        }
    }
    /**
     * Clear related caches
     */
    static async clearRelatedCaches(schoolId, category) {
        try {
            const cacheKeys = [
                'menu_items:*',
                'featured_items:*',
                ...(schoolId ? [`school:${schoolId}:menu_items:*`] : []),
                ...(category ? [`category:${category}:*`] : [])
            ];
            // Note: InMemoryCache.deletePattern method not available, clear entire cache
            cache_1.cache.clear();
        }
        catch (error) {
            logger_1.logger.warn('Failed to clear caches', error);
        }
    }
    /**
     * Clear all menu item caches (instance method for tests)
     */
    async clearCache() {
        try {
            cache_1.cache.clear();
            logger_1.logger.info('Menu item caches cleared');
        }
        catch (error) {
            logger_1.logger.warn('Failed to clear menu item caches', error);
        }
    }
    /**
     * Disconnect from external resources (instance method for tests)
     */
    async disconnect() {
        try {
            // No specific resources to disconnect from in this service
            logger_1.logger.info('Menu item service disconnected');
        }
        catch (error) {
            logger_1.logger.warn('Failed to disconnect menu item service', error);
        }
    }
    // Instance methods delegating to static methods for testing compatibility
    /**
     * Create new menu item (instance method)
     */
    async createMenuItem(input) {
        return MenuItemService.createMenuItem(input);
    }
    /**
     * Get menu item by ID (instance method)
     */
    async getMenuItemById(id, includeSchool = true) {
        return MenuItemService.getMenuItemById(id, includeSchool);
    }
    /**
     * Get menu items with filtering and pagination (instance method)
     */
    async getMenuItems(filters = {}, pagination = {}) {
        return MenuItemService.getMenuItems(filters, pagination);
    }
    /**
     * Update menu item (instance method)
     */
    async updateMenuItem(id, input) {
        return MenuItemService.updateMenuItem(id, input);
    }
    /**
     * Delete menu item (instance method)
     */
    async deleteMenuItem(id, hard = false) {
        return MenuItemService.deleteMenuItem(id, hard);
    }
    /**
     * Get menu items by category (instance method)
     */
    async getMenuItemsByCategory(category, options = {}) {
        return MenuItemService.getMenuItemsByCategory(category, options);
    }
    /**
     * Get featured menu items (instance method)
     */
    async getFeaturedItems(options = {}) {
        return MenuItemService.getFeaturedItems(options);
    }
    /**
     * Search menu items by name and description (instance method)
     */
    async searchMenuItems(searchOptions) {
        const searchTerm = searchOptions.query;
        const filters = {
            ...(searchOptions.schoolId && { schoolId: searchOptions.schoolId }),
            ...(searchOptions.filters || {})
        };
        const pagination = {
            page: searchOptions.pagination?.page || 1,
            limit: searchOptions.pagination?.limit || searchOptions.limit || 50,
            sortBy: 'name',
            sortOrder: 'asc'
        };
        const result = await MenuItemService.searchMenuItems(searchTerm, filters, pagination);
        return result.items;
    }
    /**
     * Bulk create menu items (instance method)
     */
    async bulkCreateMenuItems(items) {
        return MenuItemService.bulkCreateMenuItems(items);
    }
    /**
     * Bulk update menu availability (instance method)
     */
    async bulkUpdateAvailability(updates) {
        return MenuItemService.bulkUpdateAvailability(updates);
    }
    /**
     * Transform raw MenuItem from database (instance method for tests)
     */
    transformMenuItem(rawItem) {
        return MenuItemService.transformMenuItem(rawItem);
    }
    /**
     * Get menu statistics
     */
    static async getMenuStats(schoolId) {
        const stats = await menuItem_repository_1.MenuItemRepository.getStatistics(schoolId);
        return {
            totalItems: stats.totalItems,
            averagePrice: Number(stats.averagePrice) || 0,
            byCategory: stats.itemsByCategory
        };
    }
}
exports.MenuItemService = MenuItemService;
// Export singleton instance
exports.menuItemService = new MenuItemService();
