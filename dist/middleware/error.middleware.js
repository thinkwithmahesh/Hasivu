"use strict";
/**
 * HASIVU Platform - Error Handling Middleware
 * Global error handler with structured error responses and logging
 * Generated by SuperClaude Wave 2: Backend Implementation
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.installGlobalErrorHandlers = exports.unhandledRejectionHandler = exports.uncaughtExceptionHandler = exports.transformDatabaseError = exports.validationErrorHandler = exports.asyncHandler = exports.notFoundHandler = exports.errorHandler = exports.createDatabaseError = exports.createConflictError = exports.createServiceUnavailableError = exports.createRateLimitError = exports.createAuthorizationError = exports.createAuthenticationError = exports.createNotFoundError = exports.createValidationError = exports.createError = exports.ErrorCodes = void 0;
const logger_1 = require("../utils/logger");
const environment_1 = require("../config/environment");
/**
 * Predefined error codes and messages
 */
exports.ErrorCodes = {
    VALIDATION_ERROR: 'VALIDATION_ERROR',
    AUTHENTICATION_ERROR: 'AUTHENTICATION_ERROR',
    AUTHORIZATION_ERROR: 'AUTHORIZATION_ERROR',
    NOT_FOUND: 'NOT_FOUND',
    DUPLICATE_RESOURCE: 'DUPLICATE_RESOURCE',
    RESOURCE_CONFLICT: 'RESOURCE_CONFLICT',
    RATE_LIMIT_EXCEEDED: 'RATE_LIMIT_EXCEEDED',
    SERVICE_UNAVAILABLE: 'SERVICE_UNAVAILABLE',
    DATABASE_ERROR: 'DATABASE_ERROR',
    EXTERNAL_API_ERROR: 'EXTERNAL_API_ERROR',
    CONFIGURATION_ERROR: 'CONFIGURATION_ERROR',
    INTERNAL_ERROR: 'INTERNAL_ERROR'
};
/**
 * Create standardized error
 */
function createError(code, message, statusCode = 500, details) {
    const error = new Error(message);
    error.code = code;
    error.statusCode = statusCode;
    error.details = details;
    error.isOperational = true;
    return error;
}
exports.createError = createError;
/**
 * Create validation error
 */
function createValidationError(message, details) {
    return createError(exports.ErrorCodes.VALIDATION_ERROR, message, 400, details);
}
exports.createValidationError = createValidationError;
/**
 * Create not found error
 */
function createNotFoundError(resource, identifier) {
    const message = identifier
        ? `${resource} with identifier '${identifier}' not found`
        : `${resource} not found`;
    return createError(exports.ErrorCodes.NOT_FOUND, message, 404);
}
exports.createNotFoundError = createNotFoundError;
/**
 * Create authentication error
 */
function createAuthenticationError(message = 'Authentication required') {
    return createError(exports.ErrorCodes.AUTHENTICATION_ERROR, message, 401);
}
exports.createAuthenticationError = createAuthenticationError;
/**
 * Create authorization error
 */
function createAuthorizationError(message = 'Access denied') {
    return createError(exports.ErrorCodes.AUTHORIZATION_ERROR, message, 403);
}
exports.createAuthorizationError = createAuthorizationError;
/**
 * Create rate limit error
 */
function createRateLimitError(message = 'Too many requests') {
    return createError(exports.ErrorCodes.RATE_LIMIT_EXCEEDED, message, 429);
}
exports.createRateLimitError = createRateLimitError;
/**
 * Create service unavailable error
 */
function createServiceUnavailableError(message = 'Service temporarily unavailable') {
    return createError(exports.ErrorCodes.SERVICE_UNAVAILABLE, message, 503);
}
exports.createServiceUnavailableError = createServiceUnavailableError;
/**
 * Create conflict error
 */
function createConflictError(message = 'Resource already exists') {
    return createError(exports.ErrorCodes.RESOURCE_CONFLICT, message, 409);
}
exports.createConflictError = createConflictError;
/**
 * Create database error
 */
function createDatabaseError(message, details) {
    return createError(exports.ErrorCodes.DATABASE_ERROR, message, 500, details);
}
exports.createDatabaseError = createDatabaseError;
/**
 * Main error handling middleware
 */
const errorHandler = (err, req, res, next) => {
    // Set default values for unhandled errors
    const statusCode = err.statusCode || 500;
    const errorCode = err.code || exports.ErrorCodes.INTERNAL_ERROR;
    const message = err.message || 'Internal server error';
    const isProduction = environment_1.config.server.nodeEnv === 'production';
    // Generate request ID
    const requestId = req.headers['x-request-id'] || generateRequestId();
    // Log error details
    logError(err, req, requestId);
    // Build error response
    const errorResponse = {
        success: false,
        error: {
            code: errorCode,
            message: isProduction && statusCode >= 500 ? 'Internal server error' : message,
            timestamp: new Date().toISOString(),
            requestId,
            path: req.path,
            ...(shouldIncludeDetails(statusCode, isProduction) && { details: err.details })
        }
    };
    // Send error response
    res.status(statusCode).json(errorResponse);
};
exports.errorHandler = errorHandler;
/**
 * 404 Not Found handler
 */
const notFoundHandler = (req, res, next) => {
    const error = createNotFoundError('Route', `${req.method} ${req.originalUrl}`);
    next(error);
};
exports.notFoundHandler = notFoundHandler;
/**
 * Async handler wrapper to catch async errors
 */
const asyncHandler = (fn) => {
    return (req, res, next) => {
        Promise.resolve(fn(req, res, next)).catch(next);
    };
};
exports.asyncHandler = asyncHandler;
/**
 * Helper functions
 */
function generateRequestId() {
    return `req_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
}
function shouldIncludeDetails(statusCode, isProduction) {
    // Don't include details in production for server errors
    if (isProduction && statusCode >= 500) {
        return false;
    }
    // Include details for client errors and in development
    return true;
}
function logError(err, req, requestId) {
    const logData = {
        requestId,
        error: {
            name: err.name,
            message: err.message,
            code: err.code,
            statusCode: err.statusCode,
            stack: err.stack,
            details: err.details
        },
        request: {
            method: req.method,
            url: req.originalUrl,
            headers: req.headers,
            body: req.body,
            query: req.query,
            params: req.params,
            ip: req.ip,
            userAgent: req.get('User-Agent')
        },
        timestamp: new Date().toISOString()
    };
    // Log based on error severity
    if (err.statusCode && err.statusCode < 500) {
        // Client errors (4xx) - log as warning
        logger_1.logger.warn('Client error occurred', logData);
    }
    else {
        // Server errors (5xx) - log as error
        logger_1.logger.error('Server error occurred', logData);
    }
}
/**
 * Validation error middleware
 */
const validationErrorHandler = (req, res, next) => {
    // This would typically be used with express-validator
    // For now, it's a placeholder that just calls next
    next();
};
exports.validationErrorHandler = validationErrorHandler;
/**
 * Database error transformer
 */
const transformDatabaseError = (error) => {
    // Transform different database errors to standard format
    if (error.code === 'P2002') {
        // Prisma unique constraint violation
        return createError(exports.ErrorCodes.DUPLICATE_RESOURCE, 'Resource already exists', 409, { field: error.meta?.target });
    }
    if (error.code === 'P2025') {
        // Prisma record not found
        return createNotFoundError('Resource');
    }
    if (error.code === 'P2003') {
        // Prisma foreign key constraint violation
        return createError(exports.ErrorCodes.RESOURCE_CONFLICT, 'Cannot perform operation due to related data', 409);
    }
    // Generic database error
    return createDatabaseError('Database operation failed', {
        originalError: error.message,
        code: error.code
    });
};
exports.transformDatabaseError = transformDatabaseError;
/**
 * Express error handler for uncaught exceptions
 */
const uncaughtExceptionHandler = (error) => {
    logger_1.logger.error('Uncaught Exception', {
        name: error.name,
        message: error.message,
        stack: error.stack,
        timestamp: new Date().toISOString()
    });
    // Graceful shutdown
    process.exit(1);
};
exports.uncaughtExceptionHandler = uncaughtExceptionHandler;
/**
 * Express error handler for unhandled promise rejections
 */
const unhandledRejectionHandler = (reason, promise) => {
    logger_1.logger.error('Unhandled Promise Rejection', {
        reason: reason.toString(),
        stack: reason.stack,
        promise: promise.toString(),
        timestamp: new Date().toISOString()
    });
    // Graceful shutdown
    process.exit(1);
};
exports.unhandledRejectionHandler = unhandledRejectionHandler;
/**
 * Install global error handlers
 */
const installGlobalErrorHandlers = () => {
    process.on('uncaughtException', exports.uncaughtExceptionHandler);
    process.on('unhandledRejection', exports.unhandledRejectionHandler);
    // Graceful shutdown on SIGTERM
    process.on('SIGTERM', () => {
        logger_1.logger.info('SIGTERM received, shutting down gracefully');
        process.exit(0);
    });
    // Graceful shutdown on SIGINT
    process.on('SIGINT', () => {
        logger_1.logger.info('SIGINT received, shutting down gracefully');
        process.exit(0);
    });
};
exports.installGlobalErrorHandlers = installGlobalErrorHandlers;
