/**
 * HASIVU Platform - API Versioning Enhancement Utilities
 * Provides advanced API versioning capabilities including deprecation management,
 * version migration utilities, and backward compatibility support.
 * Generated by SuperClaude Emergency Recovery Phase 13
 */

import { Request, Response, NextFunction } from 'express';
import { AuthenticatedRequest, ApiResponse, ApiError } from '../types/api.types';
import { logger } from '../shared/utils/logger';
import * as semver from 'semver';

// =============================================================================
// TYPES AND INTERFACES
// =============================================================================

/**
 * API version information
 */
export interface ApiVersionInfo {
  version: string;
  status: 'current' | 'supported' | 'deprecated' | 'unsupported';
  releaseDate: string;
  deprecationDate?: string;
  sunsetDate?: string;
  replacementVersion?: string;
  features: string[];
  breakingChanges: string[];
  migrationGuide?: string;
  documentation: string;
}

/**
 * Version detection result
 */
export interface VersionDetectionResult {
  detectedVersion: string;
  requestedVersion?: string;
  isSupported: boolean;
  isDeprecated: boolean;
  deprecationWarning?: string;
  migrationInfo?: MigrationInfo;
}

/**
 * Migration information
 */
export interface MigrationInfo {
  fromVersion: string;
  toVersion: string;
  breakingChanges: string[];
  migrationSteps: string[];
  automatedMigration: boolean;
  migrationGuide: string;
  migrationScript?: string;
  testSuite?: string;
  documentation: string;
}

/**
 * Version compatibility matrix
 */
export interface VersionCompatibility {
  clientVersion: string;
  apiVersion: string;
  compatible: boolean;
  warnings: string[];
  requiredChanges: string[];
}

/**
 * API versioning configuration
 */
export interface ApiVersioningConfig {
  defaultVersion: string;
  latestVersion: string;
  supportedVersions: string[];
  deprecatedVersions: string[];
  unsupportedVersions: string[];
  versionHeader: string;
  pathPrefix: string;
  enableDeprecationWarnings: boolean;
  enableMigrationHints: boolean;
  strictVersioning: boolean;
}

// =============================================================================
// API VERSION MANAGER
// =============================================================================

/**
 * API Version Manager
 * Handles version detection, deprecation notices, and migration utilities
 */
export class ApiVersionManager {
  private static instance: ApiVersionManager;
  private supportedVersions: Map<string, ApiVersionInfo>;
  private logger: any;
  private config: ApiVersioningConfig;

  private constructor() {
    this.logger = logger;
    this.supportedVersions = new Map();
    this.config = {
      defaultVersion: 'v1',
      latestVersion: 'v1.2',
      supportedVersions: ['v1', 'v1.1', 'v1.2'],
      deprecatedVersions: ['v1.0'],
      unsupportedVersions: ['v0.9', 'v0.8'],
      versionHeader: 'api-version',
      pathPrefix: '/api/',
      enableDeprecationWarnings: true,
      enableMigrationHints: true,
      strictVersioning: false,
    };
    this.initializeSupportedVersions();
  }

  /**
   * Get singleton instance
   */
  public static getInstance(): ApiVersionManager {
    if (!ApiVersionManager.instance) {
      ApiVersionManager.instance = new ApiVersionManager();
    }
    return ApiVersionManager.instance;
  }

  /**
   * Get configuration
   */
  public getConfig(): ApiVersioningConfig {
    return { ...this.config };
  }

  /**
   * Initialize supported API versions with their compatibility levels
   */
  private initializeSupportedVersions(): void {
    // Current stable version
    this.supportedVersions.set('v1.2', {
      version: 'v1.2',
      status: 'current',
      releaseDate: '2024-06-01',
      features: [
        'Enhanced menu management',
        'Advanced payment processing',
        'Real-time notifications',
        'RFID integration',
        'Performance optimizations',
      ],
      breakingChanges: [
        'Payment webhook signature validation required',
        'Menu item structure updated with nutrition info',
        'Authentication token format changed',
      ],
      documentation: '/docs/api/v1.2',
    });

    // Previous stable version
    this.supportedVersions.set('v1.1', {
      version: 'v1.1',
      status: 'supported',
      releaseDate: '2024-03-01',
      features: [
        'Basic menu management',
        'Payment processing',
        'Email notifications',
        'User management',
      ],
      breakingChanges: ['Order status enum values changed', 'User role hierarchy updated'],
      documentation: '/docs/api/v1.1',
    });

    // Legacy version
    this.supportedVersions.set('v1', {
      version: 'v1',
      status: 'supported',
      releaseDate: '2024-01-01',
      features: ['Basic API functionality', 'User authentication', 'Order management'],
      breakingChanges: [],
      documentation: '/docs/api/v1',
    });

    // Deprecated version
    this.supportedVersions.set('v1.0', {
      version: 'v1.0',
      status: 'deprecated',
      releaseDate: '2023-10-01',
      deprecationDate: '2024-01-01',
      sunsetDate: '2024-12-31',
      replacementVersion: 'v1.2',
      features: ['Legacy API functionality'],
      breakingChanges: ['Complete API redesign', 'Authentication system overhaul'],
      migrationGuide: '/docs/migration/v1.0-to-v1.2',
      documentation: '/docs/api/v1.0',
    });
  }

  /**
   * Detect API version from request headers or URL path
   */
  public detectVersion(req: AuthenticatedRequest): VersionDetectionResult {
    let detectedVersion: string;
    let requestedVersion: string | undefined;

    // Priority 1: URL path versioning (e.g., /api/v1.2/users)
    const pathVersion = this.extractVersionFromPath(req.path);
    if (pathVersion && this.supportedVersions.has(pathVersion)) {
      detectedVersion = pathVersion;
      requestedVersion = pathVersion;
    } else {
      // Priority 2: Header-based versioning
      const versionHeaderValue = req.headers[this.config.versionHeader];
      const fallbackVersionValue = req.headers['x-api-version'];

      const headerVersion =
        (Array.isArray(versionHeaderValue) ? versionHeaderValue[0] : versionHeaderValue) ||
        (Array.isArray(fallbackVersionValue) ? fallbackVersionValue[0] : fallbackVersionValue);
      if (headerVersion && this.supportedVersions.has(headerVersion)) {
        detectedVersion = headerVersion;
        requestedVersion = headerVersion;
      } else {
        // Priority 3: Accept header versioning
        const acceptVersion = this.extractVersionFromAcceptHeader(req.headers.accept);
        if (acceptVersion && this.supportedVersions.has(acceptVersion)) {
          detectedVersion = acceptVersion;
          requestedVersion = acceptVersion;
        } else {
          // Default to latest stable version
          detectedVersion = this.config.defaultVersion;
        }
      }
    }

    const versionInfo = this.supportedVersions.get(detectedVersion)!;
    const isSupported = versionInfo.status !== 'unsupported';
    const isDeprecated = versionInfo.status === 'deprecated';

    let deprecationWarning: string | undefined;
    let migrationInfo: MigrationInfo | undefined;

    if (isDeprecated && this.config.enableDeprecationWarnings) {
      deprecationWarning = this.generateDeprecationWarning(versionInfo);

      if (this.config.enableMigrationHints && versionInfo.replacementVersion) {
        migrationInfo = this.generateMigrationInfo(detectedVersion, versionInfo.replacementVersion);
      }
    }

    return {
      detectedVersion,
      requestedVersion,
      isSupported,
      isDeprecated,
      deprecationWarning,
      migrationInfo,
    };
  }

  /**
   * Extract version from URL path
   */
  private extractVersionFromPath(path: string): string | null {
    const versionMatch = path.match(/\/api\/v(\d+(?:\.\d+)?)/);
    return versionMatch ? `v${versionMatch[1]}` : null;
  }

  /**
   * Extract version from Accept header
   */
  private extractVersionFromAcceptHeader(acceptHeader: string = ''): string | null {
    const versionMatch = acceptHeader.match(/application\/vnd\.hasivu\.v(\d+(?:\.\d+)?)\+json/);
    return versionMatch ? `v${versionMatch[1]}` : null;
  }

  /**
   * Generate deprecation warning message
   */
  private generateDeprecationWarning(versionInfo: ApiVersionInfo): string {
    const baseMessage = `API version ${versionInfo.version} is deprecated`;

    if (versionInfo.sunsetDate) {
      const sunsetDate = new Date(versionInfo.sunsetDate);
      const now = new Date();
      const daysUntilSunset = Math.ceil(
        (sunsetDate.getTime() - now.getTime()) / (1000 * 60 * 60 * 24)
      );

      if (daysUntilSunset > 0) {
        return `${baseMessage} and will be discontinued in ${daysUntilSunset} days (${versionInfo.sunsetDate}).`;
      } else {
        return `${baseMessage} and should no longer be used.`;
      }
    }

    if (versionInfo.replacementVersion) {
      return `${baseMessage}. Please migrate to ${versionInfo.replacementVersion}.`;
    }

    return `${baseMessage}. Please update to a supported version.`;
  }

  /**
   * Generate migration information
   */
  private generateMigrationInfo(fromVersion: string, toVersion: string): MigrationInfo {
    const fromInfo = this.supportedVersions.get(fromVersion);
    const toInfo = this.supportedVersions.get(toVersion);

    if (!fromInfo || !toInfo) {
      throw new Error(`Migration information not available for ${fromVersion} to ${toVersion}`);
    }

    // Get breaking changes between versions
    const breakingChanges = this.getBreakingChangesBetweenVersions(fromVersion, toVersion);
    const migrationSteps = this.getMigrationSteps(fromVersion, toVersion);

    return {
      fromVersion,
      toVersion,
      breakingChanges,
      migrationSteps,
      automatedMigration: false, // Manual migration required for major changes
      migrationGuide: `/docs/migration/${fromVersion}-to-${toVersion}`,
      migrationScript: `/scripts/migrate-${fromVersion}-to-${toVersion}.js`,
      testSuite: `/tests/migration/${fromVersion}-to-${toVersion}.test.js`,
      documentation: `/docs/migration/${fromVersion}-to-${toVersion}.md`,
    };
  }

  /**
   * Get breaking changes between versions
   */
  private getBreakingChangesBetweenVersions(fromVersion: string, toVersion: string): string[] {
    // Define breaking changes for version transitions
    const breakingChanges: Record<string, string[]> = {
      'v1.0-to-v1': [
        'Authentication endpoint moved from /auth to /api/v1/auth',
        'User ID format changed from integer to UUID',
        'Order status values updated',
      ],
      'v1-to-v1.1': [
        'Menu item structure includes nutrition information',
        'Payment webhook requires signature validation',
        'Error response format standardized',
      ],
      'v1.1-to-v1.2': [
        'RFID integration endpoints added',
        'Real-time notification system implemented',
        'Enhanced payment processing with multiple gateways',
      ],
      'v1.0-to-v1.2': [
        'Complete API redesign',
        'Authentication system overhaul with JWT',
        'New endpoint structure and naming conventions',
        'Enhanced error handling and validation',
        'Real-time features and WebSocket support',
      ],
    };

    return (
      breakingChanges[`${fromVersion}-to-${toVersion}`] || [
        'Please refer to the migration guide for detailed breaking changes',
      ]
    );
  }

  /**
   * Get migration steps between versions
   */
  private getMigrationSteps(fromVersion: string, toVersion: string): string[] {
    const migrationSteps: Record<string, string[]> = {
      'v1.0-to-v1': [
        'Update authentication endpoints',
        'Convert user IDs to UUID format',
        'Update order status handling',
        'Test all existing integrations',
      ],
      'v1-to-v1.1': [
        'Add nutrition info to menu items',
        'Implement webhook signature validation',
        'Update error response handling',
        'Test payment workflows',
      ],
      'v1.1-to-v1.2': [
        'Integrate RFID endpoints',
        'Implement real-time notifications',
        'Update payment gateway integration',
        'Test new features end-to-end',
      ],
      'v1.0-to-v1.2': [
        'Complete authentication system migration',
        'Update all API endpoints to new structure',
        'Implement new error handling patterns',
        'Add real-time notification support',
        'Comprehensive testing and validation',
      ],
    };

    return (
      migrationSteps[`${fromVersion}-to-${toVersion}`] || [
        'Please refer to the migration guide for detailed steps',
      ]
    );
  }

  /**
   * Check if endpoint supports specific version
   */
  public isEndpointCompatible(endpoint: string, version: string): boolean {
    const versionInfo = this.supportedVersions.get(version);
    if (!versionInfo) return false;

    // Define endpoint compatibility rules
    const endpointIntroductions: Record<string, string> = {
      '/api/rfid': 'v1.2',
      '/api/notifications/realtime': 'v1.2',
      '/api/payments/webhook': 'v1.1',
      '/api/menu/nutrition': 'v1.1',
      '/api/auth/refresh': 'v1',
    };

    const requiredVersion = endpointIntroductions[endpoint];
    if (!requiredVersion) return true; // Assume compatibility for unlisted endpoints

    return this.isVersionCompatible(version, requiredVersion);
  }

  /**
   * Check if version is compatible with required version
   */
  private isVersionCompatible(currentVersion: string, requiredVersion: string): boolean {
    try {
      // Remove 'v' prefix for semver comparison
      const current = currentVersion.replace(/^v/, '');
      const required = requiredVersion.replace(/^v/, '');

      return semver.gte(current, required);
    } catch (error) {
      this.logger.warn('Version comparison failed', { currentVersion, requiredVersion, error });
      return false;
    }
  }

  /**
   * Get all supported versions
   */
  public getSupportedVersions(): ApiVersionInfo[] {
    return Array.from(this.supportedVersions.values())
      .filter(version => version.status !== 'unsupported')
      .sort((a, b) => {
        // Sort by version number (newest first)
        try {
          const aVersion = a.version.replace(/^v/, '');
          const bVersion = b.version.replace(/^v/, '');
          return semver.rcompare(aVersion, bVersion);
        } catch {
          return b.version.localeCompare(a.version);
        }
      });
  }

  /**
   * Get version information
   */
  public getVersionInfo(version: string): ApiVersionInfo | null {
    return this.supportedVersions.get(version) || null;
  }

  /**
   * Update configuration
   */
  public updateConfig(newConfig: Partial<ApiVersioningConfig>): void {
    this.config = { ...this.config, ...newConfig };
    this.logger.info('API versioning configuration updated', { config: this.config });
  }

  /**
   * Add or update version information
   */
  public addVersion(versionInfo: ApiVersionInfo): void {
    this.supportedVersions.set(versionInfo.version, versionInfo);
    this.logger.info('API version added/updated', { version: versionInfo.version });
  }

  /**
   * Remove version
   */
  public removeVersion(version: string): boolean {
    const removed = this.supportedVersions.delete(version);
    if (removed) {
      this.logger.info('API version removed', { version });
    }
    return removed;
  }

  /**
   * Get version compatibility matrix
   */
  public getCompatibilityMatrix(clientVersion: string): VersionCompatibility[] {
    return Array.from(this.supportedVersions.keys()).map(apiVersion => {
      const compatible = this.isVersionCompatible(clientVersion, apiVersion);
      const warnings: string[] = [];
      const requiredChanges: string[] = [];

      if (!compatible) {
        warnings.push(`Client version ${clientVersion} is not compatible with API ${apiVersion}`);
        requiredChanges.push(`Upgrade client to support API ${apiVersion}`);
      }

      const versionInfo = this.supportedVersions.get(apiVersion)!;
      if (versionInfo.status === 'deprecated') {
        warnings.push(`API version ${apiVersion} is deprecated`);
        if (versionInfo.replacementVersion) {
          requiredChanges.push(`Migrate to ${versionInfo.replacementVersion}`);
        }
      }

      return {
        clientVersion,
        apiVersion,
        compatible,
        warnings,
        requiredChanges,
      };
    });
  }
}

// =============================================================================
// MIDDLEWARE FUNCTIONS
// =============================================================================

/**
 * API versioning middleware
 * Detects and validates API version from request
 */
export function apiVersioningMiddleware(
  req: AuthenticatedRequest,
  res: Response,
  next: NextFunction
): void | Response {
  const versionManager = ApiVersionManager.getInstance();

  try {
    // Detect version from request
    const versionResult = versionManager.detectVersion(req);

    // Attach version information to request
    req.apiVersion = versionResult.detectedVersion;
    req.versionInfo = versionResult;

    // Check if version is supported
    if (!versionResult.isSupported) {
      const error: ApiError = {
        code: 'UNSUPPORTED_API_VERSION',
        message: `API version ${versionResult.detectedVersion} is not supported`,
        timestamp: new Date().toISOString(),
        requestId: req.requestId,
      };

      return res.status(400).json({
        success: false,
        error,
        timestamp: new Date().toISOString(),
        version: req.apiVersion || 'unknown',
        supportedVersions: versionManager.getSupportedVersions().map(v => v.version),
      } as ApiResponse<unknown>);
    }

    // Add deprecation warning headers
    if (versionResult.isDeprecated && versionResult.deprecationWarning) {
      res.set('X-API-Deprecation-Warning', versionResult.deprecationWarning);

      if (versionResult.migrationInfo) {
        res.set('X-API-Migration-Guide', versionResult.migrationInfo.migrationGuide);
      }
    }

    // Add version information to response headers
    res.set('X-API-Version', versionResult.detectedVersion);
    res.set('X-API-Latest-Version', versionManager.getConfig().latestVersion);

    next();
  } catch (error) {
    const loggerInstance = logger;
    loggerInstance.error('API versioning middleware error', { error, path: req.path });

    const apiError: ApiError = {
      code: 'VERSION_DETECTION_ERROR',
      message: 'Failed to detect API version',
      timestamp: new Date().toISOString(),
      requestId: req.requestId,
    };

    res.status(500).json({
      success: false,
      error: apiError,
    } as ApiResponse);
  }
}

/**
 * Endpoint compatibility middleware
 * Checks if requested endpoint is compatible with detected API version
 */
export function endpointCompatibilityMiddleware(
  req: AuthenticatedRequest,
  res: Response,
  next: NextFunction
): void {
  const versionManager = ApiVersionManager.getInstance();

  try {
    const apiVersion = req.apiVersion || versionManager.getConfig().defaultVersion;
    const isCompatible = versionManager.isEndpointCompatible(req.path, apiVersion);

    if (!isCompatible) {
      const error: ApiError = {
        code: 'ENDPOINT_NOT_COMPATIBLE',
        message: `Endpoint ${req.path} is not available in API version ${apiVersion}`,
        timestamp: new Date().toISOString(),
        requestId: req.requestId,
        details: {
          endpoint: req.path,
          version: apiVersion,
          availableVersions: versionManager
            .getSupportedVersions()
            .filter(v => versionManager.isEndpointCompatible(req.path, v.version))
            .map(v => v.version),
        },
      };

      res.status(404).json({
        success: false,
        error,
      } as ApiResponse);
      return;
    }

    next();
  } catch (error) {
    const loggerInstance = logger;
    loggerInstance.error('Endpoint compatibility middleware error', { error, path: req.path });

    const apiError: ApiError = {
      code: 'COMPATIBILITY_CHECK_ERROR',
      message: 'Failed to check endpoint compatibility',
      timestamp: new Date().toISOString(),
      requestId: req.requestId,
    };

    res.status(500).json({
      success: false,
      error: apiError,
    } as ApiResponse);
  }
}

// =============================================================================
// UTILITY FUNCTIONS
// =============================================================================

/**
 * Compare two API versions
 */
export function compareApiVersions(version1: string, version2: string): number {
  try {
    const v1 = version1.replace(/^v/, '');
    const v2 = version2.replace(/^v/, '');
    return semver.compare(v1, v2);
  } catch (error) {
    // Fallback to string comparison
    return version1.localeCompare(version2);
  }
}

/**
 * Check if version is greater than or equal to target
 */
export function isVersionGTE(version: string, target: string): boolean {
  try {
    const v = version.replace(/^v/, '');
    const t = target.replace(/^v/, '');
    return semver.gte(v, t);
  } catch (error) {
    return version >= target;
  }
}

/**
 * Get latest version from list
 */
export function getLatestVersion(versions: string[]): string {
  if (versions.length === 0) return '';

  try {
    const semverVersions = versions.map(v => v.replace(/^v/, ''));
    const latest = semver.maxSatisfying(semverVersions, '*');
    return latest ? `v${latest}` : versions[versions.length - 1];
  } catch (error) {
    return versions.sort().reverse()[0];
  }
}

/**
 * Validate version format
 */
export function isValidVersionFormat(version: string): boolean {
  return /^v\d+(\.\d+)*$/.test(version);
}

/**
 * Normalize version string
 */
export function normalizeVersion(version: string): string {
  const normalized = version.toLowerCase().trim();
  return normalized.startsWith('v') ? normalized : `v${normalized}`;
}

/**
 * Extract major version number
 */
export function getMajorVersion(version: string): string {
  const match = version.match(/^v?(\d+)/);
  return match ? `v${match[1]}` : version;
}

/**
 * Generate version-specific route path
 */
export function generateVersionedPath(basePath: string, version: string): string {
  const normalizedVersion = normalizeVersion(version);
  const cleanPath = basePath.replace(/^\/+/, '');
  return `/api/${normalizedVersion}/${cleanPath}`;
}

/**
 * Create version deprecation notice
 */
export function createDeprecationNotice(
  version: string,
  sunsetDate?: string,
  replacementVersion?: string
): string {
  let notice = `This API version (${version}) is deprecated`;

  if (sunsetDate) {
    notice += ` and will be discontinued on ${sunsetDate}`;
  }

  if (replacementVersion) {
    notice += `. Please migrate to ${replacementVersion}`;
  }

  return notice + '.';
}

/**
 * Parse version from various sources
 */
export function parseVersionFromRequest(req: Request): {
  pathVersion?: string;
  headerVersion?: string;
  acceptVersion?: string;
} {
  const pathVersion = req.path.match(/\/api\/v(\d+(?:\.\d+)?)/)?.[1];
  const headerVersion = (req.headers['api-version'] || req.headers['x-api-version']) as string;
  const acceptVersion = req.headers.accept?.match(
    /application\/vnd\.hasivu\.v(\d+(?:\.\d+)?)\+json/
  )?.[1];

  return {
    pathVersion: pathVersion ? `v${pathVersion}` : undefined,
    headerVersion: headerVersion ? normalizeVersion(headerVersion) : undefined,
    acceptVersion: acceptVersion ? `v${acceptVersion}` : undefined,
  };
}

// =============================================================================
// VERSION MANAGEMENT UTILITIES
// =============================================================================

/**
 * Version manager for handling API lifecycle
 */
export class VersionLifecycleManager {
  private static instance: VersionLifecycleManager;
  private logger: any; // Logger instance for lifecycle operations

  private constructor() {
    this.logger = logger;
  }

  public static getInstance(): VersionLifecycleManager {
    if (!VersionLifecycleManager.instance) {
      VersionLifecycleManager.instance = new VersionLifecycleManager();
    }
    return VersionLifecycleManager.instance;
  }

  /**
   * Schedule version deprecation
   */
  public scheduleDeprecation(
    version: string,
    deprecationDate: Date,
    sunsetDate: Date,
    replacementVersion: string
  ): void {
    const versionManager = ApiVersionManager.getInstance();
    const versionInfo = versionManager.getVersionInfo(version);

    if (!versionInfo) {
      throw new Error(`Version ${version} not found`);
    }

    const updatedInfo: ApiVersionInfo = {
      ...versionInfo,
      status: 'deprecated',
      deprecationDate: deprecationDate.toISOString(),
      sunsetDate: sunsetDate.toISOString(),
      replacementVersion,
    };

    versionManager.addVersion(updatedInfo);
    this.logger.info('Version deprecation scheduled', {
      version,
      deprecationDate,
      sunsetDate,
      replacementVersion,
    });
  }

  /**
   * Sunset deprecated version
   */
  public sunsetVersion(version: string): void {
    const versionManager = ApiVersionManager.getInstance();
    const versionInfo = versionManager.getVersionInfo(version);

    if (!versionInfo) {
      throw new Error(`Version ${version} not found`);
    }

    if (versionInfo.status !== 'deprecated') {
      throw new Error(`Version ${version} is not deprecated and cannot be sunset`);
    }

    const updatedInfo: ApiVersionInfo = {
      ...versionInfo,
      status: 'unsupported',
    };

    versionManager.addVersion(updatedInfo);
    this.logger.info('Version sunset completed', { version });
  }

  /**
   * Get version usage analytics
   */
  public async getVersionUsageAnalytics(): Promise<{
    [version: string]: {
      requestCount: number;
      uniqueClients: number;
      errorRate: number;
      lastUsed: string;
    };
  }> {
    // This would typically integrate with analytics service
    // For now, return placeholder data
    return {
      v1: {
        requestCount: 1250,
        uniqueClients: 45,
        errorRate: 0.02,
        lastUsed: new Date().toISOString(),
      },
      'v1.1': {
        requestCount: 3400,
        uniqueClients: 120,
        errorRate: 0.015,
        lastUsed: new Date().toISOString(),
      },
      'v1.2': {
        requestCount: 5600,
        uniqueClients: 200,
        errorRate: 0.01,
        lastUsed: new Date().toISOString(),
      },
    };
  }
}

// =============================================================================
// REQUEST AUGMENTATION
// =============================================================================

/**
 * Augment AuthenticatedRequest interface with version information
 */
declare module 'express-serve-static-core' {
  interface Request {
    apiVersion?: string;
    versionInfo?: VersionDetectionResult;
  }
}

// =============================================================================
// ERROR CLASSES
// =============================================================================

/**
 * Version-related error
 */
export class VersionError extends Error {
  public readonly code: string;
  public readonly version: string;
  public readonly supportedVersions: string[];

  constructor(message: string, code: string, version: string, supportedVersions: string[] = []) {
    super(message);
    this.name = 'VersionError';
    this.code = code;
    this.version = version;
    this.supportedVersions = supportedVersions;
  }
}

/**
 * Deprecation warning error
 */
export class DeprecationError extends Error {
  public readonly version: string;
  public readonly sunsetDate?: string;
  public readonly replacementVersion?: string;

  constructor(message: string, version: string, sunsetDate?: string, replacementVersion?: string) {
    super(message);
    this.name = 'DeprecationError';
    this.version = version;
    this.sunsetDate = sunsetDate;
    this.replacementVersion = replacementVersion;
  }
}

// =============================================================================
// EXPORT CONFIGURATION
// =============================================================================

/**
 * Default API versioning configuration
 */
export const defaultVersioningConfig: ApiVersioningConfig = {
  defaultVersion: 'v1',
  latestVersion: 'v1.2',
  supportedVersions: ['v1', 'v1.1', 'v1.2'],
  deprecatedVersions: ['v1.0'],
  unsupportedVersions: ['v0.9', 'v0.8'],
  versionHeader: 'api-version',
  pathPrefix: '/api/',
  enableDeprecationWarnings: true,
  enableMigrationHints: true,
  strictVersioning: false,
};

/**
 * Initialize API versioning with default configuration
 */
export function initializeApiVersioning(config?: Partial<ApiVersioningConfig>): ApiVersionManager {
  const manager = ApiVersionManager.getInstance();

  if (config) {
    manager.updateConfig(config);
  }

  return manager;
}

// Export singleton instance for direct usage
export const apiVersionManager = ApiVersionManager.getInstance();
export const versionLifecycleManager = VersionLifecycleManager.getInstance();

// Export all types and utilities
export default {
  ApiVersionManager,
  VersionLifecycleManager,
  apiVersioningMiddleware,
  endpointCompatibilityMiddleware,
  compareApiVersions,
  isVersionGTE,
  getLatestVersion,
  isValidVersionFormat,
  normalizeVersion,
  getMajorVersion,
  generateVersionedPath,
  createDeprecationNotice,
  parseVersionFromRequest,
  initializeApiVersioning,
  defaultVersioningConfig,
  VersionError,
  DeprecationError,
};
