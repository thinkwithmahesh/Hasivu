/**
 * HASIVU Platform - School Hierarchy Manager Lambda Function
 * Epic 7.3: Enterprise Multi-School Management Platform
 *
 * Organization structure management for enterprise multi-school systems
 * Features: Hierarchy CRUD, role management, permission delegation, organizational reporting
 */

import { APIGatewayProxyEvent, APIGatewayProxyResult, Context } from 'aws-lambda';
import { logger } from '../../shared/utils/logger';
import { createSuccessResponse, createErrorResponse, handleError } from '../../shared/response.utils';
import { databaseService } from '../../shared/database.service';
import { jwtService } from '../../shared/services/jwt.service';

// Types
interface AuthenticatedUser {
  id: string;
  email: string;
  role: string;
  districtId?: string;
  tenantId?: string;
  isActive: boolean;
}

interface HierarchyNode {
  id: string;
  name: string;
  type: 'DISTRICT' | 'REGION' | 'SCHOOL' | 'DEPARTMENT';
  parentId?: string;
  level: number;
  code: string;
  metadata: Record<string, any>;
  isActive: boolean;
  children?: HierarchyNode[];
}

interface RoleAssignment {
  id: string;
  userId: string;
  roleId: string;
  scopeType: 'SYSTEM' | 'DISTRICT' | 'SCHOOL' | 'DEPARTMENT';
  scopeId: string;
  assignedBy: string;
  isActive: boolean;
  expiresAt?: Date;
  createdAt: Date;
}

interface PermissionMatrix {
  roleId: string;
  permissions: string[];
  inheritedFrom?: string[];
  canDelegate: string[];
  restrictions: string[];
}

// Authentication middleware
async function authenticateLambda(event: APIGatewayProxyEvent): Promise<AuthenticatedUser> {
  const token = event.headers.authorization?.replace('Bearer ', '');
  if (!token) {
    throw new Error('No authentication token provided');
  }

  const jwtResult = await jwtService.verifyToken(token);
  if (!jwtResult.isValid || !jwtResult.payload.userId) {
    throw new Error('Invalid authentication token');
  }

  return {
    id: jwtResult.payload.userId,
    email: jwtResult.payload.email,
    role: jwtResult.payload.role,
    districtId: (jwtResult.payload as any).districtId,
    tenantId: (jwtResult.payload as any).tenantId,
    isActive: true
  };
}

/**
 * School Hierarchy Manager Lambda Handler
 */
export const handler = async (
  event: APIGatewayProxyEvent,
  context: Context
): Promise<APIGatewayProxyResult> => {
  const requestId = context.awsRequestId;

  try {
    logger.info('School hierarchy manager request started', {
      requestId,
      httpMethod: event.httpMethod,
      path: event.path
    });

    // Authentication
    let authResult: AuthenticatedUser;
    try {
      authResult = await authenticateLambda(event);
    } catch (authError) {
      logger.warn('Authentication failed', { requestId, error: (authError as Error).message });
      return createErrorResponse('Authentication required', 401, 'UNAUTHORIZED');
    }

    const { httpMethod: method } = event;
    const pathParameters = event.pathParameters || {};
    const nodeId = pathParameters.nodeId;
    const db = databaseService.getPrismaClient();

    switch (method) {
      case 'GET':
        if (event.path?.includes('/hierarchy')) {
          return await getOrganizationHierarchy(authResult, db);
        } else if (event.path?.includes('/roles')) {
          return await getRoleAssignments(event.queryStringParameters, authResult, db);
        } else if (event.path?.includes('/permissions')) {
          return await getPermissionMatrix(event.queryStringParameters, authResult, db);
        } else if (nodeId) {
          return await getHierarchyNode(nodeId, authResult, db);
        } else {
          return await listHierarchyNodes(event.queryStringParameters, authResult, db);
        }

      case 'POST':
        if (event.path?.includes('/nodes')) {
          return await createHierarchyNode(JSON.parse(event.body || '{}'), authResult, db);
        } else if (event.path?.includes('/roles/assign')) {
          return await assignRole(JSON.parse(event.body || '{}'), authResult, db);
        } else if (event.path?.includes('/bulk-assign')) {
          return await bulkAssignRoles(JSON.parse(event.body || '{}'), authResult, db);
        }
        break;

      case 'PUT':
        if (nodeId && event.path?.includes('/move')) {
          return await moveHierarchyNode(nodeId, JSON.parse(event.body || '{}'), authResult, db);
        } else if (nodeId) {
          return await updateHierarchyNode(nodeId, JSON.parse(event.body || '{}'), authResult, db);
        } else if (event.path?.includes('/roles/update')) {
          return await updateRoleAssignment(JSON.parse(event.body || '{}'), authResult, db);
        }
        break;

      case 'DELETE':
        if (nodeId) {
          return await deleteHierarchyNode(nodeId, authResult, db);
        } else if (event.path?.includes('/roles/revoke')) {
          return await revokeRole(JSON.parse(event.body || '{}'), authResult, db);
        }
        break;

      default:
        return createErrorResponse('Method not allowed', 405, 'METHOD_NOT_ALLOWED');
    }

    return createErrorResponse('Invalid request path', 400, 'INVALID_PATH');

  } catch (error: unknown) {
    logger.error('School hierarchy manager request failed', {
      requestId,
      error: (error as Error).message,
      stack: (error as Error).stack
    });

    return handleError(error, 'Hierarchy management operation failed');
  }
};

/**
 * Get complete organization hierarchy
 */
async function getOrganizationHierarchy(
  user: AuthenticatedUser,
  db: any
): Promise<APIGatewayProxyResult> {
  try {
    let whereCondition = '';
    const params: any[] | undefined = [];

    // Filter by district for non-super admins
    if (user.role !== 'super_admin' && user.districtId) {
      whereCondition = 'WHERE district_id = $1 OR parent_district_id = $1';
      params.push(user.districtId);
    }

    const nodes = await db.$queryRawUnsafe(`
      SELECT
        id, name, type, parent_id, level, code,
        metadata, is_active, created_at, updated_at
      FROM hierarchy_nodes
      ${whereCondition}
      ORDER BY level ASC, name ASC
    `, ...params) as any[];

    // Build tree structure
    const hierarchy = buildHierarchyTree(nodes);

    return createSuccessResponse({
      data: { hierarchy },
      message: 'Organization hierarchy retrieved successfully'
    });

  } catch (error: unknown) {
    return handleError(error, 'Failed to retrieve organization hierarchy');
  }
}

/**
 * Build hierarchy tree from flat node list
 */
function buildHierarchyTree(nodes: any[] | undefined): HierarchyNode[] {
  if (!nodes || nodes.length === 0) {
    return [];
  }

  const nodeMap = new Map<string, HierarchyNode>();
  const rootNodes: HierarchyNode[] = [];

  // Create node map
  nodes.forEach(node => {
    nodeMap.set(node.id, {
      id: node.id,
      name: node.name,
      type: node.type,
      parentId: node.parent_id,
      level: node.level,
      code: node.code,
      metadata: JSON.parse(node.metadata || '{}'),
      isActive: node.is_active,
      children: []
    });
  });

  // Build tree structure
  nodes.forEach(node => {
    const hierarchyNode = nodeMap.get(node.id)!;

    if (node.parent_id) {
      const parent = nodeMap.get(node.parent_id);
      if (parent) {
        parent.children!.push(hierarchyNode);
      }
    } else {
      rootNodes.push(hierarchyNode);
    }
  });

  return rootNodes;
}

/**
 * Get hierarchy node details
 */
async function getHierarchyNode(
  nodeId: string,
  user: AuthenticatedUser,
  db: any
): Promise<APIGatewayProxyResult> {
  try {
    const node = await db.$queryRaw`
      SELECT
        id, name, type, parent_id, level, code,
        metadata, is_active, created_at, updated_at
      FROM hierarchy_nodes
      WHERE id = ${nodeId}
      AND (district_id = ${user.districtId} OR ${user.role === 'super_admin'})
    ` as any[];

    if (!node.length) {
      return createErrorResponse('Hierarchy node not found', 404, 'NODE_NOT_FOUND');
    }

    // Get children
    const children = await db.$queryRaw`
      SELECT id, name, type, level, code, is_active
      FROM hierarchy_nodes
      WHERE parent_id = ${nodeId}
      ORDER BY name ASC
    ` as any[];

    const nodeData = {
      ...node[0],
      metadata: JSON.parse(node[0].metadata || '{}'),
      children
    };

    return createSuccessResponse({
      data: { node: nodeData },
      message: 'Hierarchy node retrieved successfully'
    });

  } catch (error: unknown) {
    return handleError(error, 'Failed to retrieve hierarchy node');
  }
}

/**
 * Create new hierarchy node
 */
async function createHierarchyNode(
  nodeData: any,
  user: AuthenticatedUser,
  db: any
): Promise<APIGatewayProxyResult> {
  try {
    // Validation
    if (!nodeData.name || !nodeData.type || !nodeData.code) {
      return createErrorResponse('Name, type, and code are required', 400, 'VALIDATION_ERROR');
    }

    // Validate parent hierarchy
    let level = 1;
    let parentDistrictId = user.districtId;

    if (nodeData.parentId) {
      const parent = await db.$queryRaw`
        SELECT level, district_id FROM hierarchy_nodes
        WHERE id = ${nodeData.parentId}
      ` as any[];

      if (!parent.length) {
        return createErrorResponse('Parent node not found', 404, 'PARENT_NOT_FOUND');
      }

      level = parent[0].level + 1;
      parentDistrictId = parent[0].district_id;
    }

    // Check for duplicate code
    const existing = await db.$queryRaw`
      SELECT id FROM hierarchy_nodes
      WHERE code = ${nodeData.code}
      AND district_id = ${parentDistrictId}
    ` as any[];

    if (existing.length) {
      return createErrorResponse('Node with this code already exists', 409, 'DUPLICATE_CODE');
    }

    const nodeId = `node_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;

    const newNode = await db.$queryRaw`
      INSERT INTO hierarchy_nodes (
        id, name, type, parent_id, level, code,
        metadata, district_id, is_active, created_by, created_at, updated_at
      ) VALUES (
        ${nodeId},
        ${nodeData.name},
        ${nodeData.type},
        ${nodeData.parentId || null},
        ${level},
        ${nodeData.code},
        ${JSON.stringify(nodeData.metadata || {})},
        ${parentDistrictId},
        ${nodeData.isActive !== undefined ? nodeData.isActive : true},
        ${user.id},
        NOW(),
        NOW()
      ) RETURNING *
    ` as any[];

    return createSuccessResponse({
      data: { node: newNode[0] },
      message: 'Hierarchy node created successfully'
    }, 201);

  } catch (error: unknown) {
    return handleError(error, 'Failed to create hierarchy node');
  }
}

/**
 * Update hierarchy node
 */
async function updateHierarchyNode(
  nodeId: string,
  updateData: any,
  user: AuthenticatedUser,
  db: any
): Promise<APIGatewayProxyResult> {
  try {
    // Check if node exists and user has access
    const existing = await db.$queryRaw`
      SELECT id, district_id FROM hierarchy_nodes
      WHERE id = ${nodeId}
      AND (district_id = ${user.districtId} OR ${user.role === 'super_admin'})
    ` as any[];

    if (!existing.length) {
      return createErrorResponse('Hierarchy node not found', 404, 'NODE_NOT_FOUND');
    }

    const updateFields = [];
    const params: any[] | undefined = [];
    let paramIndex = 1;

    if (updateData.name !== undefined) {
      updateFields.push(`name = $${paramIndex++}`);
      params.push(updateData.name);
    }

    if (updateData.code !== undefined) {
      updateFields.push(`code = $${paramIndex++}`);
      params.push(updateData.code);
    }

    if (updateData.metadata !== undefined) {
      updateFields.push(`metadata = $${paramIndex++}`);
      params.push(JSON.stringify(updateData.metadata));
    }

    if (updateData.isActive !== undefined) {
      updateFields.push(`is_active = $${paramIndex++}`);
      params.push(updateData.isActive);
    }

    if (updateFields.length === 0) {
      return createErrorResponse('No valid fields to update', 400, 'NO_UPDATE_FIELDS');
    }

    updateFields.push(`updated_at = NOW()`);
    params.push(nodeId);

    const query = `
      UPDATE hierarchy_nodes
      SET ${updateFields.join(', ')}
      WHERE id = $${paramIndex++}
      RETURNING *
    `;

    const result = await db.$queryRawUnsafe(query, ...params) as any[];

    return createSuccessResponse({
      data: { node: result[0] },
      message: 'Hierarchy node updated successfully'
    });

  } catch (error: unknown) {
    return handleError(error, 'Failed to update hierarchy node');
  }
}

/**
 * Move hierarchy node to different parent
 */
async function moveHierarchyNode(
  nodeId: string,
  moveData: any,
  user: AuthenticatedUser,
  db: any
): Promise<APIGatewayProxyResult> {
  try {
    const { newParentId } = moveData;

    // Validate move operation
    if (newParentId === nodeId) {
      return createErrorResponse('Cannot move node to itself', 400, 'INVALID_MOVE');
    }

    // Check if new parent exists and calculate new level
    let newLevel = 1;
    if (newParentId) {
      const parent = await db.$queryRaw`
        SELECT level FROM hierarchy_nodes
        WHERE id = ${newParentId}
      ` as any[];

      if (!parent.length) {
        return createErrorResponse('New parent node not found', 404, 'PARENT_NOT_FOUND');
      }

      newLevel = parent[0].level + 1;

      // Check for circular dependency
      const isDescendant = await checkCircularDependency(nodeId, newParentId, db);
      if (isDescendant) {
        return createErrorResponse('Cannot move node to its descendant', 400, 'CIRCULAR_DEPENDENCY');
      }
    }

    // Update node and all its descendants
    await db.$transaction(async (tx: any) => {
      // Update the node itself
      await tx.$queryRaw`
        UPDATE hierarchy_nodes
        SET parent_id = ${newParentId}, level = ${newLevel}, updated_at = NOW()
        WHERE id = ${nodeId}
      `;

      // Update descendant levels
      await updateDescendantLevels(nodeId, newLevel, tx);
    });

    return createSuccessResponse({
      data: { nodeId, newParentId, newLevel },
      message: 'Hierarchy node moved successfully'
    });

  } catch (error: unknown) {
    return handleError(error, 'Failed to move hierarchy node');
  }
}

/**
 * Check for circular dependency in hierarchy
 */
async function checkCircularDependency(nodeId: string, newParentId: string, db: any): Promise<boolean> {
  const descendants = await db.$queryRaw`
    WITH RECURSIVE node_descendants AS (
      SELECT id, parent_id FROM hierarchy_nodes WHERE id = ${nodeId}
      UNION ALL
      SELECT h.id, h.parent_id
      FROM hierarchy_nodes h
      INNER JOIN node_descendants d ON h.parent_id = d.id
    )
    SELECT id FROM node_descendants WHERE id = ${newParentId}
  ` as any[];

  return descendants.length > 0;
}

/**
 * Update levels of all descendant nodes
 */
async function updateDescendantLevels(nodeId: string, baseLevel: number, tx: any): Promise<void> {
  await tx.$queryRaw`
    WITH RECURSIVE node_descendants AS (
      SELECT id, level FROM hierarchy_nodes WHERE parent_id = ${nodeId}
      UNION ALL
      SELECT h.id, h.level
      FROM hierarchy_nodes h
      INNER JOIN node_descendants d ON h.parent_id = d.id
    )
    UPDATE hierarchy_nodes h
    SET level = ${baseLevel + 1} + (
      SELECT COUNT(*) FROM hierarchy_nodes ancestors
      WHERE ancestors.id IN (
        WITH RECURSIVE ancestor_chain AS (
          SELECT parent_id, 0 as depth FROM hierarchy_nodes WHERE id = h.id
          UNION ALL
          SELECT hn.parent_id, ac.depth + 1
          FROM hierarchy_nodes hn
          INNER JOIN ancestor_chain ac ON hn.id = ac.parent_id
          WHERE hn.parent_id IS NOT NULL AND ac.depth < 10
        )
        SELECT parent_id FROM ancestor_chain WHERE parent_id IS NOT NULL
      ) AND ancestors.id != ${nodeId}
    ),
    updated_at = NOW()
    WHERE h.id IN (SELECT id FROM node_descendants)
  `;
}

/**
 * Get role assignments
 */
async function getRoleAssignments(
  queryParams: { [key: string]: string | undefined } | null,
  user: AuthenticatedUser,
  db: any
): Promise<APIGatewayProxyResult> {
  try {
    const page = parseInt(queryParams?.page || '1');
    const limit = parseInt(queryParams?.limit || '20');
    const offset = (page - 1) * limit;

    let whereCondition = '';
    const params: any[] | undefined = [];

    // Filter by scope for non-super admins
    if (user.role !== 'super_admin' && user.districtId) {
      whereCondition = 'WHERE (scope_type = \'DISTRICT\' AND scope_id = $1) OR (scope_type = \'SCHOOL\' AND scope_id IN (SELECT id FROM schools WHERE district_id = $1))';
      params.push(user.districtId);
    }

    // User filter
    if (queryParams?.userId) {
      if (whereCondition) {
        whereCondition += ` AND user_id = $${params.length + 1}`;
      } else {
        whereCondition = `WHERE user_id = $${params.length + 1}`;
      }
      params.push(queryParams.userId);
    }

    // Role filter
    if (queryParams?.roleId) {
      if (whereCondition) {
        whereCondition += ` AND role_id = $${params.length + 1}`;
      } else {
        whereCondition = `WHERE role_id = $${params.length + 1}`;
      }
      params.push(queryParams.roleId);
    }

    const countQuery = `SELECT COUNT(*) as total FROM user_administrative_roles ${whereCondition}`;
    const dataQuery = `
      SELECT
        uar.*, ar.role_name, ar.role_code,
        u.email, u.first_name, u.last_name
      FROM user_administrative_roles uar
      JOIN administrative_roles ar ON uar.role_id = ar.id
      JOIN users u ON uar.user_id = u.id
      ${whereCondition}
      ORDER BY uar.created_at DESC
      LIMIT $${params.length + 1} OFFSET $${params.length + 2}
    `;

    params.push(limit, offset);

    const [countResult, assignments] = await Promise.all([
      db.$queryRawUnsafe(countQuery, ...params.slice(0, -2)) as any[],
      db.$queryRawUnsafe(dataQuery, ...params) as any[]
    ]);

    const totalCount = parseInt(countResult[0]?.total || '0');
    const totalPages = Math.ceil(totalCount / limit);

    return createSuccessResponse({
      data: { assignments },
      pagination: {
        page,
        limit,
        total: totalCount,
        pages: totalPages,
        hasNext: page < totalPages,
        hasPrev: page > 1
      },
      message: 'Role assignments retrieved successfully'
    });

  } catch (error: unknown) {
    return handleError(error, 'Failed to retrieve role assignments');
  }
}

/**
 * Assign role to user
 */
async function assignRole(
  assignmentData: any,
  user: AuthenticatedUser,
  db: any
): Promise<APIGatewayProxyResult> {
  try {
    const { userId, roleId, scopeType, scopeId, expiresAt } = assignmentData;

    // Validation
    if (!userId || !roleId || !scopeType || !scopeId) {
      return createErrorResponse('userId, roleId, scopeType, and scopeId are required', 400, 'VALIDATION_ERROR');
    }

    // Check for existing assignment
    const existing = await db.$queryRaw`
      SELECT id FROM user_administrative_roles
      WHERE user_id = ${userId} AND role_id = ${roleId}
      AND scope_type = ${scopeType} AND scope_id = ${scopeId}
      AND is_active = true
    ` as any[];

    if (existing.length) {
      return createErrorResponse('Role already assigned to user for this scope', 409, 'ROLE_ALREADY_ASSIGNED');
    }

    const assignmentId = `assign_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;

    const newAssignment = await db.$queryRaw`
      INSERT INTO user_administrative_roles (
        id, user_id, role_id, scope_type, scope_id,
        assigned_by, expires_at, is_active, created_at, updated_at
      ) VALUES (
        ${assignmentId},
        ${userId},
        ${roleId},
        ${scopeType},
        ${scopeId},
        ${user.id},
        ${expiresAt ? new Date(expiresAt) : null},
        true,
        NOW(),
        NOW()
      ) RETURNING *
    ` as any[];

    return createSuccessResponse({
      data: { assignment: newAssignment[0] },
      message: 'Role assigned successfully'
    }, 201);

  } catch (error: unknown) {
    return handleError(error, 'Failed to assign role');
  }
}

/**
 * Bulk assign roles
 */
async function bulkAssignRoles(
  bulkData: any,
  user: AuthenticatedUser,
  db: any
): Promise<APIGatewayProxyResult> {
  try {
    const { assignments } = bulkData;

    if (!Array.isArray(assignments) || assignments.length === 0) {
      return createErrorResponse('Assignments array is required', 400, 'VALIDATION_ERROR');
    }

    const results = [];
    const errors = [];

    for (const assignment of assignments) {
      try {
        const assignmentId = `bulk_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;

        await db.$queryRaw`
          INSERT INTO user_administrative_roles (
            id, user_id, role_id, scope_type, scope_id,
            assigned_by, expires_at, is_active, created_at, updated_at
          ) VALUES (
            ${assignmentId},
            ${assignment.userId},
            ${assignment.roleId},
            ${assignment.scopeType},
            ${assignment.scopeId},
            ${user.id},
            ${assignment.expiresAt ? new Date(assignment.expiresAt) : null},
            true,
            NOW(),
            NOW()
          ) ON CONFLICT (user_id, role_id, scope_type, scope_id) DO NOTHING
        `;

        results.push({
          userId: assignment.userId,
          roleId: assignment.roleId,
          status: 'SUCCESS'
        });

      } catch (error: unknown) {
        errors.push({
          userId: assignment.userId,
          roleId: assignment.roleId,
          error: (error as Error).message
        });
      }
    }

    return createSuccessResponse({
      data: {
        successful: results.length,
        failed: errors.length,
        results,
        errors
      },
      message: 'Bulk role assignment completed'
    });

  } catch (error: unknown) {
    return handleError(error, 'Failed to perform bulk role assignment');
  }
}

/**
 * Get permission matrix
 */
async function getPermissionMatrix(
  queryParams: { [key: string]: string | undefined } | null,
  user: AuthenticatedUser,
  db: any
): Promise<APIGatewayProxyResult> {
  try {
    const roleId = queryParams?.roleId;

    if (roleId) {
      // Get specific role permissions
      const role = await db.$queryRaw`
        SELECT
          ar.*,
          parent.role_name as parent_role_name,
          parent.permissions as parent_permissions
        FROM administrative_roles ar
        LEFT JOIN administrative_roles parent ON ar.parent_role_id = parent.id
        WHERE ar.id = ${roleId}
      ` as any[];

      if (!role.length) {
        return createErrorResponse('Role not found', 404, 'ROLE_NOT_FOUND');
      }

      const roleData = role[0];
      const permissions = JSON.parse(roleData.permissions || '[]');
      const parentPermissions = JSON.parse(roleData.parent_permissions || '[]');
      const capabilities = JSON.parse(roleData.system_capabilities || '[]');
      const canDelegate = JSON.parse(roleData.can_delegate_to_roles || '[]');

      const matrix: PermissionMatrix = {
        roleId,
        permissions,
        inheritedFrom: parentPermissions,
        canDelegate,
        restrictions: [] // Calculate based on business rules
      };

      return createSuccessResponse({
        data: { permissionMatrix: matrix },
        message: 'Permission matrix retrieved successfully'
      });

    } else {
      // Get all roles and their permissions
      const roles = await db.$queryRaw`
        SELECT
          id, role_name, role_code, permissions,
          system_capabilities, can_delegate_to_roles,
          administrative_scope, role_level
        FROM administrative_roles
        WHERE is_active = true
        ORDER BY role_level ASC
      ` as any[];

      const matrices = roles.map(role => ({
        roleId: role.id,
        roleName: role.role_name,
        roleCode: role.role_code,
        permissions: JSON.parse(role.permissions || '[]'),
        capabilities: JSON.parse(role.system_capabilities || '[]'),
        canDelegate: JSON.parse(role.can_delegate_to_roles || '[]'),
        scope: role.administrative_scope,
        level: role.role_level
      }));

      return createSuccessResponse({
        data: { permissionMatrices: matrices },
        message: 'Permission matrices retrieved successfully'
      });
    }

  } catch (error: unknown) {
    return handleError(error, 'Failed to retrieve permission matrix');
  }
}

/**
 * List hierarchy nodes with filtering
 */
async function listHierarchyNodes(
  queryParams: { [key: string]: string | undefined } | null,
  user: AuthenticatedUser,
  db: any
): Promise<APIGatewayProxyResult> {
  try {
    const page = parseInt(queryParams?.page || '1');
    const limit = parseInt(queryParams?.limit || '50');
    const offset = (page - 1) * limit;

    let whereCondition = '';
    const params: any[] | undefined = [];

    // District filtering for non-super admins
    if (user.role !== 'super_admin' && user.districtId) {
      whereCondition = 'WHERE district_id = $1';
      params.push(user.districtId);
    }

    // Type filtering
    if (queryParams?.type) {
      if (whereCondition) {
        whereCondition += ` AND type = $${params.length + 1}`;
      } else {
        whereCondition = `WHERE type = $${params.length + 1}`;
      }
      params.push(queryParams.type);
    }

    // Level filtering
    if (queryParams?.level) {
      const level = parseInt(queryParams.level);
      if (whereCondition) {
        whereCondition += ` AND level = $${params.length + 1}`;
      } else {
        whereCondition = `WHERE level = $${params.length + 1}`;
      }
      params.push(level);
    }

    // Active status filtering
    if (queryParams?.active) {
      const isActive = queryParams.active === 'true';
      if (whereCondition) {
        whereCondition += ` AND is_active = $${params.length + 1}`;
      } else {
        whereCondition = `WHERE is_active = $${params.length + 1}`;
      }
      params.push(isActive);
    }

    const countQuery = `SELECT COUNT(*) as total FROM hierarchy_nodes ${whereCondition}`;
    const dataQuery = `
      SELECT
        id, name, type, parent_id, level, code,
        metadata, is_active, created_at, updated_at
      FROM hierarchy_nodes
      ${whereCondition}
      ORDER BY level ASC, name ASC
      LIMIT $${params.length + 1} OFFSET $${params.length + 2}
    `;

    params.push(limit, offset);

    const [countResult, nodes] = await Promise.all([
      db.$queryRawUnsafe(countQuery, ...params.slice(0, -2)) as any[],
      db.$queryRawUnsafe(dataQuery, ...params) as any[]
    ]);

    const totalCount = parseInt(countResult[0]?.total || '0');
    const totalPages = Math.ceil(totalCount / limit);

    return createSuccessResponse({
      data: {
        nodes: nodes.map(node => ({
          ...node,
          metadata: JSON.parse(node.metadata || '{}')
        }))
      },
      pagination: {
        page,
        limit,
        total: totalCount,
        pages: totalPages,
        hasNext: page < totalPages,
        hasPrev: page > 1
      },
      message: 'Hierarchy nodes retrieved successfully'
    });

  } catch (error: unknown) {
    return handleError(error, 'Failed to list hierarchy nodes');
  }
}

/**
 * Delete hierarchy node
 */
async function deleteHierarchyNode(
  nodeId: string,
  user: AuthenticatedUser,
  db: any
): Promise<APIGatewayProxyResult> {
  try {
    // Check if node has children
    const children = await db.$queryRaw`
      SELECT id FROM hierarchy_nodes WHERE parent_id = ${nodeId}
    ` as any[];

    if (children.length > 0) {
      return createErrorResponse('Cannot delete node with children', 400, 'NODE_HAS_CHILDREN');
    }

    const result = await db.$queryRaw`
      DELETE FROM hierarchy_nodes
      WHERE id = ${nodeId}
      AND (district_id = ${user.districtId} OR ${user.role === 'super_admin'})
      RETURNING id
    ` as any[];

    if (!result.length) {
      return createErrorResponse('Hierarchy node not found or access denied', 404, 'NODE_NOT_FOUND');
    }

    return createSuccessResponse({
      data: { nodeId },
      message: 'Hierarchy node deleted successfully'
    });

  } catch (error: unknown) {
    return handleError(error, 'Failed to delete hierarchy node');
  }
}

/**
 * Update role assignment
 */
async function updateRoleAssignment(
  updateData: any,
  user: AuthenticatedUser,
  db: any
): Promise<APIGatewayProxyResult> {
  try {
    const { assignmentId, expiresAt, isActive } = updateData;

    if (!assignmentId) {
      return createErrorResponse('Assignment ID is required', 400, 'VALIDATION_ERROR');
    }

    const updateFields = [];
    const params: any[] | undefined = [];
    let paramIndex = 1;

    if (expiresAt !== undefined) {
      updateFields.push(`expires_at = $${paramIndex++}`);
      params.push(expiresAt ? new Date(expiresAt) : null);
    }

    if (isActive !== undefined) {
      updateFields.push(`is_active = $${paramIndex++}`);
      params.push(isActive);
    }

    if (updateFields.length === 0) {
      return createErrorResponse('No valid fields to update', 400, 'NO_UPDATE_FIELDS');
    }

    updateFields.push(`updated_at = NOW()`);
    params.push(assignmentId);

    const query = `
      UPDATE user_administrative_roles
      SET ${updateFields.join(', ')}
      WHERE id = $${paramIndex++}
      RETURNING *
    `;

    const result = await db.$queryRawUnsafe(query, ...params) as any[];

    if (!result.length) {
      return createErrorResponse('Role assignment not found', 404, 'ASSIGNMENT_NOT_FOUND');
    }

    return createSuccessResponse({
      data: { assignment: result[0] },
      message: 'Role assignment updated successfully'
    });

  } catch (error: unknown) {
    return handleError(error, 'Failed to update role assignment');
  }
}

/**
 * Revoke role from user
 */
async function revokeRole(
  revokeData: any,
  user: AuthenticatedUser,
  db: any
): Promise<APIGatewayProxyResult> {
  try {
    const { assignmentId, reason } = revokeData;

    if (!assignmentId) {
      return createErrorResponse('Assignment ID is required', 400, 'VALIDATION_ERROR');
    }

    const result = await db.$queryRaw`
      UPDATE user_administrative_roles
      SET is_active = false, revoked_at = NOW(),
          revoked_by = ${user.id}, revocation_reason = ${reason || null},
          updated_at = NOW()
      WHERE id = ${assignmentId}
      RETURNING id, user_id, role_id
    ` as any[];

    if (!result.length) {
      return createErrorResponse('Role assignment not found', 404, 'ASSIGNMENT_NOT_FOUND');
    }

    return createSuccessResponse({
      data: {
        assignmentId,
        userId: result[0].user_id,
        roleId: result[0].role_id
      },
      message: 'Role revoked successfully'
    });

  } catch (error: unknown) {
    return handleError(error, 'Failed to revoke role');
  }
}

export default handler;